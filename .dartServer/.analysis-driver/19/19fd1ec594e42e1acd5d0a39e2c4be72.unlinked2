yhandleUnescapeErrorurilogEventbeginArgumentsendArgumentshandleObjectPatternFieldshandleAsyncModifierbeginAwaitExpressionendAwaitExpressionendInvalidAwaitExpression
beginBlockendBlockhandleInvalidTopLevelBlockbeginCascade
endCascadebeginCaseExpressionendCaseExpression beginClassOrMixinOrExtensionBodyendClassOrMixinOrExtensionBody/beginClassOrMixinOrNamedMixinApplicationPreludebeginClassDeclarationhandleClassExtendshandleImplementshandleClassHeaderhandleRecoverDeclarationHeaderendClassDeclarationbeginMixinDeclarationhandleMixinOnhandleMixinHeaderhandleRecoverMixinHeaderendMixinDeclaration%beginUncategorizedTopLevelDeclaration beginExtensionDeclarationPreludebeginExtensionDeclarationendExtensionDeclarationbeginExtensionTypeDeclarationendExtensionTypeDeclarationbeginPrimaryConstructorendPrimaryConstructorhandleNoPrimaryConstructorbeginCombinatorsendCombinatorsbeginCompilationUnithandleDirectivesOnlyendCompilationUnitbeginConstLiteralendConstLiteralbeginConstructorReferenceendConstructorReferencebeginDoWhileStatementendDoWhileStatementbeginDoWhileStatementBodyendDoWhileStatementBodybeginWhileStatementBodyendWhileStatementBody	beginEnumendEnumendEnumConstructorhandleEnumElementshandleEnumHeaderhandleEnumElementendEnumFactoryMethodbeginExport	endExporthandleExtraneousExpressionhandleExpressionStatementbeginFactoryMethodendClassFactoryMethodendMixinFactoryMethodendExtensionFactoryMethodendExtensionTypeFactoryMethodbeginFormalParameterendFormalParameterhandleNoFormalParametersbeginFormalParametersendFormalParametersendClassFieldsendMixinFieldsendExtensionFieldsendExtensionTypeFieldsendEnumFieldsendEnumMethod"handleForInitializerEmptyStatement'handleForInitializerExpressionStatement,handleForInitializerLocalVariableDeclaration-handleForInitializerPatternVariableAssignmentbeginForStatementhandleForLoopPartsendForStatementbeginForStatementBodyendForStatementBodyhandleForInLoopPartsendForInbeginForInExpressionendForInExpressionbeginForInBodyendForInBodybeginNamedFunctionExpressionendNamedFunctionExpressionbeginLocalFunctionDeclarationendLocalFunctionDeclarationbeginBlockFunctionBodyendBlockFunctionBodyhandleNoFunctionBodyhandleFunctionBodySkippedbeginFunctionNameendFunctionNamebeginTypedef
endTypedefhandleClassWithClausehandleClassNoWithClausehandleEnumWithClausehandleEnumNoWithClausehandleMixinWithClausebeginNamedMixinApplication%handleNamedMixinApplicationWithClauseendNamedMixinApplication	beginHideendHidehandleIdentifierListbeginTypeListendTypeListbeginIfStatementendIfStatementbeginThenStatementendThenStatementbeginElseStatementendElseStatementbeginImporthandleImportPrefix	endImporthandleRecoverImportbeginConditionalUrisendConditionalUrisbeginConditionalUriendConditionalUrihandleDottedNamebeginImplicitCreationExpressionendImplicitCreationExpressionbeginInitializedIdentifierendInitializedIdentifierbeginFieldInitializerendFieldInitializerhandleNoFieldInitializerbeginVariableInitializerendVariableInitializerhandleNoVariableInitializerbeginInitializerendInitializerbeginInitializersendInitializershandleNoInitializershandleInvalidExpressionhandleInvalidFunctionBodyhandleInvalidTypeReferencehandleLabelbeginLabeledStatementendLabeledStatementbeginLibraryAugmentationendLibraryAugmentationbeginLibraryNameendLibraryNamehandleLiteralMapEntryhandleMapPatternEntrybeginLiteralStringhandleInterpolationExpressionendLiteralStringhandleAdjacentStringLiteralsbeginMemberhandleInvalidMember	endMemberbeginMethodendClassMethodendMixinMethodendExtensionMethodendExtensionTypeMethodendClassConstructorendMixinConstructorendExtensionConstructorendExtensionTypeConstructorbeginMetadataStarendMetadataStarbeginMetadataendMetadatabeginOptionalFormalParametersendOptionalFormalParameters	beginPartendPartbeginPartOf	endPartOfbeginRedirectingFactoryBodyendRedirectingFactoryBodybeginReturnStatementhandleNativeFunctionBodyhandleNativeFunctionBodyIgnoredhandleNativeFunctionBodySkippedhandleEmptyFunctionBodyhandleExpressionFunctionBodyendReturnStatement
handleSend	beginShowendShowbeginSwitchStatementendSwitchStatementbeginSwitchExpressionendSwitchExpressionbeginSwitchBlockendSwitchBlockbeginSwitchExpressionBlockendSwitchExpressionBlockbeginLiteralSymbolendLiteralSymbolhandleThrowExpressionbeginRethrowStatementendRethrowStatementendTopLevelDeclaration handleInvalidTopLevelDeclarationbeginTopLevelMemberbeginFieldsendTopLevelFieldsbeginTopLevelMethodendTopLevelMethodbeginTryStatementbeginCatchClauseendCatchClausehandleCatchBlockhandleFinallyBlockendTryStatement
handleTypehandleNonNullAssertExpressionhandleNullAssertPatternhandleNullCheckPatternhandleAssignedVariablePatternhandleDeclaredVariablePatternhandleWildcardPatternhandleNoNamebeginRecordTypeendRecordTypebeginRecordTypeEntryendRecordTypeEntrybeginRecordTypeNamedFieldsendRecordTypeNamedFieldsbeginFunctionTypeendFunctionTypebeginTypeArgumentsendTypeArgumentshandleInvalidTypeArgumentshandleNoTypeArgumentsbeginTypeVariablehandleTypeVariablesDefinedendTypeVariablebeginTypeVariablesendTypeVariables reportVarianceModifierNotEnabledbeginFunctionExpressionendFunctionExpressionbeginVariablesDeclarationendVariablesDeclarationbeginWhileStatementendWhileStatementbeginAsOperatorTypeendAsOperatorTypehandleAsOperatorhandleCastPatternhandleAssignmentExpressionbeginBinaryExpressionendBinaryExpressionbeginBinaryPatternendBinaryPatternhandleDotAccesshandleCascadeAccessbeginConditionalExpression handleConditionalExpressionColonendConditionalExpressionbeginConstExpressionendConstExpressionhandleConstFactorybeginForControlFlowendForControlFlowendForInControlFlowbeginIfControlFlowhandleThenControlFlowhandleElseControlFlowendIfControlFlowendIfElseControlFlowhandleSpreadExpressionhandleNullAwareElementhandleRestPattern!beginFunctionTypedFormalParameterendFunctionTypedFormalParameterhandleIdentifierhandleIndexedExpressionbeginIsOperatorTypeendIsOperatorTypehandleIsOperatorhandleLiteralBoolhandleBreakStatementhandleContinueStatementhandleEmptyStatementbeginAssert	endAsserthandleLiteralDouble!handleLiteralDoubleWithSeparatorshandleLiteralInthandleLiteralIntWithSeparatorshandleLiteralListhandleListPatternhandleLiteralSetOrMaphandleMapPatternhandleLiteralNullhandleNativeClausehandleNamedArgumenthandlePatternFieldhandleNamedRecordFieldbeginNewExpressionendNewExpressionhandleNoArguments:handleNoConstructorReferenceContinuationAfterTypeArguments&handleNoTypeNameInConstructorReferencehandleNoTypehandleNoTypeVariableshandleOperatorhandleSwitchCaseNoWhenClause!handleSwitchExpressionCasePatternhandleSymbolVoidhandleOperatorNamehandleInvalidOperatorNamehandleParenthesizedConditionbeginPatternbeginPatternGuard+beginParenthesizedExpressionOrRecordLiteralbeginSwitchCaseWhenClauseendRecordLiteralhandleRecordPattern
endPatternendPatternGuardendParenthesizedExpressionendSwitchCaseWhenClausehandleParenthesizedPatternbeginConstantPatternendConstantPatternhandleObjectPatternhandleQualifiedhandleStringParthandleSuperExpressionhandleAugmentSuperExpressionbeginSwitchCaseendSwitchCasebeginSwitchExpressionCaseendSwitchExpressionCasehandleThisExpression&handleUnaryPostfixAssignmentExpressionhandleUnaryPrefixExpressionhandleRelationalPattern%handleUnaryPrefixAssignmentExpression*beginFormalParameterDefaultValueExpression(endFormalParameterDefaultValueExpressionhandleValuedFormalParameter!handleFormalParameterWithoutValuehandleVoidKeyword"handleVoidKeywordWithTypeArgumentsbeginYieldStatementendYieldStatementendInvalidYieldStatementhandleRecoverableErrorhandleExperimentNotEnabledhandleErrorTokenhandleInvalidStatementhandleScripthandleTypeArgumentApplicationhandleNewAsIdentifier)handlePatternVariableDeclarationStatementhandlePatternAssignmenthandleDotShorthandContexthandleDotShorthandHeadbeginConstDotShorthandendConstDotShorthandUnescapeErrorListenerListener_fe_analyzer_sharedparserlistenerMessageMessageCodeToken
ErrorTokenAssert	BlockKindConstructorReferenceContextFormalParameterKindIdentifierContextDeclarationHeaderKindDeclarationKind
MemberKindvoidintUriStringboolParserparseDirectivesnullAwareKeyTokennullAwareValueTokeninAssignmentPatternExperimentalFlagvariancegetExperimentNotEnabledMessageassertionMessageoverrideUnescapeErrorListenerÈd{ùF¹ñóÅ3™ ¯˜    +   ../experiments/errors.dart  P   ../experiments/flags.dart“¬MessageMessageCode t   ../messages/codes.dartÎØToken °   ../scanner/token.dart‚ ‚
ErrorToken Ü   ../scanner/error_token.dart‚'‚2Assert ‚   assert.dart‚N‚\	BlockKind ‚6   block_kind.dart‚‹‚«ConstructorReferenceContext ‚`   "constructor_reference_context.dart‚Ò‚êFormalParameterKind ‚¯   formal_parameter_kind.dartƒƒ$IdentifierContext ‚î   identifier_context.dartƒFƒqDeclarationHeaderKindDeclarationKind ƒ(   declaration_kind.dartƒƒ
MemberKind ƒu   member_kind.dartÀ õü À7ôŠ³ N€œ€Ø€Ù€ü)*Os®¯ÚÛ‚‚‚4‚5‚^‚_‚­‚®‚ì‚íƒ&ƒ'ƒsƒtƒŸƒ ƒÇƒãƒø„„ „0„5„7„8„~„”„˜„ä„è….…~…”…˜…ç…ò†$†<†=†]†^†„†…†È†ã†ç†è‡4‡b‡²‡×‡Û‡ÜˆˆVˆuˆyˆzˆÅˆñˆò‰-‰K‰‰‰ª‰®‰¯‰êŠŠ*Š@ŠTŠoŠuŠŠ¡Š¢ŠÙŠÚŠëŠú‹‹$‹=‹C‹Z‹^‹_‹©‹ç‹õŒ'Œ(ŒLŒMŒcŒ|Œ€ŒŒ²Œ³Œû n¹Çc«±î/DZnt¡¥¦óZœºÀé‘0‘1‘d‘§‘ñ‘÷’D’b’s’’¤’¼’Ò’í“““4“D“K“L“’“Á””_”m”¯”Í”Ñ”Ò••0•J•“•¯•³•´•ô–––*–A–S–g––—–ç———	—Q—“—Ñ—ù˜-˜?˜S˜m˜±˜Û˜ß˜à™™2™E™„™¦™ª™«™Ş™üšš+šAšYšišpšqš²šÌ›››!›"›b›s›†››®›È›÷œœœœOœ‘œÏDUo‘¥Éíñò/D`ŸÁÅÆŸŸ
Ÿ3ŸpŸqŸÁŸÒŸØ & s y ¢ å æ¡6¡M¡S¡ ¡Â¡Û¡÷¢¢¢¢Z¢‘¢¡¢®¢Î¢ä£ ££*£0£V£Z£[£¨£¿£Å¤¤8¤S¤o¤¤†¤‡¤Ñ¥¥0¥J¥W¥{¥‘¥ª¥Æ¥İ¥ñ¥÷¦!¦%¦&¦r¦¢¦Õ¦ù¦ı¦ş§H§–§´§º§ê§ğ¨¨B¨R¨p¨†¨Ÿ¨¼¨Â¨æ¨ê¨ë©:©j©±©²©Ú©Û©şªªª ªLªMª†ªËªÑ««_«p«‘«’«Æ«ç«ë«ì¬¬¬G¬p¬¬’¬“¬Ä¬Å¬ø­­)­F­Z­—­­Ã­Ç­È­õ­ö®-®I®^®v®Š®®²®¶®·®è®é¯¯=¯A¯B¯q¯r¯¥¯Ô¯ø¯ü¯ı°$°%°b°°•°¥°»°Ò°ç°ü±±±,±0±1±z±‹±Ÿ±Ô±ë²²²/²<²W²l²‚²˜²¶²Ê²Ğ³³$³4³F³X³q³³ˆ³Œ³³¼³Û³ò´9´W´[´\´œ´­´Ì´ã´÷µµ*µCµZµoµuµ‘µ•µ–µÄµÕµõ¶7¶T¶X¶Y¶v¶Œ¶¦¶º¶À····)·*·g·x·„··±·ê¸¸¸¸P¸Ÿ¸Ã¹¹+¹/¹0¹u¹š¹¹Ÿ¹Ùºº2ºWºoº‰º º§º¨ºÆºÜºö»
»»4»8»9»W»m»‡»›»¡»á¼"¼&¼'¼I¼_¼y¼¼“¼Ó½½½½?½U½o½ƒ½‰½É¾
¾¾¾,¾=¾R¾l¾‡¾£¾ª¾«¾Æ¾Ş¾÷¿¿/¿L¿g¿…¿ ¿¦¿Ç¿Ë¿ÌÀ @À @0À @4À @5À @sÀ @tÀ @À @ŸÀ @µÀ @ÉÀ @ŞÀ @äÀ AÀ A
À AÀ ANÀ A_À AqÀ A~À AªÀ A°À AĞÀ AçÀ BÀ BÀ B4À BLÀ BgÀ B}À B™À B¨À B¾À BÒÀ BØÀ BğÀ BôÀ BõÀ C8À CIÀ C[À ChÀ C”À CšÀ CºÀ CÑÀ CëÀ DÀ DÀ D6À DQÀ DgÀ DƒÀ D’À D¨À D¼À DÂÀ EÀ EÀ E+À E?À ETÀ EgÀ E}À EÀ E¥À E²À EÄÀ EÔÀ EÛÀ EßÀ EàÀ F'À F8À FJÀ FWÀ FƒÀ F‰À F©À FÄÀ FŞÀ F÷À GÀ G)À GDÀ GZÀ GvÀ G…À G›À G¯À GµÀ GõÀ H	À HÀ H2À HGÀ HZÀ HpÀ HÀ H˜À H¥À H·À HÇÀ HÎÀ HÒÀ HÓÀ IÀ I0À IBÀ IOÀ I{À IÀ I¡À IÀÀ IÚÀ IóÀ JÀ J%À J@À JVÀ JrÀ JÀ J—À J«À J±À JñÀ KÀ KÀ K.À KCÀ KVÀ KlÀ K}À K”À K¡À K³À KÃÀ KÊÀ KÎÀ KÏÀ LÀ L#À L5À LBÀ LnÀ LtÀ L”À LªÀ LÄÀ LİÀ L÷À MÀ M*À M@À M\À MkÀ MÀ M•À M›À M¯À MÄÀ MØÀ MíÀ N À NÀ N'À N>À NKÀ N]À NmÀ NtÀ NxÀ NyÀ N½À NÎÀ NâÀ OÀ O.À OHÀ O]À OrÀ OÀ O•À OªÀ OÀÀ OÖÀ OôÀ PÀ PÀ P"À P2À PDÀ PVÀ PoÀ PÀ P†À PŠÀ P‹À PÛÀ PüÀ Q5À QcÀ QgÀ QhÀ Q¸À QŞÀ R(À R[À R_À R`À R°À RæÀ SÀ SjÀ S¢À S¦À S§À S÷À T-À T^À T”À T§À T¹À T¿À TşÀ UÀ UÀ UEÀ UlÀ U•À U–À UŞÀ V+À ViÀ V„À VšÀ V¯À VÈÀ VâÀ WÀ WÀ W	À W<À WeÀ WƒÀ W‡À WˆÀ WµÀ W¶À WéÀ XÀ X8À X<À X=À XˆÀ XÕÀ YÀ YFÀ Y–À YµÀ YğÀ ZÀ Z$À Z8À ZSÀ ZnÀ ZƒÀ ZŠÀ Z‹À ZÚÀ [À [/À [FÀ [JÀ [KÀ [wÀ [xÀ [¡À [ÂÀ [ÆÀ [ÇÀ [íÀ [îÀ \!À \GÀ \bÀ \fÀ \gÀ \³À ]À ]QÀ ]—À ]À ]²À ]ÉÀ ]ıÀ ]şÀ ^BÀ ^ŒÀ ^ØÀ _À _À _0À _GÀ _YÀ _mÀ _zÀ _ŠÀ _ŸÀ _¶À _éÀ `À `PÀ `yÀ `}À `~À `ÊÀ `ÛÀ `òÀ a'À a(À aFÀ aLÀ aaÀ arÀ a‰À aÀ aªÀ aÁÀ aÑÀ aæÀ aıÀ b0À bcÀ b˜À b½À bÁÀ bÂÀ c
À cYÀ c¨À cÒÀ d À dÀ dNÀ d—À dæÀ e4À e{À e¯À eúÀ fÀ f!À f"À fMÀ fmÀ fqÀ frÀ fºÀ fÀÀ gÀ g2À gzÀ g{À g¤À g¥À gõÀ hÀ hÀ h"À h>À hJÀ hPÀ hŒÀ h’À h§À hÌÀ hØÀ hŞÀ i+À i7À iOÀ ieÀ ivÀ i•À i›À i¹À i½À i¾À iâÀ iãÀ jÀ jÀ j]À jnÀ j‚À jœÀ j¹À jÓÀ jÙÀ k#À k4À kNÀ kkÀ k‘À kÄÀ k×À kğÀ l
À lÀ l1À l7À lZÀ l^À l_À lŸÀ l´À lÓÀ mÀ m&À m*À m+À m\À mÀ m¢À m¦À m§À mçÀ müÀ nÀ n!À niÀ nÀ nÏÀ nïÀ nóÀ nôÀ o%À oGÀ oiÀ omÀ onÀ o®À oÃÀ oâÀ oèÀ p(À p^À pÀ p±À pµÀ p¶À pïÀ q7À qÀ q‡À qÔÀ q÷À rÀ r'À r>À rVÀ rlÀ r‡À rÀ r·À rÎÀ rŞÀ råÀ ræÀ s/À sDÀ sVÀ suÀ s·À sèÀ sìÀ síÀ t0À tAÀ tSÀ tfÀ t}À tÀ t£À tÈÀ tÎÀ uÀ ucÀ u³À uóÀ uùÀ v<À v]À vnÀ v†À v˜À v¶À vÊÀ vĞÀ v÷À vûÀ vüÀ w#À w$À waÀ w‡À w«À wÁÀ wÅÀ wÆÀ wïÀ xÀ xÀ xÀ x9À x:À xZÀ xtÀ xxÀ xyÀ x¡À x¢À xëÀ yÀ yÀ yÀ y7À y8À ytÀ y“À y—À y˜À yÂÀ yÃÀ yïÀ z+À zJÀ zNÀ zOÀ zzÀ z{À zÁÀ { À {2À {hÀ {®À {ÌÀ {ĞÀ {ÑÀ |À |À |+À |DÀ |^À |rÀ |ÁÀ |ÙÀ |İÀ |ŞÀ }À }SÀ }•À }ãÀ }üÀ ~À ~*À ~YÀ ~yÀ ~}À ~~À ~ªÀ ~«À ~ÒÀ ~óÀ ~÷À ~øÀ 'À (À mÀ À ÁÀ ŞÀ €-À €MÀ €QÀ €RÀ €À €ªÀ €®À €¯À €æÀ €çÀ 3À _À cÀ dÀ –À —À ÊÀ ñÀ õÀ öÀ ‚#À ‚$À ‚aÀ ‚€À ‚³À ‚òÀ ƒÀ ƒÀ ƒÀ ƒGÀ ƒvÀ ƒšÀ ƒÀ ƒŸÀ ƒÏÀ ƒĞÀ „À „/À „iÀ „À „’À „“À „ÂÀ „ôÀ …À …À … À …HÀ …IÀ …|À …¤À …ÌÀ …ĞÀ …ÑÀ …úÀ …ûÀ †AÀ †_À †cÀ †dÀ †„À †¤À †¨À †©À †÷À ‡DÀ ‡iÀ ‡—À ‡ºÀ ‡¾À ‡¿À ˆÀ ˆVÀ ˆÀ ˆÀÀ ˆåÀ ˆéÀ ˆêÀ ‰9À ‰ƒÀ ‰’À ‰ÃÀ ‰éÀ ‰íÀ ‰îÀ ŠÀ Š'À Š+À Š,À ŠiÀ ŠjÀ Š—À Š¹À Š½À Š¾À ‹À ‹À ‹XÀ ‹iÀ ‹uÀ ‹”À ‹®À ‹ÈÀ ‹İÀ ‹ãÀ ŒÀ ŒÀ ŒÀ Œ5À Œ6À ŒsÀ Œ„À Œ²À ŒÿÀ À  À !À qÀ ÂÀ À À *À ]À {À ŒÀ ¢À ÀÀ àÀ çÀ À À À \À †À ¹À õÀ À À À EÀ FÀ –À —À ÊÀ ‘À ‘+À ‘/À ‘0À ‘zÀ ‘¢À ‘¦À ‘§À ‘öÀ ’2À ’~À ’¡À ’¹À ’ºÀ ’õÀ “À “9À “fÀ “…À “‰À “ŠÀ “ÅÀ ”À ”À ”JÀ ”ŠÀ ”ÊÀ ”şÀ •*À •?À •WÀ •[À •\À •«À •¼À –À –XÀ –pÀ –„À –©À –ÂÀ –ÜÀ –ôÀ —À —+À —@À —PÀ —vÀ —}À —~À —ÂÀ —ÓÀ —çÀ ˜À ˜3À ˜MÀ ˜bÀ ˜wÀ ˜„À ˜›À ˜°À ˜ÆÀ ˜ÜÀ ˜úÀ ™À ™À ™1À ™5À ™6À ™zÀ ™‹À ™ŸÀ ™ÔÀ ™ëÀ šÀ šÀ š/À š<À šSÀ šhÀ š~À š”À š²À šÆÀ šÌÀ ›À › À ›0À ›BÀ ›TÀ ›mÀ ›}À ›„À ›ˆÀ ›‰À ›ÑÀ ›âÀ ›öÀ œ+À œBÀ œ\À œqÀ œ†À œ“À œ®À œÃÀ œÙÀ œïÀ À !À 'À gÀ {À ‹À À ¯À ÈÀ ØÀ ßÀ ãÀ äÀ 1À BÀ VÀ ‹À ¢À ¼À ÑÀ æÀ óÀ ŸÀ Ÿ'À Ÿ=À ŸSÀ ŸqÀ Ÿ…À Ÿ‹À ŸËÀ ŸßÀ ŸïÀ  À  À  ,À  <À  CÀ  GÀ  HÀ  ‘À  ¢À  ¶À  ëÀ ¡À ¡À ¡1À ¡FÀ ¡SÀ ¡oÀ ¡„À ¡šÀ ¡°À ¡ÎÀ ¡âÀ ¡èÀ ¢(À ¢<À ¢LÀ ¢^À ¢pÀ ¢‰À ¢™À ¢ À ¢¤À ¢¥À ¢îÀ ¢ÿÀ £À £HÀ £_À £yÀ £À ££À £°À £ÌÀ £áÀ £÷À ¤À ¤+À ¤?À ¤EÀ ¤…À ¤™À ¤©À ¤»À ¤ÍÀ ¤æÀ ¤öÀ ¤ıÀ ¥À ¥À ¥OÀ ¥`À ¥tÀ ¥©À ¥ÀÀ ¥ÚÀ ¥ïÀ ¦À ¦À ¦1À ¦FÀ ¦\À ¦rÀ ¦À ¦¤À ¦ªÀ ¦êÀ ¦şÀ §À § À §2À §KÀ §[À §bÀ §fÀ §gÀ §ªÀ §¿À §ĞÀ §äÀ ¨À ¨0À ¨JÀ ¨_À ¨tÀ ¨À ¨¥À ¨ºÀ ¨ĞÀ ¨æÀ ©À ©À ©À ©^À ©wÀ ©‡À ©™À ©«À ©ÄÀ ©ÔÀ ©ÛÀ ©ßÀ ©àÀ ª	À ª
À ª.À ªLÀ ªPÀ ªQÀ ªvÀ ªwÀ ª¶À ªÉÀ ªàÀ «$À «6À «†À « À «¤À «¥À «ÚÀ «ÛÀ «ÿÀ ¬À ¬$À ¬8À ¬MÀ ¬SÀ ¬}À ¬À ¬‚À ¬£À ¬¤À ¬ŞÀ ¬ïÀ ¬ûÀ ­0À ­FÀ ­JÀ ­KÀ ­nÀ ­oÀ ­®À ­¿À ­íÀ ­óÀ ®CÀ ®QÀ ®cÀ ®zÀ ®À ®¤À ®¶À ®¼À ®ÔÀ ®ØÀ ®ÙÀ ¯À ¯À ¯RÀ ¯zÀ ¯~À ¯À ¯«À ¯¬À ¯ÙÀ °À °aÀ °…À °‰À °ŠÀ °×À ±À ±[À ±rÀ ±¿À ±êÀ ±îÀ ±ïÀ ²;À ²}À ²ÊÀ ²õÀ ²ùÀ ²úÀ ³;À ³mÀ ³À ³”À ³•À ³áÀ ´À ´_À ´«À ´ôÀ µÀ µ À µ!À µ<À µTÀ µjÀ µ~À µ„À µ¥À µ©À µªÀ µàÀ µöÀ µúÀ µûÀ ¶"À ¶#À ¶`À ¶…À ¶©À ¶¿À ¶ÃÀ ¶ÄÀ ¶ğÀ ¶ñÀ ·$À ·eÀ ·†À ·ŠÀ ·‹À ·¸À ·¹À ·ìÀ ¸.À ¸PÀ ¸TÀ ¸UÀ ¸}À ¸~À ¸ÇÀ ¸äÀ ¸èÀ ¸éÀ ¹À ¹À ¹OÀ ¹pÀ ¹ƒÀ ¹™À ¹­À ¹³À ¹ÚÀ ¹ŞÀ ¹ßÀ º	À º
À ºJÀ ºiÀ ºmÀ ºnÀ º¡À ºâÀ »À »À »À »5À »6À »iÀ »ªÀ »ÌÀ »ĞÀ »ÑÀ ¼À ¼]À ¼§À ¼ÈÀ ¼ÎÀ ½ À ½DÀ ½„À ½ÎÀ ½İÀ ½ãÀ ¾À ¾nÀ ¾ À ¾ÓÀ ¿À ¿(À ¿,À ¿-À ¿uÀ ¿¾À ¿ıÀ À0À À6À ÀKÀ À\À ÀÀ ÀÉÀ ÀõÀ ÀùÀ ÀúÀ Á@À Á|À Á‚À Á«À ÁÖÀ Á×À Â
À ÂTÀ Â„À Â˜À Â½À Â×À ÂğÀ Ã
À Ã"À Ã=À ÃSÀ ÃoÀ Ã‡À ÃÀ ÃÀ ÃÙÀ ÃêÀ Ã÷À ÄÀ Ä<À ÄXÀ Ä^À Ä~À Ä˜À Ä±À ÄËÀ ÄãÀ ÄşÀ ÅÀ Å0À Å?À ÅUÀ ÅiÀ ÅoÀ ÅÀ Å“À Å”À Å°À ÅÈÀ ÅáÀ ÅûÀ ÆÀ ÆÀ Æ?À ÆPÀ ÆbÀ ÆvÀ Æ‰À Æ À ÆºÀ ÆÏÀ ÆÜÀ Ç*À ÇJÀ ÇNÀ ÇOÀ ÇxÀ ÇyÀ Ç¡À Ç¢À ÇÇÀ ÇäÀ ÇèÀ ÇéÀ È8À ÈTÀ ÈXÀ ÈYÀ È‹À È©À È­À È®À ÈÆÀ ÈÚÀ ÈğÀ ÉÀ ÉÀ É%À ÉCÀ ÉGÀ ÉHÀ ÉƒÀ É™À ÉÀ ÉÀ ÉÈÀ ÊÀ Ê8À ÊaÀ ÊeÀ ÊfÀ Ê¶À ÊâÀ ËÀ Ë2À Ë6À Ë7À ËˆÀ Ë²À ËâÀ ÌÀ ÌÀ Ì	À ÌRÀ Ì“À Ì™À ÌèÀ Í3À ÍfÀ ÍÀ ÍÆÀ ÍÊÀ ÍËÀ ÎÀ Î^À Î¡À Î§À Î÷À ÏFÀ Ï•À ÏâÀ ÏòÀ ĞÀ Ğ,À ĞBÀ ĞiÀ ĞpÀ Ğ™À ĞÀ ĞÀ ĞîÀ Ñ<À ÑRÀ Ñ‘À Ñ²À Ñ¶À Ñ·À ÑÚÀ ÑòÀ ÑöÀ Ñ÷À Ò$À Ò%À ÒXÀ Ò^À ÒsÀ ÒŒÀ Ò«À Ò±À ÒÏÀ ÓÀ ÓeÀ Ó{À Ó’À Ó«À ÓºÀ ÓÓÀ ÓÙÀ ÓõÀ ÓùÀ ÓúÀ ÔÀ ÔÀ ÔMÀ ÔSÀ ÔhÀ ÔyÀ Ô†À Ô™À Ô·À ÔØÀ ÔÜÀ ÔİÀ ÕÀ ÕÀ ÕLÀ ÕRÀ ÕgÀ Õ€À ÕÀÀ ÕçÀ ÕëÀ ÕìÀ ÖÀ ÖÀ ÖXÀ Ö^À ÖsÀ ÖŠÀ ÖÀ Ö¸À ÖûÀ ×À ×À ×À ×HÀ ×IÀ ×À ×¯À ×³À ×´À ×âÀ Ø"À ØSÀ ØtÀ ØxÀ ØyÀ Ø¥À ØÆÀ ØÊÀ ØËÀ ÙÀ Ù(À Ù9À ÙSÀ Ù|À Ù}À ÙÌÀ ÚÀ Ú>À Ú{À Ú|À ÚÁÀ ÛÀ Û+À Û1À ÛFÀ ÛYÀ Û_À Û›À Û³À ÛÄÀ ÛÓÀ ÛîÀ ÜÀ Ü	À Ü'À Ü+À Ü,À ÜVÀ ÜWÀ Ü“À Ü²À Ü¶À Ü·À ÜòÀ İÀ İ_À İeÀ İiÀ İjÀ İ™À İšÀ İİÀ İòÀ Ş	À Ş#À Ş8À ŞEÀ Ş†À ŞªÀ Ş®À Ş¯À ŞòÀ ßÀ ßÀ ß2À ßCÀ ßYÀ ßuÀ ß|À ß}À ßÉÀ àÀ àRÀ àxÀ à|À à}À à¨À à©À àÜÀ áÀ á;À á?À á@À ánÀ áoÀ ášÀ áºÀ á¾À á¿À áéÀ âÀ â	À â
À âUÀ âˆÀ â³À âĞÀ âÔÀ âÕÀ ãÀ ã<À ã@À ãAÀ ãÀ ã­À ã³À ãôÀ ä!À ä"À ä\À ä~À ä‚À äƒÀ äÏÀ äùÀ äúÀ åJÀ åƒÀ åªÀ åÉÀ åÍÀ åÎÀ æÀ æÀ æBÀ æ‹À æŒÀ æÄÀ æÊÀ çÀ çOÀ çPÀ çœÀ çºÀ çïÀ çğÀ è8À èJÀ èwÀ èxÀ èÃÀ éÀ é9À é=À é>À éqÀ érÀ é›À é¼À éÀÀ éÁÀ éñÀ êÀ êÀ êÀ ê^À ê¢À êãÀ êäÀ ë-À ëhÀ ë…À ë­À ëĞÀ ëÔÀ ëÕÀ ì!À ì\À ìyÀ ì£À ìÈÀ ìÌÀ ìÍÀ íÀ í[À í‡À íˆÀ íÕÀ íîÀ îÀ îÀ îiÀ î‚À î²À îÓÀ î×À îØÀ ï!À ï6À ïXÀ ïkÀ ï¦À ïÂÀ ïéÀ ğÀ ğÀ ğÀ ğ\À ğqÀ ğ“À ğ«À ğÃÀ ğşÀ ñÀ ñEÀ ñkÀ ñoÀ ñpÀ ñ¶À òÀ òÀ òGÀ òiÀ òmÀ ònÀ ò¿À òßÀ òòÀ ó(À óJÀ óNÀ óOÀ óŸÀ ó¼À óéÀ ô/À ôLÀ ôPÀ ôQÀ ôÀ ôµÀ ôîÀ ôïÀ õ:À õQÀ õeÀ õÀ õÊÀ õøÀ õüÀ õıÀ öÀ ö%À öqÀ ö³À öÏÀ öÓÀ öÔÀ öôÀ ÷	À ÷&À ÷DÀ ÷JÀ ÷mÀ ÷qÀ ÷rÀ ÷ À ÷¡À ÷ÌÀ ÷ìÀ ÷ğÀ ÷ñÀ ø)À øEÀ øIÀ øJÀ ørÀ øÀ ø“À ø”À øÇÀ øäÀ øøÀ ùÀ ù$À ù*À ùJÀ ùNÀ ùOÀ ù‚À ù¢À ù¶À ùÑÀ ùåÀ ùëÀ úÀ úÀ úÀ ú>À ú^À úbÀ úcÀ ú›À úœÀ úÏÀ úáÀ úúÀ ûÀ û&À û=À ûQÀ ûWÀ ûoÀ ûsÀ ûtÀ ûºÀ ûëÀ üÀ ü4À ü8À ü9À ü‰À üÀÀ üøÀ ı%À ı)À ı*À ırÀ ı£À ıÊÀ ıæÀ ıêÀ ıëÀ ş1À ştÀ ş©À şÓÀ ş×À şØÀ şòÀ ÿÀ ÿÀ ÿ1À ÿIÀ ÿOÀ ÿlÀ ÿpÀ ÿqÀ ÿÁÀ ÿúÀ GÀ dÀ hÀ iÀ ‡À –À «À ÄÀ ÚÀ#ÀrÀ‚À˜ÀÀ¿ÀÃÀÄÀÀSÀ›À·À»À¼ÀäÀÀÀÀCÀaÀeÀfÀÀ¯À³À´À À8ÀbÀ€À„À…À²ÀÔÀØÀÙÀÀÀ+ÀJÀNÀOÀwÀ”À˜À™ÀêÀ0À4À5ÀrÀ¤À¨À©ÀÓÀëÀïÀğÀÀ=ÀAÀBÀgÀÀ…À†ÀÎÀÀ)À-À.ÀfÀ“À—À˜À¿ÀÛÀßÀàÀ	$À	dÀ	‚À	†À	‡À	ÊÀ	ıÀ
DÀ
iÀ
mÀ
nÀ
¡À
¶À
ÌÀ
åÀ
øÀFÀnÀrÀsÀŠÀ­ÀÆÀÊÀËÀÀ?À]ÀaÀbÀ²ÀóÀ6À7À‚À±À×ÀÛÀÜÀÀUÀtÀxÀyÀÆÀ	À>À]ÀaÀbÀwÀ˜À±ÀµÀ¶À À&ÀDÀHÀIÀoÀ¹ÀõÀ&ÀOÀSÀTÀŸÀÍÀóÀ÷ÀøÀGÀmÀÀÄÀÈÀÉÀÀCÀIÀ–ÀçÀ6À‚ÀÅÀÀ"ÀUÀvÀzÀ{ÀËÀõÀûÀHÀ™ÀèÀ4ÀwÀ¹ÀÔÀÀ&À*À+ÀwÀ¾ÀÀ*ÀFÀaÀqÀÀ”À³À·À¸À	ÀLÀaÀ’À¸ÀßÀúÀşÀÿÀ&ÀBÀFÀGÀÀ¯À³À´ÀÙÀñÀÀ&À,ÀTÀXÀYÀªÀ«ÀÁÀÕÀîÀ	À'À?ÀUÀiÀoÀ‹ÀÀÀ¶À·À×ÀíÀşÀÀ#À)ÀOÀSÀTÀšÀºÀ¾À¿ÀüÀ.À2À3ÀeÀŒÀÀ‘ÀàÀ .À \À À ƒÀ „À ÀÀ ñÀ õÀ öÀ!-À!.À!bÀ!™À!À!À!ÂÀ!ÔÀ!åÀ"À"	À"0À"4À"5À"mÀ"šÀ"À"ŸÀ"ÇÀ"äÀ"èÀ"éÀ#+À#hÀ#¡À#ÕÀ#ÙÀ#ÚÀ$#À$NÀ$OÀ$ŠÀ$§À$ÚÀ%)À%IÀ%MÀ%NÀ%‰À%¦À%ÇÀ%İÀ%óÀ&À&"À&(À&OÀ&SÀ&TÀ&¢À&ïÀ';À'…À'ÇÀ'æÀ'ûÀ(À(%À(,À(-À(tÀ(ÄÀ)À)]À)–À)ØÀ)ûÀ*"À*8À*LÀ*RÀ*nÀ*¦À*¸À*ÈÀ*ÏÀ*ÓÀ*ÔÀ+À+gÀ+­À+ËÀ+÷À,9À,=À,>À,JÀ,fÀ,{À,À,¥À,µÀ,»À,ôÀ,øÀ,ùÀ-HÀ-—À-åÀ.1À.oÀ.¢À.¦À.§À.ÊÀ.âÀ.æÀ.çÀ/5À/~À/¬À/òÀ0À0kÀ0 À0ñÀ0÷À1AÀ1À1ĞÀ1ãÀ2#À2$À2sÀ2»À3À3PÀ3}À3~À3ÌÀ4À4À4kÀ4µÀ4ÊÀ4üÀ5À5!À56À5<À5qÀ5uÀ5vÀ5ÅÀ5èÀ5îÀ6;À6lÀ6›À6¾À6ÂÀ6ÃÀ6óÀ7À7À7À7JÀ7lÀ7pÀ7qÀ7ŸÀ7 À7ËÀ7îÀ7òÀ7ô# "/// @docImport 'parser_impl.dart';*   O   s  “¬¯  ÎØÛ  ‚ ‚‚  ‚'‚2‚5  ‚N‚\‚_  ‚‹‚«‚®  ‚Ò‚ê‚í  ƒƒ$ƒ'  ƒFƒqƒt  ƒƒ  ƒ €–ƒ ƒ¯      ƒÉkƒÎƒÎ  ƒçƒğƒï  ƒü„„  „
„„  „$
„)„(    „8À3»„8…ø¹/// A parser event listener that does nothing except throw exceptions
/// on parser errors.
///
/// Events are methods that begin with one of: `begin`, `end`, or `handle`.
///
/// Events starting with `begin` and `end` come in pairs. Normally, a
/// `beginFoo` event is followed by an `endFoo` event. There's a few exceptions
/// documented below.
///
/// Events starting with `handle` are used when isn't possible to have a begin
/// event.   †&†/†/     x†?†D†D  †M†U†T   †`#†e†e  †t†{†z   †‡_†Œ†Œ  †™	††  †¤†«†ª  †¶†½†¼   †ê€ğ‡i‡iu/// Called after the parser has consumed a sequence of patternFields that
/// forms the arguments to an objectPattern ‡ƒ	‡ˆ‡‡  ‡‡•‡”  ‡ ‡§‡¦   ‡Ş€šˆˆ5/// Handle async modifiers `async`, `async*`, `sync`. ˆ/ˆ7ˆ6  ˆBˆJˆI   ˆ|tˆÌˆÌH/// Ended by either [endAwaitExpression] or [endInvalidAwaitExpression]. ˆáˆèˆç   ˆô€¹‰R‰RT/// One of the two possible corresponding end events for
/// [beginAwaitExpression]. ‰e‰l‰k  ‰w‰~‰}   ‰±€ïŠŠT/// One of the two possible corresponding end events for
/// [beginAwaitExpression]. Š.Š5Š4  ŠDŠKŠJ  ŠXŠeŠd   Š¤4Š©Š©  Š´Š»Šº  ŠÁŠÌŠË   ŠÜ€ŠáŠá  Šï	ŠôŠó  Šş‹‹  ‹‹‹  ‹(‹3‹2   ‹a€Å‹ü‹ü€/// Called to handle a block that has been parsed but is not associated
/// with any top level function declaration. Substructures:
/// - block ŒŒŒ   Œ*!Œ/Œ/  Œ<ŒCŒB   ŒO0ŒTŒT    Œƒ.ŒˆŒˆ  ŒœŒ£Œ¢   ŒµiŒºŒº  ŒÌŒÓŒÒ  ŒßŒçŒæ  ŒìŒóŒò   "€òÎÎ€ /// Handle the start of the body of a class, mixin or extension declaration
/// beginning at [token]. The actual kind of declaration is indicated by
/// [kind]. ï ÿ     Œõõ€Ï/// Handle the end of the body of a class, mixin or extension declaration.
/// The only substructures are the class, mixin or extension members.
///
/// The actual kind of declaration is indicated by [kind]. *)  387  HON  ^ed   ¨‡ğğ2/// Called before parsing a class declaration, mixin declaration, or named
/// mixin application.
///
/// At this point only the `class` or `mixin` keyword have been seen,
/// so we know a declaration is coming but not its name or type
/// parameter declarations.
///
/// Ended by [endTopLevelDeclaration]. ‘ ‘'‘&   ‘3‚’K’K/// Handle the beginning of a class declaration.
/// [begin] may be the same as [name], or may point to modifiers
/// (or extraneous modifiers in the case of recovery) preceding [name].
///
/// At this point we have parsed the name and type parameter declarations. 
’f’m’l  ’w’’~  ’‘’™’˜  ’¨’°’¯  ’À’È’Ç  ’Ö’Ş’İ  ’ñ’ù’ø  “““  “!“)“(  “8
“?“>   “N‚”t”t/// Handle an extends clause in a class declaration. Substructures:
/// - supertype (may be a mixin application)
/// The typeCount is for error recovery: Invalid code might have more than one
/// class specified in the extends clause. A parser error has already been
/// issued. ”‡””  ””£”¢   ”Ô€Ş•Q•Qq/// Handle an implements clause in a class, mixin or enum declaration.
/// Substructures:
/// - implemented types •b•j•i  •|••€   •¶Q––€Ğ/// Handle the header of a class declaration.  Substructures:
/// - metadata
/// - modifiers
/// - class name
/// - type variables
/// - supertype
/// - with clause
/// - implemented types
/// - native clause –°–·–¶  –½–Ä–Ã  –Ñ–Ù–Ø   —Ó˜t˜tS/// Handle recovery associated with a class or extension type header.
/// This may be called multiple times after [handleClassHeader]
/// to recover information about the previous class header.
/// The substructures are a subset of
/// and in the same order as [handleClassHeader]:
/// - supertype
/// - with clause
/// - implemented types ˜“˜ª˜©   ˜â€Ç™L™L^/// Handle the end of a class declaration.  Substructures:
/// - class header
/// - class body ™`™g™f  ™r™y™x   ™­€Â™å™å0/// Handle the beginning of a mixin declaration. š šš  ššš  š/š7š6  šEšLšK  š]
šdšc   šs€­šÓšÓV/// Handle an on clause in a mixin declaration. Substructures:
/// - implemented types šášéšè  šóšøš÷   ›$€ó›Ï›Ï€™/// Handle the header of a mixin declaration.  Substructures:
/// - metadata
/// - mixin name
/// - type variables
/// - on types
/// - implemented types ›á›è›ç   œÕ¬¬y/// Handle recovery associated with a mixin header.
/// This may be called multiple times after [handleMixinHeader]
/// to recover information about the previous mixin header.
/// For otherwise legal input the substructures are a subset of
/// and in the same order as [handleMixinHeader]
/// - on types
/// - implemented types
/// but also covers the illegal
/// - with clause   ô€Ğggg/// Handle the end of a mixin declaration.  Substructures:
/// - mixin header
/// - class or mixin body {‚  ”“   È€§Ÿ:Ÿ:f/// Begins a not-further-categorized top-level declaration.
///
/// Ended by [endTopLevelDeclaration]. Ÿ`ŸgŸf   Ÿsq © ©"/// Handle the beginning of an extension methods declaration.  Substructures:
/// - metadata
///
/// At this point only the `extension` keyword have been seen, so we know a
/// declaration is coming but not its name or type parameter declarations.
///
/// Ended by [endTopLevelDeclaration].  Ê Ñ Ğ    è&¡§¡§€±/// Handle the beginning of an extension methods declaration.  Substructures:
/// - type variables
///
/// At this point we have parsed the name and type parameter declarations. ¡Æ¡Î¡Í  ¡ß¡æ¡å  ¡û¢¢   ¢G¢µ¢µ€•/// Handle the end of an extension methods declaration.  Substructures:
/// - substructures from [beginExtensionDeclaration]
/// - on type
/// - body ¢Ò¢Ù¢Ø  ¢è¢ï¢î  £££  ££!£    £](¤¤€®/// Handle the beginning of an extension type declaration.  Substructures:
/// - type variables
///
/// At this point we have parsed the name and type parameter declarations. ¤<¤D¤C  ¤W¤^¤]  ¤s
¤z¤y   ¤‰›¥^¥^€Å/// Handle the end of an extension methods declaration.  Substructures:
/// - substructures from [beginExtensionTypeDeclaration]
/// - primary constructor formals
/// - implements clause
/// - body ¥¥†¥…  ¥•¥¥œ  ¥®¥µ¥´  ¥Ê¥Ñ¥Ğ  ¥á¥è¥ç   ¦(€Ô¦©¦©w/// Handle the start of a primary constructor declaration, currently only
/// occurring in extension type declarations. ¦Á¦È¦Ç   § é¨Y¨YA/// Handle the end of a primary constructor declaration, currently only
/// occurring in extension type declarations. [constKeyword] is the 'const'
/// keyword, if present, in
///
///   extension type const ExtensionType() {}
///
/// Substructures:
/// - constructor name (if [hasConstructorName] is `true`)
/// - formals ¨t¨{¨z  ¨Š¨’¨‘  ¨£¨©¨¨   ¨í€Ã©q©qz/// Handle the omission of a primary constructor declaration. Currently only
/// occurring in extension type declarations. ©Œ©“©’  ©™©¡©    ©´%©¹©¹  ©Ê©Ñ©Ğ   ©İA©â©â  ©ñ	©ö©õ   ª")ª'ª'  ª<ªCªB   ªOA«w«w/// This method exists for analyzer compatibility only
/// and will be removed once analyzer/cfe integration is complete.
///
/// This is called when [Parser.parseDirectives] has parsed all directives
/// and is skipping the remainder of the file.  Substructures:
/// - metadata   «”V«™«™  «¬	«±«°  «·«¾«½   «î&«ó«ó  ¬¬¬   ¬IH¬N¬N  ¬^¬e¬d   ¬•.¬š¬š  ¬´¬»¬º   ¬ú€Ì¬ÿ¬ÿ  ­­#­"  ­-­5­4  ­J­Q­P  ­^7­{­z   ­Ê*­Ï­Ï  ­å­ì­ë   ®/€†®4®4  ®M®T®S  ®b®i®h  ®z®®€   ®¹.®¾®¾  ®Ø®ß®Ş   ®ëU®ğ®ğ  ¯¯¯   ¯D,¯I¯I  ¯a¯h¯g   ¯§T¯¬¯¬  ¯Â¯É¯È   ¯ÿ$°°  °°°   °'°œ°œi/// Handle the end of an enum declaration.  Substructures:
/// - [memberCount] times:
///   - Enum member °©°°°¯  °¿°Æ°Å  °Ö°İ°Ü  °ë°ğ°ï  ± ±±   ±3‚X²C²C€ø/// Handle the end of an enum constructor declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body ²[²c²b  ²p²w²v  ²†²²Œ  ²œ²¤²£  ²º²Á²À   ³€Ë³ù³ù^/// Handle the enum elements. Substructures:
/// - [elementsCount] times:
///   - Enum element ´´´  ´$´)´(   ´^6µµ€¨/// Handle the header of an enum declaration.  Substructures:
/// - Metadata
/// - Enum name (identifier)
/// - type variables
/// - with clause
/// - implemented types µ.µ6µ5  µGµNµM  µ^µeµd   µ˜€¿µüµüX/// Handle the enum element. Substructures:
/// - Metadata
/// - Enum value (identifier) ¶¶¶  ¶ ¶(¶'   ¶[€©¶`¶`  ¶z¶¶€  ¶¶—¶–  ¶ª¶±¶°   · ··  ·· ·   ·,€Ù·¸·¸|/// Handle the end of an export directive.  Substructures:
/// - metadata
/// - uri
/// - conditional uris
/// - combinators ·Â·É·È  ·×·Ş·İ   ¸	%¸Ê¸Ê€µ/// Called by [Parser] after parsing an extraneous expression as error
/// recovery. For a stack-based listener, the suggested action is to discard
/// an expression from the stack. ¸å¸ì¸ë  ¸ò¸û¸ú   ¹2k¹7¹7  ¹Q¹X¹W  ¹c¹j¹i   ¹¡ººs/// Note that this is ended by [endClassFactoryMethod],
/// [endMixinFactoryMethod] or [endExtensionFactoryMethod]. º6ºGºF  º[ºbºa  ºsº{ºz  ºº•º”   ºª€º¯º¯  ºÊºÑºĞ  ºàºçºæ  ºú»»    »;€ê»@»@  »[»b»a  »q»x»w  »‹»’»‘   ¼)€î¼.¼.  ¼M¼T¼S  ¼c¼j¼i  ¼}¼„¼ƒ   ½€ò½ ½   ½C½J½I  ½Y½`½_  ½s½z½y   ¾€˜¾¾  ¾0¾7¾6  ¾A¾M¾L  ¾V¾^¾]  ¾p¾x¾w  ¾‹¾“¾’   ¾­¾²¾²  ¾Ê¾Ò¾Ñ  ¾â¾ê¾é  ¾û¿¿  ¿¿%¿$  ¿3¿;¿:  ¿P¿X¿W  ¿k¿€¿  ¿‰¿•¿”   ¿Îe¿Ó¿Ó  ¿ì¿ó¿ò  ¿ùÀ @À @   À @7;À @<À @<  À @RÀ @YÀ @X  À @_À @kÀ @j   À @v€“À @{À @{  À @”	À @™À @˜  À @£À @ªÀ @©  À @¹À @ÀÀ @¿  À @ÍÀ @ÙÀ @Ø   À AæÀ A×À A×€¶/// Handle the end of a class field declaration.  Substructures:
/// - Metadata
/// - Modifiers
/// - Type
/// - Variable declarations (count times)
///
/// Started by [beginFields]. 
À AëÀ AóÀ Aò  À BÀ BÀ B  À BÀ B&À B%  À B8À B@À B?  À BPÀ BXÀ BW  À BkÀ BsÀ Br  À BÀ B‰À Bˆ  À B	À B¢À B¡  À B¬À B³À B²  À BÂÀ BÉÀ BÈ   À B÷‚çÀ CÁÀ CÁ€¶/// Handle the end of a mixin field declaration.  Substructures:
/// - Metadata
/// - Modifiers
/// - Type
/// - Variable declarations (count times)
///
/// Started by [beginFields]. 
À CÕÀ CİÀ CÜ  À CïÀ C÷À Cö  À DÀ DÀ D  À D"À D*À D)  À D:À DBÀ DA  À DUÀ D]À D\  À DkÀ DsÀ Dr  À D‡	À DŒÀ D‹  À D–À DÀ Dœ  À D¬À D³À D²   À Eâ‚ïÀ F°À F°€º/// Handle the end of a extension field declaration.  Substructures:
/// - Metadata
/// - Modifiers
/// - Type
/// - Variable declarations (count times)
///
/// Started by [beginFields]. 
À FÈÀ FĞÀ FÏ  À FâÀ FêÀ Fé  À FûÀ GÀ G  À GÀ GÀ G  À G-À G5À G4  À GHÀ GPÀ GO  À G^À GfÀ Ge  À Gz	À GÀ G~  À G‰À GÀ G  À GŸÀ G¦À G¥   À HÕ‚øÀ I¨À I¨€¿/// Handle the end of a extension type field declaration.  Substructures:
/// - Metadata
/// - Modifiers
/// - Type
/// - Variable declarations (count times)
///
/// Started by [beginFields]. 
À IÄÀ IÌÀ IË  À IŞÀ IæÀ Iå  À I÷À IÿÀ Iş  À JÀ JÀ J  À J)À J1À J0  À JDÀ JLÀ JK  À JZÀ JbÀ Ja  À Jv	À J{À Jz  À J…À JŒÀ J‹  À J›À J¢À J¡   À KÑ‚¦À L›À L›€¶/// Handle the end of an enum field declaration.  Substructures:
/// - Metadata
/// - Modifiers
/// - Type
/// - Variable declarations (count times)
///
/// Started by [beginFields]. 
À L®À L¶À Lµ  À LÈÀ LĞÀ LÏ  À LáÀ LéÀ Lè  À LûÀ MÀ M  À MÀ MÀ M  À M.À M6À M5  À MDÀ MLÀ MK  À M`	À MeÀ Md  À MoÀ MvÀ Mu  À M…À MŒÀ M‹   À N{‚À O†À O†€ó/// Handle the end of an enum method declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body À O™À O¡À O   À O®À OµÀ O´  À OÄÀ OËÀ OÊ  À OÚÀ OâÀ Oá  À OøÀ OÿÀ Oş   À P€ÙÀ QÀ Ql/// Marks that the grammar term `forInitializerStatement` has been parsed and
/// it was an empty statement. À Q&À Q-À Q,   À Qj€ôÀ QåÀ Qåq/// Marks that the grammar term `forInitializerStatement` has been parsed and
/// it was an expression statement. À RÀ RÀ R  À R
À R À R   À RbCÀ S"À S"€´/// Marks that the grammar term `forInitializerStatement` has been parsed and
/// it was a `localVariableDeclaration` of the form
/// `metadata initializedVariableDeclaration ';'`. À SOÀ SVÀ SU  À S\
À SbÀ Sa   À S©XÀ TeÀ Te€°/// Marks that the grammar term `forInitializerStatement` has been parsed and
/// it was a `localVariableDeclaration` of the form
/// `metadata patternVariableDeclaration ';'`. À T˜À TŸÀ T  À T«À T²À T±   À U€À UsÀ Usd/// Marks the start of a for statement which is ended by either
/// [endForStatement] or [endForIn]. À U…À UŒÀ U‹   À U˜oÀ VpÀ Vp€Ì/// Marks the end of parsing the control structure of a for statement
/// or for control flow entry up to and including the closing parenthesis.
/// `for` `(` initialization `;` condition `;` updaters `)` À VˆÀ VÀ V  À VÀ V¥À V¤  À V³À VºÀ V¹  À VÌÀ VÓÀ VÒ  À VæÀ VëÀ Vê   À W>HÀ WCÀ WC  À WSÀ WZÀ WY   À WŠ*À WÀ W  À W¥À W¬À W«   À WëPÀ WğÀ Wğ  À XÀ XÀ X
   À X?‚JÀ Y÷À Y÷¤/// Marks the end of parsing the control structure of a for-in statement
/// or for control flow entry up to and including the closing parenthesis.
/// If [patternKeyword] is `null`, this takes the form:
///   `for` `(` (type)? identifier `in` iterator `)`
/// If [patternKeyword] is not `null`, it is either a `var` or `final` token,
/// and this takes the form:
///   `for` `(` patternKeyword pattern `in` iterator `)` À ZÀ ZÀ Z  À Z(À Z/À Z.  À Z<À ZCÀ ZB  À ZWÀ Z_À Z^  À ZrÀ ZyÀ Zx   À [:À [À [  À [À [$À [#   À [M)À [RÀ [R  À [gÀ [nÀ [m   À [zKÀ [À [  À [’À [™À [˜   À [É#À [ÎÀ [Î  À [İÀ [äÀ [ã   À \#BÀ \(À \(  À \5À \<À \;   À \i“À ]ĞÀ ]ĞS/// Handle the beginning of a named function expression which isn't legal
/// syntax in Dart.  Useful for recovering from JavaScript code being pasted
/// into a Dart program, as it will interpret `function foo() {}` as a named
/// function expression with return type `function` and name `foo`.
///
/// Substructures:
/// - Type variables À ]íÀ ]ôÀ ]ó   À ^ ‚|À `#À `#Î/// A named function expression which isn't legal syntax in Dart.
/// Useful for recovering from JavaScript code being pasted into a Dart
/// program, as it will interpret `function foo() {}` as a named function
/// expression with return type `function` and name `foo`.
///
/// Substructures:
/// - Type variables
/// - Modifiers
/// - Return type
/// - Name
/// - Formals
/// - Initializers
/// - Async modifier
/// - Function body (block or arrow expression). À `>À `EÀ `D   À `€€¦À `ùÀ `ùm/// Handle the beginning of a local function declaration.  Substructures:
/// - Metadata
/// - Type variables À aÀ aÀ a   À a*–À bjÀ bj€ï/// A function declaration.
///
/// Substructures:
/// - Metadata
/// - Type variables
/// - Return type
/// - Name
/// - Type variables
/// - Formals
/// - Initializers
/// - Async modifier
/// - Function body (block or arrow expression). À b†À bÀ bŒ   À bÄ;À cÙÀ cÙ/// This method is invoked when the parser sees that a function has a
/// block function body.  This method is not invoked for empty or expression
/// function bodies, see the corresponding methods [handleEmptyFunctionBody]
/// and [handleExpressionFunctionBody]. À cğÀ c÷À cö   À d‚À e¶À e¶¡/// This method is invoked by the parser after it finished parsing a block
/// function body.  This method is not invoked for empty or expression
/// function bodies, see the corresponding methods [handleEmptyFunctionBody]
/// and [handleExpressionFunctionBody].  The [beginToken] is the '{' token,
/// and the [endToken] is the '}' token of the block.  The number of
/// statements is given as the [count] parameter. À eË	À eĞÀ eÏ  À eÖÀ eİÀ eÜ  À eèÀ eïÀ eî   À f$LÀ f)À f)  À f>À fEÀ fD   À ftÀ g9À g9€·/// Handle the end of a function body that was skipped by the parser.
///
/// The boolean [isExpressionBody] indicates whether the function body that
/// was skipped used "=>" syntax. À gSÀ gZÀ gY  À g`À gfÀ ge   À g}&À g‚À g‚  À g”À g›À gš   À g§‚À i>À i>s/// The end of the function name in either a local function declaration, like
/// 'local' in:
///
///     void m() {
///       void local() {}
///     }
///
/// or an erroneous function expression, like 'local' in:
///
///     void m() {
///       var f = void local() {};
///     }
///
/// The boolean [isFunctionExpression] indicates that we are in the latter
/// case. À iSÀ iZÀ iY  À iiÀ ipÀ io  À izÀ i€À i   À iÀ!À iÅÀ iÅ  À iÒÀ iÙÀ iØ   À iå‚xÀ kËÀ kË‘/// Handle the end of a typedef declaration.
///
/// If [equals] is null, then we have the following substructures:
/// - Metadata
/// - Return type
/// - Name (identifier)
/// - Alias type variables
/// - Formal parameters
///
/// If [equals] is not null, then the have the following substructures:
/// - Metadata
/// - Name (identifier)
/// - Alias type variables
/// - Type (FunctionTypeAnnotation) À kÛÀ kãÀ kâ  À kôÀ kûÀ kú  À lÀ lÀ l  À l!À l(À l'   À la€ÈÀ lÚÀ lÚm/// Handle the end of a class with clause (e.g. "with B, C").
/// Substructures:
/// - mixin types (TypeList) À lğÀ l÷À lö   À m-xÀ mcÀ mc./// Handle the absence of a class with clause.   À m©IÀ n¥À n¥€ê/// Handle the end of an enum with clause (e.g. "with B, C").
/// Substructures:
/// - mixin types (TypeList)
///
/// This method is separated from [handleClassWithClause] to simplify
/// handling the different objects in the context. À nºÀ nÁÀ nÀ   À növÀ o,À o,./// Handle the absence of an enum with clause.   À opDÀ peÀ pe€ã/// Handle the end of a mixin with clause (e.g. "with B, C").
/// Substructures:
/// - mixin types (TypeList)
///
/// This method is separated from [handleClassWithClause] and
/// [handleEnumWithClause] as it is an error state. À p{À p‚À p   À p¸‚,À qÛÀ qÛ/// Handle the beginning of a named mixin application.
/// [beginToken] may be the same as [name], or may point to modifiers
/// (or extraneous modifiers in the case of recovery) preceding [name].
///
/// At this point we have parsed the name and type parameter declarations. 
À qûÀ rÀ r  À rÀ rÀ r  À r+À r3À r2  À rBÀ rJÀ rI  À rZÀ rbÀ ra  À rpÀ rxÀ rw  À r‹À r“À r’  À r¢À rªÀ r©  À r»À rÃÀ rÂ  À rÒ
À rÙÀ rØ   À rèÀ s|À s|€†/// Handle a named mixin application with clause (e.g. "A with B, C").
/// Substructures:
/// - supertype
/// - mixin types (TypeList) À s¢À s©À s¨   À sïƒÀ vCÀ vC‚0/// Handle the end of a named mixin declaration.  Substructures:
/// - metadata
/// - modifiers
/// - class name
/// - type variables
/// - supertype
/// - with clause
/// - implemented types (TypeList)
///
/// TODO(paulberry,ahe): it seems inconsistent that for a named mixin
/// application, the implemented types are a TypeList, whereas for a class
/// declaration, each implemented type is listed separately on the stack, and
/// the number of implemented types is passed as a parameter.
///
/// TODO(jensj): Rename `begin` to `beginToken` for consistency. À vaÀ vhÀ vg  À vrÀ vyÀ vx  À vŠÀ v‘À v  À vœÀ v¤À v£  À vºÀ vÁÀ vÀ   À vş$À wÀ w  À wÀ wÀ w   À w&€À wÀ w^/// Handle the end of a "hide" combinator.  Substructures:
/// - hidden names (IdentifierList) À w–À wÀ wœ   À wÈJÀ wÍÀ wÍ  À wâ	À wçÀ wæ   À x"À xÀ x  À x)À x0À x/   À x<;À xAÀ xA  À xM	À xRÀ xQ   À x{%À x€À x€  À x‘À x˜À x—   À x¤gÀ x©À x©  À x¸À x¿À x¾  À xÇÀ xÏÀ xÎ  À xÙÀ xàÀ xß   À y'À yÀ y  À y'À y.À y-   À y:\À y?À y?  À yPÀ yWÀ yV  À ybÀ yiÀ yh   À yš'À yŸÀ yŸ  À y²À y¹À y¸   À yÅ€ˆÀ yöÀ yö)/// The [beginToken] is the `else` token. À zÀ zÀ z  À zÀ z À z   À zQ(À zVÀ zV  À zbÀ ziÀ zh   À z}RÀ {oÀ {o€ä/// Signals that the current import is deferred and/or has a prefix
/// depending upon whether [deferredKeyword] and [asKeyword]
/// are not `null` respectively. Substructures:
/// - prefix identifier (only if asKeyword != null) À {‚À {ŠÀ {‰  À {šÀ {¢À {¡   À {Ó	À |yÀ |y€”/// Handle the end of an import directive.  Substructures:
/// - metadata
/// - uri
/// - conditional uris
/// - prefix identifier
/// - combinators À |ƒÀ |ŠÀ |‰  À |˜À | À |Ÿ  À |­À |µÀ |´   À |àœÀ ~1À ~1=/// Handle recovery associated with an import directive.
/// This may be called multiple times after [endImport]
/// to recover information about the previous import directive.
/// The substructures are a subset of and in the same order as [endImport]:
/// - conditional uris
/// - prefix identifier
/// - combinators À ~EÀ ~MÀ ~L   À ~€)À ~…À ~…  À ~šÀ ~¡À ~    À ~­IÀ ~²À ~²  À ~Å	À ~ÊÀ ~É   À ~ú,À ~ÿÀ ~ÿ  À À À    À *&À åÀ å€­/// Handle the end of a conditional URI construct.  Substructures:
/// - Dotted name
/// - Condition (literal string; only if [equalSign] != null)
/// - URI (literal string) À ÷À şÀ ı  À €À €À €  À €À €!À €    À €TYÀ €YÀ €Y  À €j	À €oÀ €n  À €uÀ €|À €{   À €±4À €¶À €¶  À €ÖÀ €İÀ €Ü   À €éyÀ €îÀ €î  À À À   À À  À    À f/À kÀ k  À †À À Œ   À ™[À À   À ·À ¾À ½   À ø*À ıÀ ı  À ‚À ‚À ‚   À ‚&€ñÀ ‚ºÀ ‚ºW/// Handle the end of a field initializer.  Substructures:
/// - Initializer expression À ‚ÎÀ ‚ÕÀ ‚Ô  À ‚àÀ ‚çÀ ‚æ   À ƒ€‚À ƒNÀ ƒN+/// Handle the lack of a field initializer. À ƒgÀ ƒnÀ ƒm   À ƒ¡-À ƒ¦À ƒ¦  À ƒ¿À ƒÆÀ ƒÅ   À ƒÒ€¿À „6À „6Z/// Handle the end of a variable initializer. Substructures:
/// - Initializer expression. À „MÀ „TÀ „S   À „•€‰À „ÉÀ „É,/// Used when a variable has no initializer. À „åÀ „ìÀ „ë   À …"%À …'À …'  À …8À …?À …>   À …~QÀ …ƒÀ …ƒ  À …’À …™À …˜   À …Ó&À …ØÀ …Ø  À …êÀ …ñÀ …ğ   À …ıeÀ †À †  À †	À †À †  À †À †$À †#  À †/À †6À †5   À †fAÀ †kÀ †k    À †«À ‡pÀ ‡p€¹/// Called after the listener has recovered from an invalid expression. The
/// parser will resume parsing from [token]. Exactly where the parser will
/// resume parsing is unspecified. À ‡ˆÀ ‡À ‡   À ‡Á'À ˆ—À ˆ—€Ê/// Called after the listener has recovered from an invalid function
/// body. The parser expected an open curly brace `{` and will resume parsing
/// from [token] as if a function body had preceded it. À ˆ±À ˆ¸À ˆ·   À ˆì À ‰™À ‰™€¡/// Called after the listener has recovered from an invalid type. The parser
/// expected an identifier, and will resume parsing type arguments from
/// [token]. À ‰´À ‰»À ‰º   À ‰ğ:À ‰õÀ ‰õ  À ŠÀ ŠÀ Š   À Š.:À Š3À Š3  À ŠIÀ ŠPÀ ŠO  À ŠVÀ Š[À ŠZ   À ŠlPÀ ŠqÀ Šq  À Š…À ŠŠÀ Š‰   À ŠÀLÀ ŠÅÀ ŠÅ  À ŠŞÀ ŠåÀ Šä  À ŠôÀ ŠûÀ Šú   À ‹€ûÀ ‹|À ‹|`/// Handle the end of a library augmentation directive.  Substructures:
/// - metadata
/// - uri À ‹˜À ‹ŸÀ ‹  À ‹²À ‹¹À ‹¸  À ‹ÌÀ ‹ÓÀ ‹Ò   À Œ%À ŒÀ Œ  À Œ%À Œ,À Œ+   À Œ8€çÀ Œ¹À Œ¹u/// Handle the end of a library directive.  Substructures:
/// - Metadata
/// - Library name (a qualified identifier) À ŒÈÀ ŒÏÀ ŒÎ  À ŒŞÀ ŒåÀ Œä  À ŒïÀ ŒõÀ Œô   À #èÀ dÀ d€ş/// Called after parsing a map entry. Either the key or the value or both can
/// start with the null-aware token `?`. In that case, [nullAwareKeyToken] and
/// [nullAwareValueToken] are set appropriately. Substructures:
/// - expression
/// - expression À À †À …  À À —À –  À ¦À ®À ­  À ÄÀ ÌÀ Ë   À 
À ÀÀ Àt/// Called after the parser has consumed a mapPatternEntry, consisting of an
/// expression, a colon, and a pattern. À ÖÀ İÀ Ü  À ãÀ êÀ é   À 'À "À "  À 5À <À ;   À HMÀ MÀ M  À kÀ rÀ q  À ~À †À …   À ÌbÀ ÑÀ Ñ  À âÀ çÀ æ  À úÀ ‘À ‘    À ‘2sÀ ‘7À ‘7  À ‘TÀ ‘[À ‘Z  À ‘fÀ ‘kÀ ‘j   À ‘©À ’¨À ’¨€ñ/// Called for class-like members (class, mixin, extension), but each member
/// should also have a more specific begin/end pair, e.g.
/// [beginFactoryMethod]/[endClassFactoryMethod]/[endMixinFactoryMethod]/
/// [endExtensionFactoryMethod].   À ’¼€ÌÀ “@À “@G/// Handle an invalid member declaration. Substructures:
/// - metadata À “TÀ “[À “Z   À “ŒÎÀ •1À •1/// This event is added for convenience to the listener.
/// Members will actually be begin/end'ed by more specific
/// events as well.
/// Normally listeners should probably override
/// [endClassFields], [endMixinFields], [endExtensionFields],
/// [endClassMethod], [endMixinMethod], [endExtensionMethod],
/// [endClassConstructor], [endMixinConstructor],
/// or [endExtensionConstructor] instead.   À •^‚À –wÀ –w	/// Handle the beginning of a class-like method declaration.  Substructures:
/// - metadata
/// Note that this is ended with [endClassConstructor], [endClassMethod],
/// [endExtensionConstructor], [endExtensionMethod], [endMixinConstructor] or
/// [endMixinMethod]. 	À –ˆÀ –™À –˜  À –­À –µÀ –´  À –ÆÀ –ÎÀ –Í  À –àÀ –èÀ –ç  À –øÀ — À –ÿ  À —À —À —  À —/À —7À —6  À —D
À —KÀ —J  À —T À —]À —\   À —€´À ˜‹À ˜‹€ó/// Handle the end of a class method declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body À ˜ŸÀ ˜§À ˜¦  À ˜´À ˜»À ˜º  À ˜ÊÀ ˜ÑÀ ˜Ğ  À ˜àÀ ˜èÀ ˜ç  À ˜şÀ ™À ™   À ™8‚OÀ šCÀ šC€ó/// Handle the end of a mixin method declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body À šWÀ š_À š^  À šlÀ šsÀ šr  À š‚À š‰À šˆ  À š˜À š À šŸ  À š¶À š½À š¼   À ›‹‚WÀ œšÀ œš€÷/// Handle the end of a extension method declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body À œ²À œºÀ œ¹  À œÇÀ œÎÀ œÍ  À œİÀ œäÀ œã  À œóÀ œûÀ œú  À À À    À æ‚`À úÀ ú€ü/// Handle the end of a extension type method declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body À ŸÀ ŸÀ Ÿ  À Ÿ+À Ÿ2À Ÿ1  À ŸAÀ ŸHÀ ŸG  À ŸWÀ Ÿ_À Ÿ^  À ŸuÀ Ÿ|À Ÿ{   À  J‚YÀ ¡ZÀ ¡Z€ø/// Handle the end of a class constructor declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body À ¡sÀ ¡{À ¡z  À ¡ˆÀ ¡À ¡  À ¡À ¡¥À ¡¤  À ¡´À ¡¼À ¡»  À ¡ÒÀ ¡ÙÀ ¡Ø   À ¢§‚YÀ £·À £·€ø/// Handle the end of a mixin constructor declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body À £ĞÀ £ØÀ £×  À £åÀ £ìÀ £ë  À £ûÀ ¤À ¤  À ¤À ¤À ¤  À ¤/À ¤6À ¤5   À ¥‚aÀ ¦À ¦€ü/// Handle the end of a extension constructor declaration.  Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body À ¦5À ¦=À ¦<  À ¦JÀ ¦QÀ ¦P  À ¦`À ¦gÀ ¦f  À ¦vÀ ¦~À ¦}  À ¦”À ¦›À ¦š   À §i‚uÀ ¨ˆÀ ¨ˆ/// Handle the end of an extension type constructor declaration.
/// Substructures:
/// - metadata
/// - return type
/// - method name (identifier, possibly qualified)
/// - type variables
/// - formal parameters
/// - initializers
/// - async marker
/// - body À ¨©À ¨±À ¨°  À ¨¾À ¨ÅÀ ¨Ä  À ¨ÔÀ ¨ÛÀ ¨Ú  À ¨êÀ ¨òÀ ¨ñ  À ©À ©À ©   À ©â&À ©çÀ ©ç  À ©ùÀ ª À ©ÿ   À ªCÀ ªÀ ª  À ª!	À ª&À ª%   À ªS"À ªXÀ ªX  À ªfÀ ªmÀ ªl   À ªy*À «=À «=€´/// Handle the end of a metadata annotation.  Substructures:
/// - Identifier
/// - Type arguments
/// - Constructor name (only if [periodBeforeName] is not `null`)
/// - Arguments À «IÀ «PÀ «O  À «[À «cÀ «b  À «tÀ «{À «z   À «§2À «¬À «¬  À «ÊÀ «ÑÀ «Ğ   À «İ€£À «âÀ «â  À ¬	À ¬À ¬  À ¬À ¬À ¬  À ¬(À ¬/À ¬.  À ¬<À ¬HÀ ¬G   À ¬„À ¬‰À ¬‰  À ¬“À ¬šÀ ¬™   À ¬¦€£À ­À ­P/// Handle the end of a part directive.  Substructures:
/// - metadata
/// - uri À ­
À ­À ­  À ­À ­$À ­#   À ­M À ­RÀ ­R  À ­^À ­eÀ ­d   À ­qfÀ ®XÀ ®X€Õ/// Handle the end of a "part of" directive.  Substructures:
/// - Metadata
/// - Library name (a qualified identifier)
///
/// If [hasName] is true, this part refers to its library by name, otherwise,
/// by URI. À ®gÀ ®nÀ ®m  À ®~À ®…À ®„  À ®“À ®šÀ ®™  À ®¨À ®®À ®­   À ®Û0À ®àÀ ®à  À ®üÀ ¯À ¯   À ¯nÀ ¯À ¯  À ¯.À ¯5À ¯4  À ¯@À ¯GÀ ¯F   À ¯)À ¯†À ¯†  À ¯›À ¯¢À ¯¡   À ¯®€ÚÀ °"À °"j/// Handle the end of a `native` function.
/// The [handleNativeClause] event is sent prior to this event. À °;À °BÀ °A  À °NÀ °UÀ °T   À °ŒaÀ ±yÀ ±y€ß/// Called after the [handleNativeClause] event when the parser determines
/// that the native clause should be discarded / ignored.
/// For example, this method is called a native clause is followed by
/// a function body. À ±™À ± À ±Ÿ  À ±¬À ±³À ±²   À ±ñÀ ²„À ²„€‰/// Handle the end of a `native` function that was skipped by the parser.
/// The [handleNativeClause] event is sent prior to this event. À ²¤À ²«À ²ª  À ²·À ²¾À ²½   À ²ü€—À ³BÀ ³B>/// This method is invoked when a function has the empty body. À ³ZÀ ³aÀ ³`   À ³—ˆÀ ´²À ´²y/// This method is invoked when parser finishes parsing the corresponding
/// expression of the expression function body. À ´ÏÀ ´ÖÀ ´Õ  À ´áÀ ´éÀ ´è   À µ#€…À µ(À µ(  À µ@À µFÀ µE  À µXÀ µ_À µ^  À µnÀ µuÀ µt   À µ¬MÀ µ±À µ±  À µ¼À µÃÀ µÂ  À µÎÀ µÕÀ µÔ   À µı$À ¶À ¶  À ¶À ¶À ¶   À ¶%€À ¶ŒÀ ¶Œ]/// Handle the end of a "show" combinator.  Substructures:
/// - shown names (IdentifierList) À ¶”À ¶›À ¶š   À ¶Æ)À ¶ËÀ ¶Ë  À ¶àÀ ¶çÀ ¶æ   À ·&cÀ ·+À ·+  À ·>À ·EÀ ·D  À ·SÀ ·ZÀ ·Y   À ·*À ·’À ·’  À ·¨À ·¯À ·®   À ·îeÀ ·óÀ ·ó  À ¸À ¸À ¸  À ¸À ¸#À ¸"   À ¸W%À ¸\À ¸\  À ¸mÀ ¸tÀ ¸s   À ¸€gÀ ¸…À ¸…  À ¸”À ¸™À ¸˜  À ¸£À ¸ªÀ ¸©  À ¸µÀ ¸¼À ¸»   À ¸ë/À ¸ğÀ ¸ğ  À ¹À ¹À ¹   À ¹Q€ŒÀ ¹VÀ ¹V  À ¹tÀ ¹yÀ ¹x  À ¹‡À ¹À ¹  À ¹À ¹¤À ¹£   À ¹á'À ¹æÀ ¹æ  À ¹ùÀ º À ¹ÿ   À º`À ºÀ º  À º"À º)À º(  À º3À º8À º7   À º£cÀ º¨À º¨  À º¾À ºÅÀ ºÄ  À ºĞÀ º×À ºÖ   À »
*À »À »  À »%À »,À »+   À »kdÀ »pÀ »p  À »„À »‹À »Š  À »˜À »ŸÀ »   À »ÓƒXÀ ¾ÚÀ ¾Ú‚²/// This event is added for convenience for the listener.
/// All top-level declarations will actually be begin/end'ed by more specific
/// events as well, e.g. [beginClassDeclaration]/[endClassDeclaration],
/// [beginEnum]/[endEnum] etc.
///
/// Normally listeners should probably override
/// [endClassDeclaration], [endNamedMixinApplication], [endEnum],
/// [endTypedef], [endLibraryName], [endImport], [endExport],
/// [endPart], [endPartOf], [endTopLevelFields], or [endTopLevelMethod]
/// instead.
///
/// Started by one of [beginExtensionDeclarationPrelude],
/// [beginClassOrMixinOrNamedMixinApplicationPrelude], [beginTopLevelMember]
/// or [beginUncategorizedTopLevelDeclaration]. À ¾ñÀ ¾øÀ ¾÷   À ¿/ÉÀ À–À À– /// Called by the [Parser] when it recovers from an invalid top level
/// declaration, where [endToken] is the last token in the declaration
/// This is called after the begin/end metadata star events,
/// and is followed by [endTopLevelDeclaration].
///
/// Substructures:
/// - metadata À À·À À¾À À½   À Àü€ÙÀ Á²À Á²€¨/// Marks the beginning of a top level field or method declaration.
/// See also [endTopLevelFields] and [endTopLevelMethod].
///
/// Ended by [endTopLevelDeclaration]. À ÁÆÀ ÁÍÀ ÁÌ   À ÁÙ´À Â‹À Â‹€¦/// Marks the beginning of a fields declaration.
/// Note that this is ended with [endTopLevelFields], [endClassFields],
/// [endMixinFields] or [endExtensionFields]. 	À ÂœÀ Â­À Â¬  À ÂÁÀ ÂÉÀ ÂÈ  À ÂÛÀ ÂãÀ Ââ  À ÂôÀ ÂüÀ Âû  À ÃÀ ÃÀ Ã  À Ã&À Ã.À Ã-  À ÃAÀ ÃIÀ ÃH  À ÃWÀ Ã_À Ã^  À ÃsÀ ÃzÀ Ãy   À Ã‘‚À Ä…À Ä…€Ş/// Handle the end of a top level variable declaration.  Substructures:
/// - Metadata
/// - Type
/// - Repeated [count] times:
///   - Variable name (identifier)
///   - Field initializer
///
/// Started by [beginFields]. 	À ÄœÀ Ä¤À Ä£  À ÄµÀ Ä½À Ä¼  À ÄÏÀ Ä×À ÄÖ  À ÄçÀ ÄïÀ Äî  À ÅÀ Å
À Å	  À ÅÀ Å À Å  À Å4	À Å9À Å8  À ÅCÀ ÅJÀ ÅI  À ÅYÀ Å`À Å_   À Å–kÀ Å›À Å›  À Å´À Å»À Åº  À ÅÌÀ ÅÔÀ ÅÓ  À ÅåÀ ÅíÀ Åì   À ÆHÀ ÆãÀ Æã€Æ/// Handle the end of a top level method.  Substructures:
/// - metadata
/// - modifiers
/// - return type
/// - identifier
/// - type variables
/// - formal parameters
/// - async marker
/// - body À ÆõÀ ÆüÀ Æû  À ÇÀ ÇÀ Ç  À ÇÀ ÇÀ Ç   À ÇQ&À ÇVÀ ÇV  À ÇhÀ ÇoÀ Çn   À Ç{%À Ç€À Ç€  À Ç‘À Ç˜À Ç—   À Ç¤CÀ Ç©À Ç©  À Ç¸À Ç¿À Ç¾   À ÇëlÀ ÇğÀ Çğ  À ÈÀ È	À È  À ÈÀ ÈÀ È  À È(À È0À È/   À È[QÀ È`À È`  À ÈsÀ ÈzÀ Èy   À È°€–À ÈµÀ Èµ  À ÈÊÀ ÈÏÀ ÈÎ  À ÈŞÀ ÈåÀ Èä  À ÈôÀ ÈüÀ Èû  À ÉÀ ÉÀ É   À ÉJRÀ ÉOÀ ÉO  À ÉZÀ ÉaÀ É`  À ÉlÀ ÉtÀ És   À É €ÄÀ ÊÀ Êb/// Called when parser encounters a '!'
/// used as a non-null postfix assertion in an expression. À Ê*
À Ê1À Ê0   À Êh€ÍÀ ÊéÀ Êéw/// Called after the parser has consumed a null-assert pattern, consisting of
/// a pattern followed by a `!` operator. À Ë
À ËÀ Ë   À Ë9€ÎÀ Ë¹À Ë¹v/// Called after the parser has consumed a null-check pattern, consisting of a
/// pattern followed by a `?` operator. À ËĞÀ Ë×À ËÖ   À Ì¾À ÍmÀ ÍmP/// Called after the parser has consumed an assigned variable pattern,
/// consisting of a variable name identifier (other than `_`).
///
/// This method will only be called for a variable pattern that is part of a
/// `patternAssignment` (and hence should refer to a previously declared
/// variable rather than declaring a fresh one). À Í‹À Í’À Í‘   À ÍÍ‚ÏÀ ÏùÀ Ïù‚/// Called after the parser has consumed a declared variable pattern,
/// consisting of an optional `var` or `final` keyword, an optional type
/// annotation, and a variable name identifier (other than `_`).
///
/// The flag [inAssignmentPattern] indicates whether this variable pattern is
/// part of a `patternAssignment`.  If this is `true`, it indicates that the
/// parser has recovered from an error (since declared variable patterns are
/// not allowed inside a `patternAssignment`).  The error has already been
/// reported. À ĞÀ Ğ$À Ğ#  À Ğ0À Ğ7À Ğ6  À ĞF!À ĞUÀ ĞT   À Ğ À ÑYÀ ÑY€­/// Called after the parser has consumed a wildcard pattern, consisting of an
/// optional `var` or `final` keyword, an optional type annotation, and the
/// identifier `_`. À ÑoÀ ÑwÀ Ñv  À ÑÀ Ñ†À Ñ…   À Ñ¹<À Ñ¾À Ñ¾  À ÑËÀ ÑÒÀ ÑÑ   À Ñù*À ÑşÀ Ñş  À ÒÀ ÒÀ Ò   À Ò'ÑÀ ÓlÀ Ól-/// Handle the end of a record type declaration.
///
/// Substructures:
/// - RecordTypeEntry*
/// - RecordTypeNamedFields?
///
/// Notice that [count] is:
/// - the number of RecordTypeEntries if [hasNamedFields] is `false`, or
/// - the number of RecordTypeEntries + 1 if [hasNamedFields] is `true`. À ÓÀ Ó†À Ó…  À Ó–À ÓÀ Ó  À Ó¯	À Ó´À Ó³  À Ó¾À ÓÄÀ ÓÃ   À ÓüÀ ÔÀ Ô    À Ô€½À Ô À Ô p/// Handle the end of the record type entries.
///
/// Substructures:
/// - metadata
/// - type
/// - identifier   À Ôß5À ÔäÀ Ôä  À ÔÿÀ ÕÀ Õ   À Õ€ÒÀ Õ‡À Õ‡a/// Handle the end of the record type named fields.
///
/// Substructures:
/// - RecordTypeEntry* À Õ 	À Õ¥À Õ¤  À Õ«À Õ²À Õ±   À Õî+À ÕóÀ Õó  À ÖÀ ÖÀ Ö   À Ö€ÿÀ Ö¿À Ö¿€/// Handle the end of a generic function type declaration.
///
/// Substructures:
/// - Type variables
/// - Return type
/// - Formal parameters À ÖÏÀ ÖÖÀ ÖÕ  À ÖäÀ ÖìÀ Öë   À × 'À ×%À ×%  À ×8À ×?À ×>   À ×KgÀ ×PÀ ×P  À ×a	À ×fÀ ×e  À ×lÀ ×sÀ ×r  À ×~À ×…À ×„   À ×¶€ÁÀ Ø)À Ø)i/// After endTypeArguments has been called,
/// this event is called if those type arguments are invalid. À ØDÀ ØKÀ ØJ   À Ø{NÀ Ø€À Ø€  À Ø–À ØÀ Øœ   À ØÍ€®À ÙZÀ ÙZ/// Handle the begin of a type formal parameter (e.g. "X extends Y").
/// Substructures:
/// - Metadata
/// - Name (identifier) À ÙlÀ ÙsÀ Ùr   À Ù€ûÀ ÚEÀ ÚE€º/// Called when [beginTypeVariable] has been called for all of the variables
/// in a group, and before [endTypeVariable] has been called for any of the
/// variables in that same group. À Ú`À ÚgÀ Úf  À Úm	À ÚrÀ Úq   À Ú~¬À Û¢À Û¢/// Handle the end of a type formal parameter (e.g. "X extends Y")
/// where [index] is the index of the type variable in the list of
/// type variables being declared.
///
/// Substructures:
/// - Type bound
///
/// See [beginTypeVariable] for additional substructures. À Û·À Û¾À Û½  À ÛÈ	À ÛÍÀ ÛÌ  À Û×À ÛßÀ ÛŞ  À ÛòÀ ÛúÀ Ûù   À Ü.'À Ü3À Ü3  À ÜFÀ ÜMÀ ÜL   À ÜY\À Ü^À Ü^  À ÜoÀ ÜvÀ Üu  À ÜÀ ÜˆÀ Ü‡   À Ü¹€¯À Ü¾À Ü¾  À ÜßÀ ÜçÀ Üæ   À İl,À İqÀ İq  À İ‰À İÀ İ   À İœÀ ŞLÀ ŞL€/// Handle the end of a function expression (e.g. "() { ... }").
/// Substructures:
/// - Type variables
/// - Formal parameters
/// - Async marker
/// - Body À ŞbÀ ŞiÀ Şh  À ŞtÀ Ş{À Şz   À Ş±€ÊÀ ßÀ ßZ/// Handle the start of a variables declaration.  Substructures:
/// - Metadata
/// - Type À ß6À ß=À ß<  À ßGÀ ßOÀ ßN  À ß]À ßeÀ ßd   À àdÀ àÀ à  À à4	À à9À à8  À à?À àGÀ àF   À à(À à„À à„  À à˜À àŸÀ à   À àŞ`À àãÀ àã  À àõÀ àüÀ àû  À á	À áÀ á   À áB+À áGÀ áG  À á[À ábÀ áa   À áqLÀ ávÀ áv  À áˆÀ áÀ á   À áÁGÀ áÆÀ áÆ  À á×À áŞÀ áİ   À â€ÇÀ âÀ ây/// Called after the parser has consumed a cast pattern, consisting of a
/// pattern, `as` operator, and type annotation. À â¡À â¨À â§   À â×hÀ âÜÀ âÜ  À â÷À âşÀ âı  À ãÀ ãÀ ã
   À ãC€İÀ ãûÀ ãû€ª/// Called when the parser encounters a binary operator, in between the LHS
/// and RHS subexpressions.
///
/// Not called when the binary operator is `.`, `?.`, or `..`. À äÀ äÀ ä   À ä$]À ä)À ä)  À ä=À äDÀ äC  À äJÀ äQÀ äP   À ä…sÀ äÖÀ äÖI/// Called when the parser has consumed the operator of a binary pattern. À äéÀ äğÀ äï   À äü€ĞÀ åŠÀ åŠ€„/// Called when the parser has consumed a binary pattern, consisting of a LHS
/// pattern, `&&` or `||` operator, and a RHS pattern. À å›À å¢À å¡   À åĞ€ºÀ æIÀ æIm/// Called for property access through `.` and `?.`.
///
/// [isNullAware] is `true` if the access uses `?.`. À æYÀ æ`À æ_  À æfÀ æmÀ æl  À ævÀ æ|À æ{   À æ€ÀÀ ç	À ç	o/// Called for cascade access through `..` and `?..`.
///
/// [isNullAware] is `true` if the access uses `?..`. À çÀ ç$À ç#  À ç*À ç1À ç0  À ç:À ç@À ç?   À çR€œÀ çÁÀ çÁe/// Called when the parser encounters a `?` operator and begins parsing a
/// conditional expression. À çÜÀ çãÀ çâ   À çò€„À èQÀ èQU/// Called when the parser encounters a `:` operator in a conditional
/// expression.   À èz€ÂÀ èÊÀ èÊH/// Called when the parser finishes processing a conditional expression. À èãÀ èêÀ èé  À èóÀ èúÀ èù  À é À éÀ é   À é@0À éEÀ éE  À éZÀ éaÀ é`   À étKÀ éyÀ éy  À éŒÀ é“À é’   À éÃOÀ éÈÀ éÈ  À éÛÀ éâÀ éá   À ê€ÌÀ ê©À ê©€‰/// Called before parsing a "for" control flow list, set, or map entry.
/// Ended by either [endForControlFlow] or [endForInControlFlow]. À ê½À êÅÀ êÄ  À êĞÀ ê×À êÖ   À êæ€íÀ ëŒÀ ëŒ€š/// Called after parsing a "for" control flow list, set, or map entry.
/// One of the two possible corresponding end events for
/// [beginForControlFlow]. À ëÀ ë¥À ë¤   À ë×€ôÀ ì€À ì€€/// Called after parsing a "for-in" control flow list, set, or map entry.
/// One of the two possible corresponding end events for
/// [beginForControlFlow]. À ì”À ì›À ìš   À ìÏ€·À íbÀ íb€‰/// Called before parsing an `if` control flow list, set, or map entry.
/// Ended by either [endIfControlFlow] or [endIfElseControlFlow]. À íuÀ í|À í{   À íŠ€À íõÀ íõa/// Called before parsing the `then` portion of an `if` control flow list,
/// set, or map entry. À îÀ îÀ î   À î€¸À î‰À î‰a/// Called before parsing the `else` portion of an `if` control flow list,
/// set, or map entry. À îŸÀ î¦À î¥   À îÚ4À ïÉÀ ïÉ€İ/// Called after parsing an `if` control flow list, set, or map entry.
/// Substructures:
/// - if conditional expression
/// - expression
/// One of the two possible corresponding end events for
/// [beginIfControlFlow]. À ïÚÀ ïáÀ ïà   À ğ\À ñ!À ñ!€û/// Called after parsing an if-else control flow list, set, or map entry.
/// Substructures:
/// - if conditional expression
/// - then expression
/// - else expression
/// One of the two possible corresponding end events for
/// [beginIfControlFlow]. À ñ6À ñ=À ñ<   À ñr€úÀ òÀ ò€/// Called after parsing a list, set, or map entry that starts with
/// one of the spread collection tokens `...` or `...?`.  Substructures:
/// - expression À ò2À ò9À ò8   À òp€İÀ òùÀ òù}/// Called after parsing a list or set element that starts with the null-aware
/// token `?`. Substructures:
/// - expression À óÀ óÀ ó   À óQ€şÀ óğÀ óğ€“/// Called after parsing an element of a list or map pattern that starts with
/// `...`.  Substructures:
/// - pattern (if hasSubPattern is `true`) À ô
À ô	À ô  À ôÀ ôÀ ô   À ôS€šÀ ô¼À ô¼_/// Handle the start of a function typed formal parameter.  Substructures:
/// - type variables À ôŞÀ ôåÀ ôä   À ôñ
À õ†À õ†€‡/// Handle the end of a function typed formal parameter.  Substructures:
/// - type variables
/// - return type
/// - formal parameters À õ¦À õ­À õ¬  À õ·À õ¿À õ¾   À õÿ€ÓÀ öxÀ öxm/// Handle an identifier token.
///
/// [context] indicates what kind of construct the identifier appears in. À ö‰À öÀ ö  À ö–À ö©À ö¨   À öÖ€šÀ öÛÀ öÛ  À öøÀ ÷ À öÿ  À ÷À ÷À ÷  À ÷*À ÷1À ÷0   À ÷t+À ÷yÀ ÷y  À ÷À ÷”À ÷“   À ÷£LÀ ÷¨À ÷¨  À ÷ºÀ ÷ÁÀ ÷À   À ÷óUÀ ÷øÀ ÷ø  À ø	À øÀ ø  À ø
À ø#À ø"   À øLFÀ øQÀ øQ  À øcÀ øjÀ øi   À øÉ€„À øÎÀ øÎ  À øèÀ øîÀ øí  À øüÀ ùÀ ù  À ùÀ ùÀ ù   À ù„€À ù‰À ù‰  À ù¦À ù¬À ù«  À ùºÀ ùÁÀ ùÀ  À ùÕÀ ùÜÀ ùÛ   À úLÀ úÀ ú  À ú/À ú6À ú5   À úe5À újÀ új  À úvÀ ú}À ú|  À ú‹À ú“À ú’   À úÑ€¡À úÖÀ úÖ  À úåÀ úìÀ úë  À úşÀ ûÀ û  À ûÀ ûÀ û  À û*À û2À û1  À ûAÀ ûHÀ ûG   À ûv€ÁÀ ûòÀ ûòr/// Called with either the token containing a double literal, or an
/// immediately preceding "unary minus" token. À üÀ üÀ ü   À ü;€íÀ üÇÀ üÇ€‚/// Called with either the token containing a double literal with separators,
/// or an immediately preceding "unary minus" token. À üéÀ üğÀ üï   À ı,€½À ıªÀ ıªt/// Called with either the token containing an integer literal, or an
/// immediately preceding "unary minus" token. À ı»À ıÂÀ ıÁ   À ıí€éÀ ş{À ş{€„/// Called with either the token containing an integer literal with
/// separators, or an immediately preceding "unary minus" token. À şšÀ ş¡À ş    À şÚ€•À şßÀ şß  À şö	À şûÀ şú  À ÿÀ ÿÀ ÿ  À ÿÀ ÿ$À ÿ#  À ÿ5À ÿ<À ÿ;   À ÿs€ôÀ À €„/// Called after the parser has consumed a list pattern, consisting of a `[`,
/// a comma-separated sequence of patterns, and a `]`. À 	À À   À À %À $  À 1À 8À 7   À kWÀ pÀ p  À ‹	À À   À šÀ ¡À    À ¯À ·À ¶  À ÈÀ ÏÀ Î  À†ÀŒÀ‹   ÀÆ€ôÀZÀZ€Š/// Called after the parser has consumed a map pattern, consisting of a `{`,
/// a comma-separated sequence of mapPatternEntry, and a `}`. Àk	ÀpÀo  ÀvÀ}À|  À‡ÀÀ   À¾FÀÃÀÃ  ÀÕÀÜÀÛ   À\ÀÀ  À À'À&  À3À9À8   ÀhJÀmÀm  ÀÀˆÀ‡   À¶€ÍÀ?À?/// Called after the parser has consumed a patternField, consisting of an
/// optional identifier, optional `:`, and a pattern. ÀRÀZÀY   À‡PÀŒÀŒ  À£ÀªÀ©   ÀÛ'ÀàÀà  ÀóÀúÀù   ÀGÀÀ  ÀÀ#À"   ÀQFÀVÀV  ÀhÀoÀn   À›€˜À À   ÀÛÀâÀá   À7pÀ<À<  ÀcÀjÀi   À«CÀ°À°  À½ÀÄÀÃ   ÀòNÀ÷À÷  ÀÀÀ   ÀD@ÀIÀI  ÀXÀ_À^   Àˆ€¤ÀÕÀÕE/// Invoked when a pattern switch case doesn't have the 'when' clause ÀòÀùÀø   À0fÀ5À5  ÀWÀ^À]   ÀšDÀŸÀŸ  À°À·À¶   Àâ€£À	+À	+A/// Handle the end of a construct of the form "operator <token>". À	>À	EÀ	D  À	UÀ	\À	[   À	‰€ãÀ
À
q/// Handle the end of a construct of the form "operator <token>"
/// where <token> is not a valid operator token. À
À
%À
$  À
5À
<À
;   À
pÀ
ÿÀ
ÿ/// Handle the condition in a control structure:
/// - if statement
/// - do while loop
/// - switch statement
/// - while loop ÀÀ#À"  À)À1À0  À7À?À>   ÀuTÀ‘À‘/// Starts a pattern ÀÀ¥À¤   ÀÍ€“ÀÀJ/// Starts a pattern guard, the expression that follows the 'when' keyword À1
À8À7   Àd€ÑÀúÀú€Œ/// Starts a parenthesized expression or a record literal. Will be ended with
/// either [endParenthesizedExpression] or [endRecordLiteral]. À&À-À,   À9€¡À‰À‰H/// Starts a guard expression in a switch case, after the 'when' keyword À£
ÀªÀ©   ÀŞ€™ÀÀ//// Ends a record literal with [count] entries. À&À-À,  À3	À8À7  À>ÀFÀE   À{€åÀÀ€‹/// Called after the parser has consumed a record pattern, consisting of a
/// `(`, a comma-separated sequence of patternFields, and a `)`. À$À+À*  À1	À6À5   ÀdPÀ~À~/// Ends a pattern À‰ÀÀ   À¸€ÀÀG/// End a pattern guard, the expression that follows the 'when' keyword ÀÀÀ   ÀKÀüÀü€¥/// End a parenthesized expression.
/// These may be within the condition expression of a control structure
/// but will not be the condition of a control structure. ÀÀÀ   ÀV€ À¦À¦H/// Starts a guard expression in a switch case, after the 'when' keyword À¾ÀÅÀÄ   Àú€ÍÀtÀtp/// Called after the parser has consumed a parenthesized pattern, consisting
/// of a `(`, a pattern, and a `)`. ÀÀ–À•   ÀË‚®À)À)‚D/// Called after the parser has consumed a constant pattern, consisting of an
/// optional `const` and an expression.
///
/// Note that some expressions can legally begin with `const`, so there is
/// ambiguity as to whether to associate the `const` keyword with the constant
/// pattern or the constant expression.  This ambiguity is resolved in favor
/// of associating the `const` keyword with the constant pattern.  So for
/// example, in `case const []` the `const` keyword is passed to
/// [beginConstantPattern] and [endConstantPattern] rather than
/// [handleLiteralList]. À>ÀFÀE   À}‚¬ÀÛÀÛ‚D/// Called after the parser has consumed a constant pattern, consisting of an
/// optional `const` and an expression.
///
/// Note that some expressions can legally begin with `const`, so there is
/// ambiguity as to whether to associate the `const` keyword with the constant
/// pattern or the constant expression.  This ambiguity is resolved in favor
/// of associating the `const` keyword with the constant pattern.  So for
/// example, in `case const []` the `const` keyword is passed to
/// [beginConstantPattern] and [endConstantPattern] rather than
/// [handleLiteralList]. ÀîÀöÀõ   À-‰À1À1€ö/// Called after the parser has consumed an object pattern, consisting of
/// an identifier, optional dot and second identifier, optional type
/// arguments, and a parenthesized list of object pattern fields (see
/// [handleObjectPatternFields]). ÀJÀQÀP  Àe
ÀmÀl  ÀuÀ}À|   ÀºCÀ¿À¿€õ/// Handle a construct of the form "identifier.identifier" occurring in a part
/// of the grammar where expressions in general are not allowed.
/// Substructures:
/// - Qualified identifier (before the period)
/// - Identifier (after the period) ÀÏÀÖÀÕ   ÀDÀÀ  ÀÀÀ   ÀIiÀNÀN  ÀdÀkÀj  ÀqÀ„Àƒ   À¶€¡À»À»  ÀİÀäÀã  ÀõÀüÀû  ÀÀÀ   À[NÀ`À`  ÀpÀuÀt  À€À…À„  À•ÀœÀ›   À­€áÀ²À²  ÀÅÀÊÀÉ  ÀÙÀŞÀİ  ÀòÀúÀù  ÀÀÀ  À+À0À/  ÀCÀJÀI  ÀYÀ`À_   À’#À—À—    À¹€™À¾À¾  ÀÛÀâÀá  ÀñÀùÀø  ÀÀ	À  ÀÀÀ   ÀVgÀ[À[  ÀpÀwÀv  À}ÀÀ   ÀÁpÀÆÀÆ  ÀíÀôÀó   À5ZÀ:À:  ÀVÀ]À\   À“€ïÀ 5À 5€˜/// Called after the parser has consumed a relational pattern, consisting of
/// an equality operator or relational operator, followed by an expression. À MÀ TÀ S   À †nÀ ‹À ‹  À ±À ¸À ·   À ø4À ıÀ ı    À!0lÀ!5À!5    À! €“À!¥À!¥  À!ÆÀ!ÍÀ!Ì  À!ØÀ!ßÀ!Ş  À!éÀ!şÀ!ı   À"7fÀ"<À"<  À"^À"eÀ"d   À"¡FÀ"¦À"¦  À"¸À"¿À"¾   À"ë€íÀ#oÀ#oz/// The parser saw a void with type arguments (e.g. void<int>).
/// This is not valid - an error has already been emitted. À#’À#™À#˜   À#ÜqÀ$*À$*F/// Ended by either [endYieldStatement] or [endInvalidYieldStatement]. À$>À$EÀ$D   À$Q€ûÀ$áÀ$áS/// One of the two possible corresponding end events for
/// [beginYieldStatement]. À$óÀ$úÀ$ù  À%À%À%  À%À%À%   À%PÀ%­À%­S/// One of the two possible corresponding end events for
/// [beginYieldStatement]. À%ËÀ%ÒÀ%Ñ  À%áÀ%éÀ%è  À%÷À%şÀ%ı  À&À&À&   À&VÕÀ'ÎÀ'Î(/// The parser noticed a syntax error, but was able to recover from it. The
/// error should be reported using the [message], and the code between the
/// beginning of the [startToken] and the end of the [endToken] should be
/// highlighted. The [startToken] and [endToken] can be the same token. À'êÀ'óÀ'ò  À'ÿÀ(À(  À(À(À(   À(/‚£À)ßÀ)ß^/// The parser noticed a use of the experimental feature by the flag
/// [experimentalFlag] that was not enabled, but was able to recover from it.
/// The error should be reported and the code between the beginning of the
/// [startToken] and the end of the [endToken] should be highlighted. The
/// [startToken] and [endToken] can be the same token. À)ÿ!À*À*  À*&À*-À*,  À*<À*CÀ*B   À*ÖfÀ+ÒÀ+Ò€î/// The parser encountered an [ErrorToken] representing an error
/// from the scanner but recovered from it. By default, the error is reported
/// by calling [handleRecoverableError] with the message associated
/// with the error [token]. À+ãÀ+ïÀ+î   À,@€·À,QÀ,Q  À,jÀ,sÀ,r  À,À,†À,…  À,“À,˜À,—  À,©
À,®À,­  À,@À,AÀ,ûªÀ.8À.8//// Signals to the listener that the previous statement contained a semantic
/// error (described by the given [message]). This method can also be called
/// after [handleExpressionFunctionBody], in which case it signals that the
/// implicit return statement of the function contained a semantic error. À.OÀ.VÀ.U  À.\À.eÀ.d   À.©<À.®À.®  À.»À.ÂÀ.Á   À.éƒ9À1êÀ1ê‚á/// An expression was encountered consisting of type arguments applied to a
/// subexpression.  This could validly represent any of the following:
/// - A type literal (`var x = List<int>;`)
/// - A function tear-off with type arguments (`var x = f<int>;` or
///   `var x = importPrefix.f<int>;`)
/// - A static method tear-off with type arguments (`var x = ClassName.m<int>`
///   or `var x = importPrefix.ClassName.m<int>;`)
/// - An instance method tear-off with type arguments (`var x = EXPR.m<int>;`)
///
/// Or, in the event of invalid code, it could represent type arguments
/// erroneously applied to some other expression type (e.g.
/// `var x = (f)<int>;`).  The client is responsible for reporting an error if
/// this occurs. À2À2À2   À2&VÀ3WÀ3W#/// A `new` token was found in a place where an identifier was expected, and
/// the "constructor tearoffs" feature permits `new` to be used as an
/// identifier name.  It is the client's responsibility to report an
/// appropriate error if the "constructor tearoffs" feature is not enabled. À3mÀ3tÀ3s   À3€ôÀ4ÑÀ4Ñ?/// Called after the parser has processed a variable declaration statement,
/// consisting of `METADATA KEYWORD PATTERN EQUALS EXPRESSION SEMICOLON`.
///
/// KEYWORD is either `var` or `final`, and PATTERN may only be one of the
/// patterns accepted by the `outerPattern` grammar rule defined in the
/// patterns spec. À5 À5À5  À5À5À5  À5%À5,À5+   À5xIÀ6sÀ6s€ë/// Called after the parser has processed a pattern assignment consisting of
/// `PATTERN EQUALS EXPRESSION`.
///
/// PATTERN may only be one of the patterns accepted by the `outerPattern`
/// grammar rule defined in the patterns spec. À6‹À6’À6‘   À6ÅVÀ6ÊÀ6Ê  À6äÀ6ëÀ6ê   À7PÀ7$À7$  À7;À7BÀ7A   À7s+À7xÀ7x  À7À7–À7•   À7¢OÀ7§À7§  À7¼À7ÃÀ7Â                  €â  parser_impl.dart#_fe_analyzer_shared.parser.listenerŠ³ N€œ€Ø€Ù€ü)*Os®¯ÚÛ‚‚‚4‚5‚^‚_‚­‚®‚ì‚íƒ&ƒ'ƒsƒtƒŸƒ ƒÇƒãƒø„„ „0„5„7„8„~„”„˜„ä„è….…~…”…˜…ç…ò†$†<†=†]†^†„†…†È†ã†ç†è‡4‡b‡²‡×‡Û‡ÜˆˆVˆuˆyˆzˆÅˆñˆò‰-‰K‰‰‰ª‰®‰¯‰êŠŠ*Š@ŠTŠoŠuŠŠ¡Š¢ŠÙŠÚŠëŠú‹‹$‹=‹C‹Z‹^‹_‹©‹ç‹õŒ'Œ(ŒLŒMŒcŒ|Œ€ŒŒ²Œ³Œû n¹Çc«±î/DZnt¡¥¦óZœºÀé‘0‘1‘d‘§‘ñ‘÷’D’b’s’’¤’¼’Ò’í“““4“D“K“L“’“Á””_”m”¯”Í”Ñ”Ò••0•J•“•¯•³•´•ô–––*–A–S–g––—–ç———	—Q—“—Ñ—ù˜-˜?˜S˜m˜±˜Û˜ß˜à™™2™E™„™¦™ª™«™Ş™üšš+šAšYšišpšqš²šÌ›››!›"›b›s›†››®›È›÷œœœœOœ‘œÏDUo‘¥Éíñò/D`ŸÁÅÆŸŸ
Ÿ3ŸpŸqŸÁŸÒŸØ & s y ¢ å æ¡6¡M¡S¡ ¡Â¡Û¡÷¢¢¢¢Z¢‘¢¡¢®¢Î¢ä£ ££*£0£V£Z£[£¨£¿£Å¤¤8¤S¤o¤¤†¤‡¤Ñ¥¥0¥J¥W¥{¥‘¥ª¥Æ¥İ¥ñ¥÷¦!¦%¦&¦r¦¢¦Õ¦ù¦ı¦ş§H§–§´§º§ê§ğ¨¨B¨R¨p¨†¨Ÿ¨¼¨Â¨æ¨ê¨ë©:©j©±©²©Ú©Û©şªªª ªLªMª†ªËªÑ««_«p«‘«’«Æ«ç«ë«ì¬¬¬G¬p¬¬’¬“¬Ä¬Å¬ø­­)­F­Z­—­­Ã­Ç­È­õ­ö®-®I®^®v®Š®®²®¶®·®è®é¯¯=¯A¯B¯q¯r¯¥¯Ô¯ø¯ü¯ı°$°%°b°°•°¥°»°Ò°ç°ü±±±,±0±1±z±‹±Ÿ±Ô±ë²²²/²<²W²l²‚²˜²¶²Ê²Ğ³³$³4³F³X³q³³ˆ³Œ³³¼³Û³ò´9´W´[´\´œ´­´Ì´ã´÷µµ*µCµZµoµuµ‘µ•µ–µÄµÕµõ¶7¶T¶X¶Y¶v¶Œ¶¦¶º¶À····)·*·g·x·„··±·ê¸¸¸¸P¸Ÿ¸Ã¹¹+¹/¹0¹u¹š¹¹Ÿ¹Ùºº2ºWºoº‰º º§º¨ºÆºÜºö»
»»4»8»9»W»m»‡»›»¡»á¼"¼&¼'¼I¼_¼y¼¼“¼Ó½½½½?½U½o½ƒ½‰½É¾
¾¾¾,¾=¾R¾l¾‡¾£¾ª¾«¾Æ¾Ş¾÷¿¿/¿L¿g¿…¿ ¿¦¿Ç¿Ë¿ÌÀ @À @0À @4À @5À @sÀ @tÀ @À @ŸÀ @µÀ @ÉÀ @ŞÀ @äÀ AÀ A
À AÀ ANÀ A_À AqÀ A~À AªÀ A°À AĞÀ AçÀ BÀ BÀ B4À BLÀ BgÀ B}À B™À B¨À B¾À BÒÀ BØÀ BğÀ BôÀ BõÀ C8À CIÀ C[À ChÀ C”À CšÀ CºÀ CÑÀ CëÀ DÀ DÀ D6À DQÀ DgÀ DƒÀ D’À D¨À D¼À DÂÀ EÀ EÀ E+À E?À ETÀ EgÀ E}À EÀ E¥À E²À EÄÀ EÔÀ EÛÀ EßÀ EàÀ F'À F8À FJÀ FWÀ FƒÀ F‰À F©À FÄÀ FŞÀ F÷À GÀ G)À GDÀ GZÀ GvÀ G…À G›À G¯À GµÀ GõÀ H	À HÀ H2À HGÀ HZÀ HpÀ HÀ H˜À H¥À H·À HÇÀ HÎÀ HÒÀ HÓÀ IÀ I0À IBÀ IOÀ I{À IÀ I¡À IÀÀ IÚÀ IóÀ JÀ J%À J@À JVÀ JrÀ JÀ J—À J«À J±À JñÀ KÀ KÀ K.À KCÀ KVÀ KlÀ K}À K”À K¡À K³À KÃÀ KÊÀ KÎÀ KÏÀ LÀ L#À L5À LBÀ LnÀ LtÀ L”À LªÀ LÄÀ LİÀ L÷À MÀ M*À M@À M\À MkÀ MÀ M•À M›À M¯À MÄÀ MØÀ MíÀ N À NÀ N'À N>À NKÀ N]À NmÀ NtÀ NxÀ NyÀ N½À NÎÀ NâÀ OÀ O.À OHÀ O]À OrÀ OÀ O•À OªÀ OÀÀ OÖÀ OôÀ PÀ PÀ P"À P2À PDÀ PVÀ PoÀ PÀ P†À PŠÀ P‹À PÛÀ PüÀ Q5À QcÀ QgÀ QhÀ Q¸À QŞÀ R(À R[À R_À R`À R°À RæÀ SÀ SjÀ S¢À S¦À S§À S÷À T-À T^À T”À T§À T¹À T¿À TşÀ UÀ UÀ UEÀ UlÀ U•À U–À UŞÀ V+À ViÀ V„À VšÀ V¯À VÈÀ VâÀ WÀ WÀ W	À W<À WeÀ WƒÀ W‡À WˆÀ WµÀ W¶À WéÀ XÀ X8À X<À X=À XˆÀ XÕÀ YÀ YFÀ Y–À YµÀ YğÀ ZÀ Z$À Z8À ZSÀ ZnÀ ZƒÀ ZŠÀ Z‹À ZÚÀ [À [/À [FÀ [JÀ [KÀ [wÀ [xÀ [¡À [ÂÀ [ÆÀ [ÇÀ [íÀ [îÀ \!À \GÀ \bÀ \fÀ \gÀ \³À ]À ]QÀ ]—À ]À ]²À ]ÉÀ ]ıÀ ]şÀ ^BÀ ^ŒÀ ^ØÀ _À _À _0À _GÀ _YÀ _mÀ _zÀ _ŠÀ _ŸÀ _¶À _éÀ `À `PÀ `yÀ `}À `~À `ÊÀ `ÛÀ `òÀ a'À a(À aFÀ aLÀ aaÀ arÀ a‰À aÀ aªÀ aÁÀ aÑÀ aæÀ aıÀ b0À bcÀ b˜À b½À bÁÀ bÂÀ c
À cYÀ c¨À cÒÀ d À dÀ dNÀ d—À dæÀ e4À e{À e¯À eúÀ fÀ f!À f"À fMÀ fmÀ fqÀ frÀ fºÀ fÀÀ gÀ g2À gzÀ g{À g¤À g¥À gõÀ hÀ hÀ h"À h>À hJÀ hPÀ hŒÀ h’À h§À hÌÀ hØÀ hŞÀ i+À i7À iOÀ ieÀ ivÀ i•À i›À i¹À i½À i¾À iâÀ iãÀ jÀ jÀ j]À jnÀ j‚À jœÀ j¹À jÓÀ jÙÀ k#À k4À kNÀ kkÀ k‘À kÄÀ k×À kğÀ l
À lÀ l1À l7À lZÀ l^À l_À lŸÀ l´À lÓÀ mÀ m&À m*À m+À m\À mÀ m¢À m¦À m§À mçÀ müÀ nÀ n!À niÀ nÀ nÏÀ nïÀ nóÀ nôÀ o%À oGÀ oiÀ omÀ onÀ o®À oÃÀ oâÀ oèÀ p(À p^À pÀ p±À pµÀ p¶À pïÀ q7À qÀ q‡À qÔÀ q÷À rÀ r'À r>À rVÀ rlÀ r‡À rÀ r·À rÎÀ rŞÀ råÀ ræÀ s/À sDÀ sVÀ suÀ s·À sèÀ sìÀ síÀ t0À tAÀ tSÀ tfÀ t}À tÀ t£À tÈÀ tÎÀ uÀ ucÀ u³À uóÀ uùÀ v<À v]À vnÀ v†À v˜À v¶À vÊÀ vĞÀ v÷À vûÀ vüÀ w#À w$À waÀ w‡À w«À wÁÀ wÅÀ wÆÀ wïÀ xÀ xÀ xÀ x9À x:À xZÀ xtÀ xxÀ xyÀ x¡À x¢À xëÀ yÀ yÀ yÀ y7À y8À ytÀ y“À y—À y˜À yÂÀ yÃÀ yïÀ z+À zJÀ zNÀ zOÀ zzÀ z{À zÁÀ { À {2À {hÀ {®À {ÌÀ {ĞÀ {ÑÀ |À |À |+À |DÀ |^À |rÀ |ÁÀ |ÙÀ |İÀ |ŞÀ }À }SÀ }•À }ãÀ }üÀ ~À ~*À ~YÀ ~yÀ ~}À ~~À ~ªÀ ~«À ~ÒÀ ~óÀ ~÷À ~øÀ 'À (À mÀ À ÁÀ ŞÀ €-À €MÀ €QÀ €RÀ €À €ªÀ €®À €¯À €æÀ €çÀ 3À _À cÀ dÀ –À —À ÊÀ ñÀ õÀ öÀ ‚#À ‚$À ‚aÀ ‚€À ‚³À ‚òÀ ƒÀ ƒÀ ƒÀ ƒGÀ ƒvÀ ƒšÀ ƒÀ ƒŸÀ ƒÏÀ ƒĞÀ „À „/À „iÀ „À „’À „“À „ÂÀ „ôÀ …À …À … À …HÀ …IÀ …|À …¤À …ÌÀ …ĞÀ …ÑÀ …úÀ …ûÀ †AÀ †_À †cÀ †dÀ †„À †¤À †¨À †©À †÷À ‡DÀ ‡iÀ ‡—À ‡ºÀ ‡¾À ‡¿À ˆÀ ˆVÀ ˆÀ ˆÀÀ ˆåÀ ˆéÀ ˆêÀ ‰9À ‰ƒÀ ‰’À ‰ÃÀ ‰éÀ ‰íÀ ‰îÀ ŠÀ Š'À Š+À Š,À ŠiÀ ŠjÀ Š—À Š¹À Š½À Š¾À ‹À ‹À ‹XÀ ‹iÀ ‹uÀ ‹”À ‹®À ‹ÈÀ ‹İÀ ‹ãÀ ŒÀ ŒÀ ŒÀ Œ5À Œ6À ŒsÀ Œ„À Œ²À ŒÿÀ À  À !À qÀ ÂÀ À À *À ]À {À ŒÀ ¢À ÀÀ àÀ çÀ À À À \À †À ¹À õÀ À À À EÀ FÀ –À —À ÊÀ ‘À ‘+À ‘/À ‘0À ‘zÀ ‘¢À ‘¦À ‘§À ‘öÀ ’2À ’~À ’¡À ’¹À ’ºÀ ’õÀ “À “9À “fÀ “…À “‰À “ŠÀ “ÅÀ ”À ”À ”JÀ ”ŠÀ ”ÊÀ ”şÀ •*À •?À •WÀ •[À •\À •«À •¼À –À –XÀ –pÀ –„À –©À –ÂÀ –ÜÀ –ôÀ —À —+À —@À —PÀ —vÀ —}À —~À —ÂÀ —ÓÀ —çÀ ˜À ˜3À ˜MÀ ˜bÀ ˜wÀ ˜„À ˜›À ˜°À ˜ÆÀ ˜ÜÀ ˜úÀ ™À ™À ™1À ™5À ™6À ™zÀ ™‹À ™ŸÀ ™ÔÀ ™ëÀ šÀ šÀ š/À š<À šSÀ šhÀ š~À š”À š²À šÆÀ šÌÀ ›À › À ›0À ›BÀ ›TÀ ›mÀ ›}À ›„À ›ˆÀ ›‰À ›ÑÀ ›âÀ ›öÀ œ+À œBÀ œ\À œqÀ œ†À œ“À œ®À œÃÀ œÙÀ œïÀ À !À 'À gÀ {À ‹À À ¯À ÈÀ ØÀ ßÀ ãÀ äÀ 1À BÀ VÀ ‹À ¢À ¼À ÑÀ æÀ óÀ ŸÀ Ÿ'À Ÿ=À ŸSÀ ŸqÀ Ÿ…À Ÿ‹À ŸËÀ ŸßÀ ŸïÀ  À  À  ,À  <À  CÀ  GÀ  HÀ  ‘À  ¢À  ¶À  ëÀ ¡À ¡À ¡1À ¡FÀ ¡SÀ ¡oÀ ¡„À ¡šÀ ¡°À ¡ÎÀ ¡âÀ ¡èÀ ¢(À ¢<À ¢LÀ ¢^À ¢pÀ ¢‰À ¢™À ¢ À ¢¤À ¢¥À ¢îÀ ¢ÿÀ £À £HÀ £_À £yÀ £À ££À £°À £ÌÀ £áÀ £÷À ¤À ¤+À ¤?À ¤EÀ ¤…À ¤™À ¤©À ¤»À ¤ÍÀ ¤æÀ ¤öÀ ¤ıÀ ¥À ¥À ¥OÀ ¥`À ¥tÀ ¥©À ¥ÀÀ ¥ÚÀ ¥ïÀ ¦À ¦À ¦1À ¦FÀ ¦\À ¦rÀ ¦À ¦¤À ¦ªÀ ¦êÀ ¦şÀ §À § À §2À §KÀ §[À §bÀ §fÀ §gÀ §ªÀ §¿À §ĞÀ §äÀ ¨À ¨0À ¨JÀ ¨_À ¨tÀ ¨À ¨¥À ¨ºÀ ¨ĞÀ ¨æÀ ©À ©À ©À ©^À ©wÀ ©‡À ©™À ©«À ©ÄÀ ©ÔÀ ©ÛÀ ©ßÀ ©àÀ ª	À ª
À ª.À ªLÀ ªPÀ ªQÀ ªvÀ ªwÀ ª¶À ªÉÀ ªàÀ «$À «6À «†À « À «¤À «¥À «ÚÀ «ÛÀ «ÿÀ ¬À ¬$À ¬8À ¬MÀ ¬SÀ ¬}À ¬À ¬‚À ¬£À ¬¤À ¬ŞÀ ¬ïÀ ¬ûÀ ­0À ­FÀ ­JÀ ­KÀ ­nÀ ­oÀ ­®À ­¿À ­íÀ ­óÀ ®CÀ ®QÀ ®cÀ ®zÀ ®À ®¤À ®¶À ®¼À ®ÔÀ ®ØÀ ®ÙÀ ¯À ¯À ¯RÀ ¯zÀ ¯~À ¯À ¯«À ¯¬À ¯ÙÀ °À °aÀ °…À °‰À °ŠÀ °×À ±À ±[À ±rÀ ±¿À ±êÀ ±îÀ ±ïÀ ²;À ²}À ²ÊÀ ²õÀ ²ùÀ ²úÀ ³;À ³mÀ ³À ³”À ³•À ³áÀ ´À ´_À ´«À ´ôÀ µÀ µ À µ!À µ<À µTÀ µjÀ µ~À µ„À µ¥À µ©À µªÀ µàÀ µöÀ µúÀ µûÀ ¶"À ¶#À ¶`À ¶…À ¶©À ¶¿À ¶ÃÀ ¶ÄÀ ¶ğÀ ¶ñÀ ·$À ·eÀ ·†À ·ŠÀ ·‹À ·¸À ·¹À ·ìÀ ¸.À ¸PÀ ¸TÀ ¸UÀ ¸}À ¸~À ¸ÇÀ ¸äÀ ¸èÀ ¸éÀ ¹À ¹À ¹OÀ ¹pÀ ¹ƒÀ ¹™À ¹­À ¹³À ¹ÚÀ ¹ŞÀ ¹ßÀ º	À º
À ºJÀ ºiÀ ºmÀ ºnÀ º¡À ºâÀ »À »À »À »5À »6À »iÀ »ªÀ »ÌÀ »ĞÀ »ÑÀ ¼À ¼]À ¼§À ¼ÈÀ ¼ÎÀ ½ À ½DÀ ½„À ½ÎÀ ½İÀ ½ãÀ ¾À ¾nÀ ¾ À ¾ÓÀ ¿À ¿(À ¿,À ¿-À ¿uÀ ¿¾À ¿ıÀ À0À À6À ÀKÀ À\À ÀÀ ÀÉÀ ÀõÀ ÀùÀ ÀúÀ Á@À Á|À Á‚À Á«À ÁÖÀ Á×À Â
À ÂTÀ Â„À Â˜À Â½À Â×À ÂğÀ Ã
À Ã"À Ã=À ÃSÀ ÃoÀ Ã‡À ÃÀ ÃÀ ÃÙÀ ÃêÀ Ã÷À ÄÀ Ä<À ÄXÀ Ä^À Ä~À Ä˜À Ä±À ÄËÀ ÄãÀ ÄşÀ ÅÀ Å0À Å?À ÅUÀ ÅiÀ ÅoÀ ÅÀ Å“À Å”À Å°À ÅÈÀ ÅáÀ ÅûÀ ÆÀ ÆÀ Æ?À ÆPÀ ÆbÀ ÆvÀ Æ‰À Æ À ÆºÀ ÆÏÀ ÆÜÀ Ç*À ÇJÀ ÇNÀ ÇOÀ ÇxÀ ÇyÀ Ç¡À Ç¢À ÇÇÀ ÇäÀ ÇèÀ ÇéÀ È8À ÈTÀ ÈXÀ ÈYÀ È‹À È©À È­À È®À ÈÆÀ ÈÚÀ ÈğÀ ÉÀ ÉÀ É%À ÉCÀ ÉGÀ ÉHÀ ÉƒÀ É™À ÉÀ ÉÀ ÉÈÀ ÊÀ Ê8À ÊaÀ ÊeÀ ÊfÀ Ê¶À ÊâÀ ËÀ Ë2À Ë6À Ë7À ËˆÀ Ë²À ËâÀ ÌÀ ÌÀ Ì	À ÌRÀ Ì“À Ì™À ÌèÀ Í3À ÍfÀ ÍÀ ÍÆÀ ÍÊÀ ÍËÀ ÎÀ Î^À Î¡À Î§À Î÷À ÏFÀ Ï•À ÏâÀ ÏòÀ ĞÀ Ğ,À ĞBÀ ĞiÀ ĞpÀ Ğ™À ĞÀ ĞÀ ĞîÀ Ñ<À ÑRÀ Ñ‘À Ñ²À Ñ¶À Ñ·À ÑÚÀ ÑòÀ ÑöÀ Ñ÷À Ò$À Ò%À ÒXÀ Ò^À ÒsÀ ÒŒÀ Ò«À Ò±À ÒÏÀ ÓÀ ÓeÀ Ó{À Ó’À Ó«À ÓºÀ ÓÓÀ ÓÙÀ ÓõÀ ÓùÀ ÓúÀ ÔÀ ÔÀ ÔMÀ ÔSÀ ÔhÀ ÔyÀ Ô†À Ô™À Ô·À ÔØÀ ÔÜÀ ÔİÀ ÕÀ ÕÀ ÕLÀ ÕRÀ ÕgÀ Õ€À ÕÀÀ ÕçÀ ÕëÀ ÕìÀ ÖÀ ÖÀ ÖXÀ Ö^À ÖsÀ ÖŠÀ ÖÀ Ö¸À ÖûÀ ×À ×À ×À ×HÀ ×IÀ ×À ×¯À ×³À ×´À ×âÀ Ø"À ØSÀ ØtÀ ØxÀ ØyÀ Ø¥À ØÆÀ ØÊÀ ØËÀ ÙÀ Ù(À Ù9À ÙSÀ Ù|À Ù}À ÙÌÀ ÚÀ Ú>À Ú{À Ú|À ÚÁÀ ÛÀ Û+À Û1À ÛFÀ ÛYÀ Û_À Û›À Û³À ÛÄÀ ÛÓÀ ÛîÀ ÜÀ Ü	À Ü'À Ü+À Ü,À ÜVÀ ÜWÀ Ü“À Ü²À Ü¶À Ü·À ÜòÀ İÀ İ_À İeÀ İiÀ İjÀ İ™À İšÀ İİÀ İòÀ Ş	À Ş#À Ş8À ŞEÀ Ş†À ŞªÀ Ş®À Ş¯À ŞòÀ ßÀ ßÀ ß2À ßCÀ ßYÀ ßuÀ ß|À ß}À ßÉÀ àÀ àRÀ àxÀ à|À à}À à¨À à©À àÜÀ áÀ á;À á?À á@À ánÀ áoÀ ášÀ áºÀ á¾À á¿À áéÀ âÀ â	À â
À âUÀ âˆÀ â³À âĞÀ âÔÀ âÕÀ ãÀ ã<À ã@À ãAÀ ãÀ ã­À ã³À ãôÀ ä!À ä"À ä\À ä~À ä‚À äƒÀ äÏÀ äùÀ äúÀ åJÀ åƒÀ åªÀ åÉÀ åÍÀ åÎÀ æÀ æÀ æBÀ æ‹À æŒÀ æÄÀ æÊÀ çÀ çOÀ çPÀ çœÀ çºÀ çïÀ çğÀ è8À èJÀ èwÀ èxÀ èÃÀ éÀ é9À é=À é>À éqÀ érÀ é›À é¼À éÀÀ éÁÀ éñÀ êÀ êÀ êÀ ê^À ê¢À êãÀ êäÀ ë-À ëhÀ ë…À ë­À ëĞÀ ëÔÀ ëÕÀ ì!À ì\À ìyÀ ì£À ìÈÀ ìÌÀ ìÍÀ íÀ í[À í‡À íˆÀ íÕÀ íîÀ îÀ îÀ îiÀ î‚À î²À îÓÀ î×À îØÀ ï!À ï6À ïXÀ ïkÀ ï¦À ïÂÀ ïéÀ ğÀ ğÀ ğÀ ğ\À ğqÀ ğ“À ğ«À ğÃÀ ğşÀ ñÀ ñEÀ ñkÀ ñoÀ ñpÀ ñ¶À òÀ òÀ òGÀ òiÀ òmÀ ònÀ ò¿À òßÀ òòÀ ó(À óJÀ óNÀ óOÀ óŸÀ ó¼À óéÀ ô/À ôLÀ ôPÀ ôQÀ ôÀ ôµÀ ôîÀ ôïÀ õ:À õQÀ õeÀ õÀ õÊÀ õøÀ õüÀ õıÀ öÀ ö%À öqÀ ö³À öÏÀ öÓÀ öÔÀ öôÀ ÷	À ÷&À ÷DÀ ÷JÀ ÷mÀ ÷qÀ ÷rÀ ÷ À ÷¡À ÷ÌÀ ÷ìÀ ÷ğÀ ÷ñÀ ø)À øEÀ øIÀ øJÀ ørÀ øÀ ø“À ø”À øÇÀ øäÀ øøÀ ùÀ ù$À ù*À ùJÀ ùNÀ ùOÀ ù‚À ù¢À ù¶À ùÑÀ ùåÀ ùëÀ úÀ úÀ úÀ ú>À ú^À úbÀ úcÀ ú›À úœÀ úÏÀ úáÀ úúÀ ûÀ û&À û=À ûQÀ ûWÀ ûoÀ ûsÀ ûtÀ ûºÀ ûëÀ üÀ ü4À ü8À ü9À ü‰À üÀÀ üøÀ ı%À ı)À ı*À ırÀ ı£À ıÊÀ ıæÀ ıêÀ ıëÀ ş1À ştÀ ş©À şÓÀ ş×À şØÀ şòÀ ÿÀ ÿÀ ÿ1À ÿIÀ ÿOÀ ÿlÀ ÿpÀ ÿqÀ ÿÁÀ ÿúÀ GÀ dÀ hÀ iÀ ‡À –À «À ÄÀ ÚÀ#ÀrÀ‚À˜ÀÀ¿ÀÃÀÄÀÀSÀ›À·À»À¼ÀäÀÀÀÀCÀaÀeÀfÀÀ¯À³À´À À8ÀbÀ€À„À…À²ÀÔÀØÀÙÀÀÀ+ÀJÀNÀOÀwÀ”À˜À™ÀêÀ0À4À5ÀrÀ¤À¨À©ÀÓÀëÀïÀğÀÀ=ÀAÀBÀgÀÀ…À†ÀÎÀÀ)À-À.ÀfÀ“À—À˜À¿ÀÛÀßÀàÀ	$À	dÀ	‚À	†À	‡À	ÊÀ	ıÀ
DÀ
iÀ
mÀ
nÀ
¡À
¶À
ÌÀ
åÀ
øÀFÀnÀrÀsÀŠÀ­ÀÆÀÊÀËÀÀ?À]ÀaÀbÀ²ÀóÀ6À7À‚À±À×ÀÛÀÜÀÀUÀtÀxÀyÀÆÀ	À>À]ÀaÀbÀwÀ˜À±ÀµÀ¶À À&ÀDÀHÀIÀoÀ¹ÀõÀ&ÀOÀSÀTÀŸÀÍÀóÀ÷ÀøÀGÀmÀÀÄÀÈÀÉÀÀCÀIÀ–ÀçÀ6À‚ÀÅÀÀ"ÀUÀvÀzÀ{ÀËÀõÀûÀHÀ™ÀèÀ4ÀwÀ¹ÀÔÀÀ&À*À+ÀwÀ¾ÀÀ*ÀFÀaÀqÀÀ”À³À·À¸À	ÀLÀaÀ’À¸ÀßÀúÀşÀÿÀ&ÀBÀFÀGÀÀ¯À³À´ÀÙÀñÀÀ&À,ÀTÀXÀYÀªÀ«ÀÁÀÕÀîÀ	À'À?ÀUÀiÀoÀ‹ÀÀÀ¶À·À×ÀíÀşÀÀ#À)ÀOÀSÀTÀšÀºÀ¾À¿ÀüÀ.À2À3ÀeÀŒÀÀ‘ÀàÀ .À \À À ƒÀ „À ÀÀ ñÀ õÀ öÀ!-À!.À!bÀ!™À!À!À!ÂÀ!ÔÀ!åÀ"À"	À"0À"4À"5À"mÀ"šÀ"À"ŸÀ"ÇÀ"äÀ"èÀ"éÀ#+À#hÀ#¡À#ÕÀ#ÙÀ#ÚÀ$#À$NÀ$OÀ$ŠÀ$§À$ÚÀ%)À%IÀ%MÀ%NÀ%‰À%¦À%ÇÀ%İÀ%óÀ&À&"À&(À&OÀ&SÀ&TÀ&¢À&ïÀ';À'…À'ÇÀ'æÀ'ûÀ(À(%À(,À(-À(tÀ(ÄÀ)À)]À)–À)ØÀ)ûÀ*"À*8À*LÀ*RÀ*nÀ*¦À*¸À*ÈÀ*ÏÀ*ÓÀ*ÔÀ+À+gÀ+­À+ËÀ+÷À,9À,=À,>À,JÀ,fÀ,{À,À,¥À,µÀ,»À,ôÀ,øÀ,ùÀ-HÀ-—À-åÀ.1À.oÀ.¢À.¦À.§À.ÊÀ.âÀ.æÀ.çÀ/5À/~À/¬À/òÀ0À0kÀ0 À0ñÀ0÷À1AÀ1À1ĞÀ1ãÀ2#À2$À2sÀ2»À3À3PÀ3}À3~À3ÌÀ4À4À4kÀ4µÀ4ÊÀ4üÀ5À5!À56À5<À5qÀ5uÀ5vÀ5ÅÀ5èÀ5îÀ6;À6lÀ6›À6¾À6ÂÀ6ÃÀ6óÀ7À7À7À7JÀ7lÀ7pÀ7qÀ7ŸÀ7 À7ËÀ7îÀ7òÀ7ô   UnescapeErrorListenerListener  *m