€Ûvalue==hashCodetoString_currentElementcurrentContextcurrentWidgetcurrentState_debugLabelkeycreateElementtoStringShortdebugFillProperties	canUpdate_debugConcreteSubtypebuildcreateStatecreatedinitializedreadydefunctwidget_widget_debugLifecycleState_debugTypesAreRightcontext_elementmounted	initStatedidUpdateWidget
reassemblesetState
deactivateactivatedisposedidChangeDependencieschilddebugIsValidRenderObjectdebugTypicalAncestorWidgetClass%debugTypicalAncestorWidgetDescription%_debugDescribeIncorrectParentDataTypeapplyParentDatadebugCanApplyOutOfTurnupdateShouldNotifycreateRenderObjectupdateRenderObjectdidUnmountRenderObjectchildreninitialactiveinactive_locked	_elements_unmount_unmountAll_deactivateRecursivelyaddremovedebugContainsownerdebugDoingBuildfindRenderObjectsizedependOnInheritedElement"dependOnInheritedWidgetOfExactTypegetInheritedWidgetOfExactType'getElementForInheritedWidgetOfExactTypefindAncestorWidgetOfExactTypefindAncestorStateOfTypefindRootAncestorStateOfTypefindAncestorRenderObjectOfTypevisitAncestorElementsvisitChildElementsdispatchNotificationdescribeElementdescribeWidgetdescribeMissingAncestordescribeOwnershipChain_buildScheduled	_buildingscheduleRebuild_dirtyElementsNeedsResorting_dirtyElements_scheduleBuildFor_tryRebuild_debugAssertElementInScope_flushDirtyElements_dirtyElementIndexAfteronBuildScheduled_inactiveElements_scheduledFlushDirtyElementsfocusManagerscheduleBuildFor_debugStateLockLevel_debugStateLockeddebugBuilding_debugBuilding_debugCurrentBuildTarget	lockState
buildScope>_debugElementsThatWillNeedToBeRebuiltDueToGlobalKeyShenanigansB_debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigans_debugElementWasRebuilt_globalKeyRegistry_debugIllFatedElements_debugGlobalKeyReservationsglobalKeyCount#_debugRemoveGlobalKeyReservationFor_registerGlobalKey_unregisterGlobalKey_debugReserveGlobalKeyFor _debugVerifyGlobalKeyReservation_debugVerifyIllFatedPopulationfinalizeTreeonNotificationattachNotificationTreecurrentparent_parent_notificationTreeslot_slotdepth_depth_sortdebugIsDefunctdebugIsActive_owner_parentBuildScope_debugIsDescendantOfrenderObjectrenderObjectAttachingChilddescribeElements_lifecycleStatevisitChildrendebugVisitOnstageChildrenupdateChildupdateChildrenmount _debugRemoveGlobalKeyReservationupdateupdateSlotForChild
updateSlot_updateDepth_updateBuildScopeRecursivelydetachRenderObjectattachRenderObject_retakeInactiveElementinflateWidget_debugCheckForCyclesdeactivateChild$_debugForgottenChildrenWithGlobalKeyforgetChild_activateWithParent_activateRecursivelydebugDeactivatedunmountdebugExpectsRenderObjectForSlot_inheritedElements_dependencies_hadUnsatisfiedDependencies)_debugCheckStateIsActiveForAncestorLookupdoesDependOnInheritedElement_updateInheritance!_debugCheckOwnerBuildTargetExistsdebugGetCreatorChaindebugGetDiagnosticChaintoDiagnosticsNodedebugDescribeChildrendirty_dirty_inDirtyList_debugBuiltOncemarkNeedsBuildrebuildperformRebuildstateful	toJsonMapbuilder_defaultErrorWidgetBuilder
_stringifymessage_flutterError_child_debugDoingBuild_firstBuildstate_state_didChangeDependenciesupdatednotifyClientsdebugParentDataType_applyParentDataapplyWidgetOutOfTurn_dependentsgetDependenciessetDependenciesupdateDependenciesnotifyDependentremoveDependent_renderObject_ancestorRenderObjectElement _findAncestorRenderObjectElement_debugCheckCompetingAncestors_findAncestorParentDataElements_debugUpdateRenderObjectOwner_performRebuild_updateParentDatainsertRenderObjectChildmoveRenderObjectChildremoveRenderObjectChildassignOwner	_children_forgottenChildren$_debugCheckHasAssociatedRenderObject._debugCheckMustNotAttachRenderObjectToAncestorelementindexinstance7
_DebugOnly
_debugOnly	ObjectKey	GlobalKeyLabeledGlobalKeyGlobalObjectKeyWidgetStatelessWidgetStatefulWidget_StateLifecycleStateSetterStateProxyWidgetParentDataWidgetInheritedWidgetRenderObjectWidgetLeafRenderObjectWidgetSingleChildRenderObjectWidgetMultiChildRenderObjectWidget_ElementLifecycle_InactiveElementsElementVisitorConditionalElementVisitorBuildContext
BuildScope
BuildOwnerNotifiableElementMixin_NotificationNode_isProfileBuildsEnabledForElement_ElementDiagnosticableTreeNodeErrorWidgetBuilderErrorWidgetWidgetBuilderIndexedWidgetBuilderNullableIndexedWidgetBuilderTransitionBuilderComponentElementStatelessElementStatefulElementProxyElementParentDataElementInheritedElementRenderObjectElementRootRenderObjectElementRootElementMixinLeafRenderObjectElementSingleChildRenderObjectElementMultiChildRenderObjectElementRenderTreeRootElementDebugCreator_reportExceptionIndexedSlot_NullElement_NullWidgetŸfactory	immutablemustCallSuperoptionalTypeArgs	protectedrequiredvisibleForTestingErrorDescription	ErrorHintErrorSummaryFlutterError
debugPrintdebugPrintStackDiagnosticLevelDiagnosticsNodeKeyLocalKeyValueKeyValueChangedValueGetterValueSetterVoidCallback	RenderBoxRenderObjectdebugDumpLayerTreedebugDumpRenderTreekey	identicalObjectoverrideboolruntimeTypevalueinthashidentityHashCodeStringdescribeIdentityobjectRuntimeType
deactivate	UniqueKeyGestureDetector	initState
debugLabelemptyWidgetsBindinginstance
buildOwner_globalKeyRegistrywidgetstateconstructor	shortHashendsWith	substringlengthcreateStateupdateDiagnosticableTreevoidDiagnosticPropertiesBuilderdebugFillPropertiesdefaultDiagnosticsTreeStyleDiagnosticsTreeStyledense
nonVirtualhashCoderebuildRowColumnPaddingSizedBoxAlignCustomSingleChildLayout	Container
DecorationCustomPaintThemesetState	canUpdate"dependOnInheritedWidgetOfExactTypeStreamChangeNotifierdisposedidChangeDependenciesIgnorePointerignoringKeyedSubtreeDiagnosticablecreateddebugMaybeDispatchCreated
reassembleBindingBasereassembleApplicationImage
ListenableAnimationControllermarkNeedsLayoutmarkNeedsPaintmarkNeedsBuilddefunct	fromPartsdynamicFutureactivaterunAppshrinkAppLifecycleListener	runWidgetreadydebugMaybeDispatchDisposedAnimatedWidgetaddEnumPropertydefaultValueObjectFlagPropertyifNull
parentDataStack
ParentData
PositionedSizeTypeIterableparentDataCreatorownershipChainchildapplyWidgetOutOfTurnColorof	ThemeDataBuilderInheritedNotifierInheritedModel#SlottedMultiChildRenderObjectWidgetmountcreateRenderObjectupdateRenderObjectRenderObjectWithChildMixinContainerRenderObjectMixinRenderBoxContainerDefaultsMixinRenderStackListSetHashSet_lifecycleStateinactive$debugPrintGlobalKeyedWidgetLifecyclevisitChildren_parentunmounttoListsort_sortclearreversedforEachisEmptyactivedebugDeactivatedcontainsremovevisitChildElementsvisitAncestorElementsbuildcontext
showDialogbuilderScaffoldStateshowBottomSheetScaffoldmounted	drawFrame
RenderViewaspectMaterialInkWellNotificationListenerNotificationdescribeElementserrorPropertydebugCheckHasMaterial
buildScopeLayoutBuilderpragma_inDirtyListcallkReleaseModeMap
kDebugMode"debugEnhanceBuildTimelineArgumentstoDiagnosticsNodetoTimelineArgumentsFlutterTimeline	startSync	argumentsestackinformationCollectorDiagnosticsDebugCreatordescribeElement
finishSync_debugIsDescendantOfdebugIsActiveDiagnosticsPropertystyleindexdebugBuildRootwhereelementdirty
isNotEmptyiassignOwnerOffstageFocusManagerregisterGlobalHandlers
FocusScopeFocusScopeNodenewowner_parentBuildScope debugPrintScheduleBuildForStackslabel_dirtyElements_dirtyElementsNeedsResorting_scheduleBuildFordebugPrintBuildScopecallback	_building_flushDirtyElementsHashMapputIfAbsentcontainsKeyparentrenderObjectattached
childToKeytoStringcurrentChildforgetChildkeys_unmountAlladdAllmapMapEntryentriescountjoin_notificationTreeonNotificationdispatchNotificationdebugProfileBuildsEnabled$debugProfileBuildsEnabledUserWidgetsdebugIsWidgetLocalCreationcreateElementinitialdepthTimer	AnimationViewrenderObjectAttachingChildexpectedAncestorTypeDiagnosticsBlocknamechildrenallowTruncateStringPropertyOverlayFindervisitChildrenForSemantics_debugStateLocked_debugConcreteSubtypeslot_debugElementWasRebuilt_debugReserveGlobalKeyForslotsforgottenChildrenfilledvaluesoldChildeveryinsertRenderObjectChildmoveRenderObjectChildremoveRenderObjectChild_registerGlobalKey#_debugRemoveGlobalKeyReservationFor
updateSlot_updateDepth_updateBuildScopeRecursivelydetachRenderObjectattachRenderObject_currentElementB_debugTrackElementThatWillNeedToBeRebuiltDueToGlobalKeyShenanigansdeactivateChild_inactiveElements_activateWithParentscheduleBuildFor
dependencyremoveDependent_unregisterGlobalKey
ViewAnchorviewViewCollection_debugBuildingErrorSpacerRenderSliverdescribeForErrorhasSizedebugNeedsLayoutsizePersistentHashMapupdateDependencies_inheritedElementsupdateShouldNotify_debugCurrentBuildTargettoStringShortshowNamelevelhiddenFlagPropertyifTruea	compareTobsparsedescriptiondescribeWidget
ColoredBoxcolorupdateChildrendidUpdateWidgetAnimatedBuilderforcedebugOnRebuildDirtyWidgetdebugPrintRebuildDirtyWidgetsDiagnosticableTreeNode DiagnosticsSerializationDelegate	toJsonMapdebugIsDefunctreportErrorFlutterErrorDetailsonErrorerrorRenderErrorBox	exceptionwithDetailsmessagequoted
whitespaceOverlayEntryValueWidgetBuilderListViewSliverChildBuilderDelegate
childCountListenableBuilder
WidgetsAppMaterialAppdebugWidgetBuilderValueperformRebuildupdateChild_debugTypesAreRight_element_widget_debugLifecycleStateinitialized_firstBuilddependOnInheritedElementstatefulUnsupportedError_updateParentDataapplyParentDatadebugCanApplyOutOfTurnAutomaticKeepAlive	KeepAliveputupdated!_debugCheckOwnerBuildTargetExists	dependent_dependenciesupdateSlotForChildPageStorageperformLayoutinvokeLayoutCallbackdebugDumpAppdebugExpectsRenderObjectForSlotancestordebugParentDataTypedebugTypicalAncestorWidgetClassdebugGetCreatorChain
stackTracedebugDisposeddebugCreatordidUnmountRenderObjectdebugIsValidRenderObject%_debugDescribeIncorrectParentDataType_slotparentDataElement
Deprecated_ownerdebugDescribeChildrendebugValidateChilddebugChildrenHaveDuplicateKeysContainerParentDataMixininsertaftermoveinflateWidgetPipelineOwnerrootNode _findAncestorRenderObjectElement
StackTraceInformationCollectorlibraryUnimplementedErrorLocalKeyKey	GlobalKeyDiagnosticableTreeWidgetDiagnosticableProxyWidgetRenderObjectWidgetElementBuildContextDiagnosticableTreeNodeLeafRenderObjectWidgetComponentElementProxyElementRenderObjectElementRootElementMixinì•AĞßô.§2Ó{Äzëå‚õƒfactory	immutablemustCallSuperoptionalTypeArgs	protectedrequiredvisibleForTesting ‚Èpackage:flutter/foundation.dartƒ¼„ErrorDescription	ErrorHintErrorSummaryFlutterError
debugPrintdebugPrintStack ƒpackage:flutter/foundation.dart„@„eDiagnosticLevelDiagnosticsNode „package:flutter/foundation.dart„„¬KeyLocalKeyValueKey „gpackage:flutter/foundation.dart„×…ValueChangedValueGetterValueSetterVoidCallback „®package:flutter/foundation.dart…>…ƒ	RenderBoxRenderObjectdebugDumpLayerTreedebugDumpRenderTree …package:flutter/rendering.dart 
  —   
dart:async  ¬   dart:collection  Ç   package:flutter/foundation.dart  ñ   package:flutter/rendering.dart  ‚   binding.dart  ‚2   
debug.dart  ‚G   focus_manager.dart  ‚d   inherited_model.dart  ‚ƒ   notification_listener.dart  ‚¨   widget_inspector.dartÀ&c À¢ğœÃ <€†€¤€¥€¿€Ã€ô$SŒ•–«ÅÆğ‚‚‚1‚F‚c‚‚‚§‚Ç‚È‚ñ‚úƒƒƒ5ƒOƒbƒtƒƒ¸„„g„®……:………†……¼…â††p†»‡‡8‡¨‡İˆ*ˆ´‰l‰‰¥‰õŠŠŠ0ŠFŠHŠIŠ™Šå‹9‹c‹g‹s‹ƒ‹»‹Á‹É‹õ‹ö‹ş‹ÿŒDŒHŒ–Œ°Œ´ŒÂŒÆŒñBOr½Üİ!89Eh”¨®îòóÿHIUk¼ÂLP í‘4‘8‘†‘Õ’$’u’ƒ’‡’Ó“"“n“–“š“ê””#”o”«”¯”¿”Ã••Q•U•¢•ñ–:–Š–Ú–í–ñ—>—‰——›—Ÿ—ğ—ı˜˜W˜¨˜¹˜¿™™!™o™p™œ™¢™ğšš4š5š•š–šØšŞ›/›F›}›~›¿›Åœœ,œdœeœ¶œ¼X‘Åó	
37„¬¾ŸŸ@ŸFŸzŸĞ   * + 7 M ’ ½ ò ø¡(¡,¡.¡/¡{¡¡Í¡ç¡ë¢-¢1¢‚¢Ä££a£v£z£†£±£Ò£Ø£à£ä¤.¤{¤†¤˜¤æ¥8¥s¥t¥¸¥Î¥Ï¥Û¥ş¦*¦>¦D¦¦‘¦’¦¦Í¦Î¦Ú¦ğ§2§˜§õ¨¨G¨l¨µ¨»¨ğ¨ô¨ö¨÷©)©-©|©Èªªª`ª«ªå«3«S«W«¨«ø¬C¬‘¬¥¬©¬÷­B­‘­á®/®€®Š®®œ® ®ì¯¯b¯ˆ¯Õ°°°F°n°Š°‹°Î°Ô±±l±¾²²a²m²s²Ã³³b³­³ş´´%´v´´“´£´©´Ü´î´ïµ)µ/µ‚µÔ¶!¶q¶‡¶”¶Ÿ¶º¶»¶î¶ú··P·~·‚·ƒ··Ô·ÿ¸H¸L¸M¸Y¸g¸›¸œ¸¨¸¶¸Ü¸İ¹-¹]¹c¹´ººHºNºŸºíºş»<»™»»»è¼=¼‘¼ê½½B½N½r½~½‹½½‘½’½Ä½È¾¾g¾±¾ù¿J¿N¿‘¿•¿áÀ @)À @yÀ @ÄÀ AÀ A7À A;À A]À AaÀ A°À AüÀ BLÀ B|À B€À BÑÀ C"À ClÀ C‡À C‹À CÒÀ CõÀ CùÀ DJÀ DšÀ DéÀ E:À E‰À EÕÀ FÀ FÀ FaÀ FŸÀ F£À FóÀ GCÀ G”À G«À G¯À GúÀ HDÀ H”À HåÀ I3À I„À IÓÀ IéÀ J4À JÀ JĞÀ K!À KnÀ KºÀ LÀ LHÀ L[À L_À L°À LçÀ LëÀ M.À M2À MFÀ MJÀ MÀ M¡À MòÀ NÀ NÀ NÀ NKÀ NqÀ NuÀ N…À N°À NêÀ NòÀ NøÀ O À OÀ OÀ O(À O,À OzÀ O“À O—À O£À OÌÀ OßÀ OòÀ P À P4À P>À PBÀ P[À PvÀ PzÀ PŠÀ PµÀ PìÀ PôÀ PúÀ QÀ QÀ QÀ Q_À Q®À QÑÀ QÕÀ QãÀ QçÀ R3À R]À R©À RÏÀ RÿÀ S'À SMÀ SNÀ SŸÀ S¥À SâÀ SîÀ T,À T-À TxÀ T~À TÏÀ UÀ UjÀ U½À UåÀ UëÀ V6À VƒÀ VÔÀ WÀ WYÀ W_À W¯À WıÀ X"À X(À XvÀ X¿À YÀ YUÀ Y À YãÀ YéÀ Z&À Z,À ZzÀ Z†À ZÂÀ ZıÀ [À [KÀ [kÀ [qÀ [À [‡À [àÀ [íÀ \À \À \À \;À \?À \À \ÚÀ ]%À ]lÀ ]pÀ ]¿À ^À ^XÀ ^ À ^ñÀ ^õÀ _AÀ _‡À _ØÀ `&À `iÀ `€À `„À `ÇÀ `ËÀ aÀ a`À a®À aÿÀ b3À b7À btÀ b½À cÀ cVÀ c§À c÷À dÀ d!À dkÀ d¹À eÀ eNÀ ešÀ eéÀ f7À f†À fÖÀ g'À guÀ gÅÀ hÀ hÀ h7À h;À hvÀ hzÀ hËÀ iÀ ijÀ iºÀ j
À jVÀ j§À jÃÀ jÇÀ kÀ k\À k­À köÀ lGÀ lbÀ lfÀ l­À lÏÀ lÓÀ m À mgÀ m·À måÀ méÀ n:À nˆÀ nÏÀ oÀ oQÀ oUÀ o À oêÀ p<À pÀ pÜÀ q1À qYÀ q]À q©À qÉÀ qÍÀ rÀ rnÀ r½À s
À sVÀ s£À sîÀ t<À taÀ teÀ t°À tüÀ u@À uÀ u½À uÁÀ v	À vÀ v^À v•À v™À vÜÀ vàÀ w"À wKÀ wOÀ wcÀ wgÀ w±À wµÀ wıÀ xHÀ x”À x˜À x¤À xÒÀ xùÀ xıÀ yÀ yJÀ yPÀ yTÀ y‹À y›À yÆÀ z À zÀ zÀ zÀ z&À z:À z>À z‰À zÕÀ zõÀ zùÀ {À {-À {@À {SÀ {À {•À {ŸÀ {£À {¼À {×À {ÛÀ {ëÀ |À |"À |&À |QÀ |kÀ |oÀ |ƒÀ |«À |³À |·À |ÇÀ |òÀ }À }+À }lÀ }‹À }–À }À }¤À }¬À }¼À }ÀÀ ~	À ~XÀ ~{À ~À ~À ~‘À ~ÖÀ #À VÀ ¢À ÈÀ ÷À €À €DÀ €EÀ €•À €›À €ØÀ €äÀ  À !À rÀ xÀ ¿À ôÀ úÀ ‚À ‚À ‚UÀ ‚_À ‚eÀ ‚²À ƒÀ ƒRÀ ƒ¡À ƒñÀ „<À „SÀ „`À „kÀ „‚À „„À „…À „ËÀ „âÀ …1À …=À …HÀ …IÀ …–À …êÀ …ùÀ …úÀ †JÀ †XÀ †aÀ †bÀ †­À †ÌÀ †×À †ÙÀ †ÚÀ ‡À ‡AÀ ‡BÀ ‡{À ‡À ‡ÎÀ ˆÀ ˆeÀ ˆ¬À ˆ°À ˆğÀ ‰=À ‰‹À ‰ÚÀ Š$À ŠkÀ Š»À ‹À ‹UÀ ‹YÀ ‹‹À ‹À ‹ÈÀ ‹íÀ Œ:À Œ‰À Œ×À $À AÀ À ÙÀ 'À pÀ À ĞÀ À oÀ ½À À ^À £À òÀ ‘9À ‘…À ‘ÎÀ ‘ŞÀ ’+À ’tÀ ’ÁÀ “À “cÀ “³À ” À ”MÀ ”šÀ ”ÃÀ •À •ZÀ • À •êÀ –7À –†À –×À —$À —qÀ —ªÀ —÷À ˜CÀ ˜À ˜İÀ ™.À ™wÀ ™ÁÀ ™ĞÀ š!À šqÀ š¿À ›
À ›.À ›{À ›ÈÀ œÀ œ]À œaÀ œoÀ œsÀ œÄÀ  À MÀ €À ÌÀ òÀ *À <À À ¢À ¨À õÀ ŸBÀ ŸÀ Ÿ×À  (À  wÀ  ŠÀ  ¦À  ´À  µÀ  õÀ  ûÀ ¡HÀ ¡—À ¡ÙÀ ¡ÚÀ ¢%À ¢QÀ ¢‹À ¢ŒÀ ¢ÅÀ ¢ËÀ £À £_À £®À £ÿÀ ¤À ¤À ¤eÀ ¤À ¤¬À ¤¼À ¤ÚÀ ¤öÀ ¥nÀ ¥øÀ ¦À ¦À ¦À ¦(À ¦>À ¦BÀ ¦CÀ ¦`À ¦aÀ ¦›À ¦¡À ¦ëÀ §0À §}À §ÎÀ §íÀ §óÀ ¨5À ¨]À ¨^À ¨—À ¨À ¨ìÀ ¨şÀ ©À ©MÀ ©À ©åÀ ©ëÀ ªÀ ªfÀ ª®À ªûÀ «?À «gÀ «mÀ «ŸÀ «ëÀ ¬0À ¬OÀ ¬ƒÀ ¬‰À ¬À ¬¤À ¬ùÀ ­CÀ ­šÀ ­¯À ­µÀ ®À ®-À ®:À ®KÀ ®`À ®À ®ŞÀ ®âÀ ®ãÀ ¯À ¯!À ¯qÀ ¯¶À °À °LÀ °{À °À °ÑÀ °íÀ °óÀ ±CÀ ±‹À ±‘À ±ÀÀ ±ÆÀ ²À ²MÀ ²SÀ ²¤À ²½À ²ÎÀ ²ÛÀ ³À ³À ³?À ³EÀ ³À ³ØÀ ´'À ´-À ´=À ´CÀ ´aÀ ´À ´ÂÀ ´ÏÀ ´àÀ ´÷À ´øÀ µGÀ µMÀ µ˜À µĞÀ µÖÀ µäÀ ¶À ¶À ¶!À ¶nÀ ¶½À ¶òÀ ¶øÀ ·HÀ ·—À ·èÀ ·öÀ ·üÀ ¸HÀ ¸•À ¸ÒÀ ¸ØÀ ¹%À ¹sÀ ¹ÃÀ ºÀ ºEÀ ºKÀ ºYÀ ºˆÀ ºÀ º´À ºÀÀ »&À »UÀ »œÀ »¤À »®À »´À ¼ À ¼QÀ ¼œÀ ¼ºÀ ¼ÀÀ ½À ½IÀ ½OÀ ½]À ½tÀ ½«À ½³À ½¿À ½åÀ ½ïÀ ½õÀ ¾CÀ ¾À ¾ŞÀ ¿,À ¿|À ¿’À ¿˜À ¿³À ¿¹À À
À ÀAÀ ÀoÀ ÀuÀ ÀÅÀ ÁÀ ÁfÀ Á¡À Á§À ÁèÀ ÁîÀ Â;À ÂŠÀ ÂÛÀ Ã-À Ã`À ÃfÀ ÃµÀ ÄÀ ÄÀ Ä/À Ä5À Ä…À ÄÔÀ Å%À ÅuÀ ÅÅÀ ÅçÀ ÅíÀ Æ=À ÆÀ ÆÜÀ ÇÀ ÇÀ ÇjÀ Ç»À ÇÏÀ ÇÕÀ ÇåÀ ÇëÀ È7À ÈsÀ È€À È£À È³À ÈğÀ É(À ÉlÀ ÉˆÀ ÉåÀ Ê>À Ê•À ÊÖÀ ÊãÀ ÊøÀ Ë!À ËxÀ ËÍÀ Ì"À Ì7À ÌDÀ ÌYÀ Ì®À ÍÀ ÍQÀ Í¡À Í®À ÍºÀ ÍÂÀ ÎÀ ÎCÀ Î†À Î›À ÎôÀ ÏNÀ Ï«À ÏØÀ ÏåÀ ÏñÀ ÏùÀ ĞÀ ĞÀ ĞBÀ ĞRÀ ĞpÀ Ğ¨À ĞóÀ ÑÀ ÑfÀ Ñ§À Ñ´À ÑÉÀ Ò#À ÒÀ Ò¼À ÒÉÀ ÒÕÀ ÒİÀ Ó-À ÓOÀ ÓbÀ ÓlÀ ÓŒÀ ÓÀ Ó‘À ÓÉÀ ÓÏÀ ÔÀ ÔiÀ ÔºÀ Õ
À ÕTÀ Õ¤À ÕóÀ ÖBÀ Ö’À ÖàÀ ×0À ×^À ×dÀ ×¯À ×şÀ Ø?À ØEÀ Ø’À Ø¼À ØÂÀ ØÒÀ ØØÀ Ù(À ÙLÀ ÙYÀ ÙjÀ ÙÀ Ù‚À ÙÎÀ ÙîÀ ÙôÀ ÚBÀ ÚÀ ÚÄÀ ÚÊÀ ÛÀ ÛfÀ Û³À Ü À ÜPÀ ÜÀ ÜåÀ İ1À İÀ İÉÀ ŞÀ Ş À ŞnÀ Ş»À ŞÑÀ Ş×À ß&À ßNÀ ßTÀ ßdÀ ßjÀ ß°À ßúÀ àÀ àÀ à-À à.À àrÀ àxÀ àÂÀ áÀ á_À á°À áúÀ â À âOÀ âˆÀ âÀ â½À âÃÀ ãÀ ã7À ã=À ãNÀ ãTÀ ã¢À ãêÀ ä À äÀ ä%À ä+À äwÀ äÄÀ åÀ åRÀ åXÀ å£À åŞÀ åäÀ æ0À æpÀ ævÀ æÄÀ æóÀ æùÀ ç)À ç/À ç}À ç½À çÃÀ çÓÀ çÙÀ èÀ è!À è2À èEÀ è€À èÀ èÆÀ èÙÀ èãÀ éÀ éÀ éÀ éaÀ égÀ é¶À éÅÀ éËÀ éïÀ êÀ êHÀ êÀ êÕÀ ë&À ëMÀ ëSÀ ë¢À ëÓÀ ëÙÀ ì$À ìqÀ ìÂÀ íÀ íGÀ íMÀ íÀ íìÀ î7À î=À î‹À îÔÀ ï#À ïqÀ ï½À ğÀ ğKÀ ğQÀ ğlÀ ğrÀ ğ¼À ğÂÀ ñÀ ñ^À ñ«À ñÃÀ ñÉÀ òÀ òeÀ òµÀ óÀ óQÀ ó‹À ó‘À óâÀ ô,À ô|À ô‚À ôÒÀ õ À õbÀ õ±À öÀ öÀ ö!À ö/À öYÀ öˆÀ ö¼À öÂÀ öİÀ öãÀ öõÀ ÷/À ÷OÀ ÷„À ÷‘À ÷›À ÷£À ÷­À ÷³À øÀ øOÀ øŸÀ øìÀ ù9À ù†À ù™À ùŸÀ ùìÀ ú<À úWÀ ú]À úkÀ ú™À úØÀ úŞÀ úùÀ ûÀ ûÀ ûÀ ûJÀ ûYÀ ûkÀ û˜À û¸À ûöÀ üÀ üÀ üÀ üÀ ü%À üvÀ üÆÀ ıÀ ı`À ıÀ ı‡À ı—À ıÀ ıõÀ şÀ ş(À ş)À şhÀ şnÀ ş¯À şùÀ ÿ.À ÿ4À ÿ‚À ÿÑÀ ÿ×À !À mÀ ºÀÀ+À8ÀIÀkÀlÀxÀ½ÀèÀøÀÀ5ÀRÀrÀ¡À¬ÀµÀÈÀÒÀ&À:À’À™ÀÀÀñÀEÀGÀHÀ—À£À§ÀóÀÀÀÀ!ÀmÀ“ÀÌÀÀBÀÀ¸ÀÀ8ÀpÀœÀÖÀÀÀ>ÀDÀxÀÊÀ	À	fÀ	{À	‘À	“À	”À	áÀ	üÀ
 À
<À
ŠÀ
ÊÀ
ÎÀÀPÀTÀhÀlÀ»À ÀÀÀQÀhÀ{À—ÀµÀ¿ÀÃÀÚÀŞÀîÀ&À‚À©ÀËÀÀIÀSÀ[À_ÀoÀªÀ°À¸ÀÈÀÌÀÚÀŞÀÀbÀ©ÀìÀÀgÀ³ÀİÀ)ÀzÀÂÀÿÀ ÀÀRÀSÀ™À¯ÀµÀûÀKÀwÀ}ÀÉÀ÷À4ÀNÀkÀ”À˜À™ÀçÀ À&ÀtÀ ÀÏÀÕÀîÀôÀCÀnÀºÀüÀÀÀ"À_ÀiÀoÀ¿ÀÀ]À‰ÀŠÀØÀÀÀeÀŠÀÀáÀ%ÀÀ€ÀÄÀéÀÀ9À@ÀZÀwÀxÀ—ÀôÀÀ0ÀÀšÀ´À*À5ÀFÀ­À#À,ÀQÀdÀÒÀİÀÿÀÀ’ÀÀ¤À¨À©ÀûÀ À FÀ „À ÔÀ!#À!HÀ!NÀ!À!èÀ"9À"ŠÀ"ÙÀ"ßÀ#+À#dÀ#±À#ÏÀ#ÜÀ$À$À$]À$uÀ${À$ÇÀ%À%À%(À%.À%~À%À%šÀ%ÄÀ%ÆÀ%ÇÀ&À&À&_À&cÀ&´À' À'À'SÀ'À'“À'ÖÀ'ÚÀ'îÀ'òÀ(=À(AÀ(MÀ({À(“À(¦À(ÃÀ(áÀ(ëÀ(ïÀ)À)À)DÀ)ŒÀ)”À)˜À)ÊÀ)şÀ*?À*WÀ*_À*cÀ*sÀ*ÃÀ*ÉÀ*ÑÀ*áÀ*åÀ+À+À+lÀ+À+İÀ,&À,*À,{À,ÊÀ-À-]À-aÀ-°À. À./À.3À.À.ÒÀ/"À/lÀ/±À/üÀ0À0À0HÀ0LÀ0À0ìÀ0ıÀ1À1À1À1iÀ1ŸÀ1£À1¯À1ÚÀ2À2&À2*À2:À2eÀ2~À2™À2ºÀ2ÖÀ3À3(À3HÀ3•À3¨À3¹À3ÈÀ3ÕÀ3àÀ3èÀ3îÀ3öÀ4À4
À4À4"À4lÀ4¼À4ïÀ4óÀ4ÿÀ5*À5.À5^À5„À5ˆÀ5˜À5ÃÀ5ÜÀ5÷À6À61À6MÀ6‘À6 À6­À6¸À6ÀÀ6ÆÀ6ÎÀ7À7!À7/À73À7~À7§À7óÀ8%À8\À8 À8îÀ9À9SÀ9|À9±À:À:JÀ:†À:‡À:“À:ÑÀ:ÒÀ;#À;)À;zÀ;ËÀ<À<cÀ<vÀ<|À<ÌÀ=À=hÀ=vÀ=ƒÀ=ÃÀ=ÅÀ=ÆÀ>À>`À>qÀ>uÀ>ÀÀ>äÀ>èÀ?(À?uÀ?ÄÀ@À@8À@<À@‰À@¼ÀAÀAUÀA~ÀAÀAÍÀAÙÀAäÀBÀBÀBLÀBÀB¹ÀB¿ÀCÀCRÀCœÀCÌÀCúÀDÀDÀDKÀDLÀD™ÀDèÀEÀEÀEaÀE«ÀEöÀF&ÀFUÀFbÀFºÀF»ÀFÿÀGBÀG“ÀGÄÀGÑÀHÀHÀHÀHnÀH‰ÀHÀHÚÀIÀInÀI¶ÀIãÀIäÀIğÀJ<ÀJ>ÀJ?ÀJ“ÀJ¶ÀJºÀJûÀKIÀKšÀKÑÀKÕÀL"ÀLlÀL½ÀMÀMEÀMFÀMvÀM|ÀM­ÀMÄÀMÅÀMÑÀN+ÀN-ÀN.ÀN‚ÀNÎÀOÀO$ÀO(ÀO_ÀO¯ÀOøÀPCÀP‡ÀP®ÀP²ÀPÿÀQÀQÀQÀQPÀQÀQ¬ÀQíÀR>ÀRbÀR«ÀRÔÀS)ÀS*ÀS[ÀSaÀS±ÀSöÀTDÀTSÀTYÀT£ÀTôÀUEÀUŒÀU’ÀU ÀUÁÀUùÀV,ÀV2ÀVOÀVgÀV—ÀV¥ÀV¯ÀVµÀVÇÀVôÀW7ÀWbÀWlÀWtÀW~ÀW„ÀWÃÀWÉÀW×ÀXÀXBÀXHÀXeÀX}ÀXÇÀYÀY@ÀYNÀYXÀY^ÀYpÀYÀYéÀZÀZ'ÀZ/ÀZ9ÀZXÀZYÀZeÀZ½ÀZ¿ÀZÀÀZÌÀZÍÀ[À[À[&À[>À[sÀ[tÀ[—À[ÚÀ[êÀ\À\KÀ\•À\ŸÀ\§À\ºÀ\ÄÀ\ğÀ]À]/À]7À]NÀ]À]”À]•À]¬À]ÀÀ^À^#À^-À^XÀ^hÀ^‰À^ À^¦À^ªÀ^«À^ãÀ_$À_>À_À_´À_ÄÀ_æÀ_ùÀ`À`À`À`&À`<À`fÀ`‹À`ÊÀ`ñÀ`÷ÀaÀaÀaÀa9ÀaOÀaxÀaÀa¼ÀaıÀbÀbÀb*Àb@ÀbPÀb|ÀbÀb™Àb¬Àb°Àb²Àb³ÀbøÀbüÀc)Àc-ÀctÀc‡ÀcÀÀcÁÀd	ÀdÀd=ÀdAÀddÀd¨Àd©ÀdæÀdêÀe)ÀerÀevÀeÂÀfÀf`Àf±ÀfåÀféÀg5ÀgƒÀgÎÀgÒÀh!ÀhpÀh¿ÀiÀi`Ài°ÀişÀjMÀj™ÀjãÀkÀkÀkiÀk´ÀkıÀlMÀl–ÀlšÀl¦Àl´ÀlİÀmÀm%ÀmXÀmoÀm›ÀmºÀmåÀnÀn9ÀndÀnŠÀn½ÀnàÀoÀo0ÀoWÀo‘Ào¿ÀoöÀp"ÀphÀp–ÀpÎÀpïÀqÀq*ÀqEÀq^ÀquÀqŠÀqÀq®Àq½ÀqÊÀqÔÀqİÀqãÀqëÀqïÀr?ÀrÀrÛÀrüÀs ÀsCÀsGÀs–ÀsäÀt"ÀttÀtÅÀu ÀuÀuÀu ÀuKÀujÀuŠÀuÎÀuñÀvÀv*Àv7ÀvcÀvnÀvvÀv~Àv‘Àv•ÀvãÀw1ÀwOÀwÀw²Àw³ÀwıÀx5ÀxNÀxOÀx—Àx¹Àx¿ÀyÀy\ÀypÀyvÀyÄÀyÊÀzÀzÀzÀzhÀznÀz¹ÀzíÀ{>À{`À{°À{ÊÀ{ĞÀ|!À|bÀ|À|”À|ÌÀ|èÀ|éÀ}-À}{À}ÈÀ}äÀ}êÀ~5À~À~ÆÀÀBÀHÀ˜ÀèÀ€7À€~À€À€–À€âÀÀ
ÀWÀ£ÀóÀ‚À‚=À‚>À‚€À‚†À‚ÒÀƒÀƒgÀƒÀƒ–ÀƒâÀ„À„
À„[À„«À„øÀ…EÀ…KÀ…˜À…äÀ†4À†ZÀ†lÀ†mÀ†¯À†ğÀ†öÀ‡À‡À‡gÀ‡¹À‡ìÀ‡òÀˆFÀˆtÀˆÍÀˆÎÀ‰À‰VÀ‰\À‰¦À‰öÀŠCÀŠ’ÀŠÓÀŠÙÀ‹+À‹vÀ‹ˆÀ‹À‹ÖÀŒ"ÀŒoÀŒ¿ÀÀ]ÀwÀ}ÀÍÀÀmÀºÀîÀôÀBÀÀÃÀÉÀÀEÀKÀ›ÀçÀ‘8À‘ƒÀ‘¨À‘®À‘çÀ’.À’rÀ’˜À’­À“À“À“TÀ“ˆÀ“À“ŞÀ”+À”|À”¸À”¾À•À•]À•®À•ûÀ–/À–5À–ƒÀ–ĞÀ—À—
À—JÀ—‹À—ŒÀ—áÀ˜(À˜.À˜^À˜dÀ˜»À˜ûÀ™À™PÀ™†À™ŒÀ™ÜÀš+ÀšeÀš¸À›À›3À›HÀ›¢À›£À›öÀœ"Àœ(ÀœuÀœÂÀÀ]À­ÀúÀGÀ˜ÀèÀŸ4ÀŸ:ÀŸ†ÀŸÑÀ 
À À bÀ ®À üÀ¡OÀ¡UÀ¡¡À¡ÂÀ¡×À¢À¢À¢aÀ¢’À¢˜À¢ßÀ£0À£À£ÕÀ¤(À¤tÀ¤ÀÀ¤äÀ¤êÀ¥7À¥†À¥×À¦	À¦À¦[À¦¦À¦ßÀ¦åÀ§7À§ƒÀ§ÑÀ¨À¨3À¨9À¨OÀ¨UÀ¨cÀ¨»À¨ÅÀ¨×À©À©	À©[À©ŒÀ©’À©İÀª5ÀªÀª¨Àª®À«À«À«(À«]À«^À«ºÀ«ëÀ«ñÀ¬?À¬À¬áÀ­5À­„À­ÔÀ®!À®XÀ®^À®ªÀ®õÀ¯.À¯4À¯†À¯ÒÀ° À°tÀ°‰À°ÈÀ°ÉÀ±À±QÀ±WÀ±œÀ±ëÀ²:À²À²…À²ºÀ²ÀÀ³À³À³kÀ³¸À´À´QÀ´fÀ´§À´¨À´ÑÀ´×ÀµÀµdÀµ´À¶À¶2À¶8À¶†À¶ÒÀ¶àÀ¶æÀ·1À·}À·ƒÀ·ÔÀ¸À¸oÀ¸ÀÀ¸ÙÀ¸îÀ¹!À¹"À¹eÀ¹kÀ¹ºÀºÀºÀºSÀºTÀº¬Àº²À» À»À»À»À»sÀ»–À»©À»îÀ»ôÀ»õÀ¼LÀ¼RÀ¼ŸÀ¼ÁÀ¼ÔÀ½À½À½ À½oÀ½”À½šÀ½éÀ¾@À¾AÀ¾‹À¾¦À¾¬À¾øÀ¿/À¿1À¿2À¿€À¿„À¿ÓÀÀ ÀÀKÀÀOÀÀÀÀñÀÁCÀÁ“ÀÁÁÀÁÚÀÂ$ÀÂJÀÂKÀÂuÀÂ•ÀÂäÀÂşÀÂÿÀÃLÀÃ‡ÀÃÀÃÛÀÄ+ÀÄ~ÀÄĞÀÄ÷ÀÅÀÅÀÅjÀÅšÀÅ ÀÅïÀÅõÀÆBÀÆdÀÆŠÀÆ¾ÀÆ¿ÀÆŞÀÆüÀÇÀÇHÀÇyÀÇšÀÇ½ÀÇàÀÇæÀÈÀÈ.ÀÈMÀÈSÀÈƒÀÈ®ÀÈ´ÀÈ¸ÀÈ¹ÀÈØÀÈöÀÉÀÉCÀÉiÀÉ‹ÀÉ¼ÀÊÀÊ9ÀÊlÀÊ~ÀÊ¾ÀËÀË%ÀË:ÀËFÀË«ÀË±ÀË»ÀËÔÀËíÀÌÀÌBÀÌMÀÌ\ÀÌ“ÀÌİÀÍ-ÀÍ8ÀÍAÀÍGÀÍdÀÍˆÀÍÀÍ’ÀÍ“ÀÍàÀÎCÀÎXÀÎkÀÎqÀÎ¥ÀÎòÀÏ
ÀÏgÀÏ¹ÀÏÂÀÏÓÀĞ2ÀĞ‘ÀĞîÀÑ:ÀÑCÀÑgÀÑ’ÀÑªÀÑİÀÑæÀÒ
ÀÒyÀÒŠÀÒ½ÀÒÆÀÒÎÀÒÒÀÒÓÀÓ ÀÓ@ÀÓŸÀÓÇÀÓñÀÓûÀÔ^ÀÔ•ÀÔÈÀÕÀÕ/ÀÕ9ÀÕAÀÕSÀÕšÀÕ¹ÀÖÀÖ!ÀÖJÀÖ„ÀÖÈÀÖßÀ×CÀ×RÀ×|À×½À×ÛÀØÀØ#ÀØIÀØœÀØºÀØÉÀØ×ÀØáÀØöÀÙÀÙÀÙHÀÙ{ÀÙ£ÀÙ­ÀÙµÀÙÓÀÙşÀÚÀÚ#ÀÚ'ÀÚ(ÀÚGÀÚeÀÚ…ÀÚ°ÀÚÚÀÚòÀÚøÀÛÀÛ0ÀÛZÀÛ•ÀÛòÀÜEÀÜ¢ÀÜÿÀİYÀİ¯ÀİäÀİöÀİüÀŞÀŞ<ÀŞoÀŞÆÀŞÎÀŞáÀŞëÀŞıÀßÀßÀßÀß1Àß5Àß‚ÀßÓÀà ÀàFÀàJÀà–ÀàÖÀà÷ÀàûÀáGÀáKÀázÀá¿ÀáĞÀáÔÀáèÀâ6Àâ€ÀâÄÀâÈÀãÀã$Àã7ÀãeÀãkÀã·ÀäÀäMÀä›Àä·ÀäùÀåJÀåKÀå–Àå£ÀåÅÀåÆÀæ	Àæ
Àæ7Àæ8ÀæfÀælÀæºÀæñÀæ÷Àç"Àç(ÀçrÀçÁÀèÀèaÀètÀè‘Àè’ÀèŞÀéÀéCÀéfÀé•Àé¥ÀéÓÀéìÀéıÀê‡Àê’ÀêšÀê¶ÀêîÀëMÀë£Àë¿Àì"ÀìMÀìZÀìoÀìÍÀíÀílÀíyÀí…ÀíÀí ÀíªÀíàÀíğÀî6ÀîOÀî`Àî—Àï Àï]ÀïhÀïpÀï¥ÀïİÀğ.ÀğCÀğÀğÂÀğÏÀñÀñÀñÀñ2Àñ<ÀñÀñ¬ÀñÇÀñÍÀñøÀòÀò6ÀòÀò˜Àò«ÀòµÀò¹ÀòºÀòÚÀóÀóÀóKÀóQÀó|Àó¨ÀóÇÀóìÀóíÀô=Àô_ÀôeÀôµÀôÖÀõ Àõ'Àõ7ÀõXÀõkÀõuÀõÀõ‘Àõ¡Àõ³ÀõÖÀõëÀõ÷ÀõıÀö$Àö(Àö)ÀöuÀöÁÀö÷ÀöıÀ÷KÀ÷‹À÷‘À÷ŞÀø*ÀøzÀø¼ÀøæÀøìÀù:Àù‰ÀùºÀùÀÀùõÀùûÀú5Àú;Àú‚ÀúÏÀûÀû*ÀûWÀû–ÀûÌÀüÀüÀü!ÀüHÀüeÀüuÀü—Àü«ÀüáÀı,Àı7Àı?Àı`Àı}ÀıÀıšÀı³ÀıæÀıøÀş*Àş_Àş­ÀşóÀÿ&ÀÿOÀÿ\ÀÿfÀÿ{Àÿ‡ÀÿÔÀÿÚÀÿäÀ À 2À PÀ sÀ À ²À ñÀÀ6ÀDÀRÀhÀ|À’ÀËÀÀ:ÀSÀcÀmÀuÀ´ÀÄÀèÀÀ/ÀUÀ]À{ÀÀ­ÀĞÀôÀ!À+À@ÀLÀRÀyÀ}À~ÀŞÀßÀ*À<ÀOÀUÀ‚ÀÍÀıÀPÀcÀgÀhÀ—ÀéÀíÀîÀ;À<À”ÀÎÀÜÀ3À4ÀƒÀ¥ÀõÀ	À	À	oÀ	©À	·À
À
<À
JÀ
KÀ
˜À
ÓÀ
ÀÀWÀgÀ¢ÀµÀ¿ÀÃÀÄÀ ÀÀAÀ~ÀËÀüÀÀÀ!ÀHÀLÀMÀ‹À›ÀòÀ/À|À„À—À¡ÀÏÀõÀûÀÿÀ ÀQÀaÀ¨ÀâÀõÀÿÀÀÀ0À@ÀŠÀìÀ(ÀkÀ¡À³À½ÀùÀEÀ“À¦ÀÍÀáÀíÀ9À…ÀÆÀõÀBÀÀ×ÀÀ6À\À”ÀÔÀÀAÀ¥ÀÄÀãÀFÀYÀkÀ€ÀÀÀÀ-ÀÀàÀ ÀcÀvÀˆÀ–ÀãÀ1ÀÀ¥ÀÏÀ
À7ÀcÀuÀ‡À•À¿ÀúÀ'ÀSÀeÀwÀ…ÀÀ±ÀØÀäÀğÀúÀ&À9ÀCÀGÀHÀrÀ‚À²ÀÀIÀwÀ¹ÀğÀ&ÀiÀÁÀâÀ À À &À MÀ mÀ ´À!À!?À!yÀ!ÈÀ"À"gÀ"¸À"ñÀ#À#2À#wÀ#À#À#«À#µÀ#ÎÀ#êÀ$GÀ$TÀ$_À$’À$šÀ$­À$·À$»À$¼À%	À%À%$À%XÀ%^À%¯À%ÌÀ%ùÀ&À&*À&\À&bÀ&lÀ&¿À&ÑÀ&ßÀ'À'9À'À'ÜÀ(À(^À(¨À(ÅÀ)"À)5À)EÀ)SÀ)vÀ)ÄÀ*"À*YÀ*¡À*ºÀ*åÀ*÷À+À+>À+À+½À+ßÀ+÷À,À,lÀ,}À,®À-À-XÀ-™À-ÒÀ-åÀ.$À.tÀ.À.ÀÀ.ÒÀ.âÀ/À/uÀ/¨À/ÊÀ/æÀ/ıÀ0cÀ0tÀ0 À0áÀ1À1bÀ1©À2À2IÀ2À2áÀ3.À3À3ÌÀ48À4vÀ4ÆÀ5À5?À5aÀ5ÕÀ6HÀ6£À6ÕÀ7JÀ7ĞÀ8HÀ8¸À9+À9dÀ9˜À9ıÀ:À:"À:0À:<À:PÀ:£À:­À:ÂÀ:ÎÀ:çÀ;5À;€À; À;ôÀ<À<À<EÀ<MÀ<SÀ<WÀ<XÀ<¤À<óÀ=DÀ=cÀ=iÀ=µÀ=×À=ğÀ>3À>9À>CÀ>gÀ>‰À>¢À>²À>ÍÀ>óÀ>ûÀ?À?À?À?À?UÀ?iÀ?mÀ?{À?ÍÀ?÷À@@À@\À@bÀ@©À@ùÀA+ÀA,ÀA8ÀAZÀA§ÀA«ÀA­ÀA®ÀAÈÀAøÀAùÀBÀB9ÀB:ÀBsÀB¬ÀBºÀBÀÀBğÀBôÀBöÀB÷ÀC(ÀCNÀC¢ÀC¤ÀC¥ÀCîÀCòÀDBÀD“ÀDäÀE/ÀEÀE–ÀEšÀEèÀF4ÀF8ÀFcÀFgÀF¸ÀG ÀGPÀG ÀGçÀH4ÀHÀHÀHÛÀI*ÀIyÀIÊÀJÀJhÀJ¦ÀJóÀKCÀK“ÀKàÀL1ÀL^ÀL­ÀLöÀMAÀM‡ÀMØÀN%ÀNrÀNÀÀOÀO5ÀOƒÀOĞÀOàÀP*ÀP[ÀP§ÀPñÀP÷ÀQ8ÀQfÀQ©ÀQ­ÀQ®ÀQÂÀQêÀQëÀRÀRÀRcÀR®ÀRçÀRíÀS<ÀSŠÀSØÀT'ÀT-ÀTzÀTÉÀUÀU_ÀUeÀU¯ÀUñÀUÿÀVÀVWÀV“ÀV”ÀVäÀVöÀVüÀWMÀWÀWµÀWÒÀWãÀWäÀX1ÀX}ÀXÀXŸÀXÙÀY/ÀY7ÀYJÀYTÀYgÀYkÀYlÀYÀY€ÀYÑÀYçÀZÀZ:ÀZqÀZ†ÀZ™ÀZŸÀZîÀ[À[2À[QÀ[qÀ[wÀ[ªÀ[¸À[¼À[½À\À\]À\²À]	À]?À]eÀ]qÀ]—À]£À]°À]´À]µÀ]ßÀ]åÀ^/À^{À^ËÀ_À_gÀ_À_©À_ÊÀ_İÀ_ŞÀ_êÀ`À`À`@À`FÀ`ŒÀ`ÜÀ`øÀaÀa$ÀadÀawÀaÀa—Àa›ÀaœÀaÉÀaÏÀbÀbeÀb€Àb›Àb«ÀbéÀbüÀcÀcÀcÀc Àc]ÀciÀcŒÀc¢Àc£ÀcæÀd3ÀdSÀdYÀd­Àd³ÀeÀeRÀe˜ÀeèÀf9ÀfˆÀfÀfŞÀg0Àg€ÀgÏÀgëÀgñÀhAÀh„Àh•Àh›ÀhèÀi:ÀiOÀiUÀieÀikÀi¶ÀiéÀj9ÀjeÀj†Àj‡Àj¼ÀkÀk(Àk.Àk}ÀkÉÀkéÀkïÀl>ÀlÀl£Àl©ÀlúÀmKÀm–ÀmæÀn/Àn|ÀnÍÀoÀoÀo#Ào3Ào9ÀoUÀo‚Ào¶ÀoÇÀoÔÀoêÀp Àp$Àp>ÀpFÀpJÀpKÀpyÀp–ÀpÔÀpõÀpûÀqÀqÀqÀq_ÀqeÀq¶ÀrÀr4Àr:Àr‡ÀrÑÀsÀsOÀsrÀsÀs­ÀsïÀsşÀt1ÀtVÀteÀt›Àt£Àt©ÀtºÀt¾Àt¿ÀuÀuPÀuVÀu¦Àu÷Àv:Àv†Àv³Àv¹ÀwÀwOÀw\ÀwˆÀw›Àw¿Àx	ÀxÀx%Àx6Àx:Àx;ÀxGÀxŸÀxâÀyÀyAÀy_ÀyrÀyzÀy{ÀyÀy´ÀzÀzÀzMÀzVÀz]Àz^Àz~Àz×ÀzäÀzûÀ{À{TÀ{šÀ{¥À{®À{´À{ÌÀ{ĞÀ{ÑÀ|(À|}À|šÀ|¬À|ÅÀ}%À}:À}UÀ}\À}`À}aÀ}mÀ}À}£À}èÀ}ïÀ~2À~6À~7À~CÀ~eÀ~xÀ~½À~ÄÀÀÀÀÀPÀ›ÀæÀùÀ€4À€8À€9À€‚À€˜À€ÙÀ€ÚÀ)ÀHÀNÀŸÀÈÀÎÀ‚À‚kÀ‚¼ÀƒÀƒ4Àƒ5ÀƒqÀƒwÀƒÆÀƒÖÀƒÜÀ„*À„wÀ„ÄÀ„ùÀ„ÿÀ…OÀ…mÀ…sÀ…ƒÀ…‰À…½À…÷À†FÀ†–À†¥À†ùÀ†úÀ‡3À‡?À‡sÀ‡ƒÀ‡»À‡ĞÀ‡ØÀˆÀˆQÀˆkÀˆ¼À‰À‰`À‰ŒÀ‰—À‰¡À‰«À‰ÇÀ‰ËÀ‰ÌÀŠÀŠÀŠ`ÀŠ¯ÀŠµÀ‹À‹À‹]À‹°À‹¶ÀŒÀŒ?ÀŒEÀŒ–ÀŒçÀ8ÀƒÀ¬À²ÀÀÀÀjÀ¸ÀôÀúÀ*À0ÀÀÒÀ#À©À¯À‘ À‘MÀ‘‘À‘ÛÀ’)À’nÀ’tÀ’ÅÀ’ÒÀ’ñÀ“À“/À“|À“™À“´À“ÔÀ“ÜÀ“ïÀ“õÀ“öÀ”À”+À”PÀ”¡À”ñÀ•DÀ•œÀ•éÀ•òÀ–EÀ–¢À–öÀ—À—À—dÀ—°À˜À˜JÀ˜\À˜¦À˜òÀ™1À™FÀ™RÀ™À™×Àš"ÀšTÀšyÀš§Àš±ÀšËÀ›À›CÀ›qÀ›{À›ÚÀ›ûÀœ2ÀœHÀœŒÀœèÀœöÀÀÀƒÀÀ®ÀÏÀ÷ÀÀ,À@ÀwÀÀœÀ¶ÀÅÀåÀŸÀŸVÀŸ¦ÀŸÙÀ À À $À lÀ ºÀ ëÀ¡À¡%À¡&À¡6À¡QÀ¡‚À¡ŠÀ¡°À¡ÎÀ¡íÀ¢,À¢4À¢GÀ¢QÀ¢RÀ¢gÀ¢kÀ¢lÀ¢«À¢±À¢úÀ£KÀ£vÀ£|À£ËÀ¤À¤hÀ¤³À¤şÀ¥OÀ¥„À¥ŠÀ¥ÛÀ¦,À¦}À¦ËÀ§À§lÀ§»À§ÿÀ¨PÀ¨À¨…À¨¾À©À©YÀ©¥À©ìÀª:ÀªjÀªpÀª¼À«À«SÀ«¢À«äÀ¬-À¬€À¬ËÀ­À­YÀ­¥À­óÀ®DÀ®\À®iÀ®‰À®¨À®ÇÀ®ìÀ¯À¯À¯MÀ¯NÀ¯‡À¯ÒÀ¯ØÀ¯ÙÀ°À°5À°VÀ°—À°À°À°àÀ±/À±|À±ÀÀ±ÁÀ±ğÀ²À²2À²wÀ²œÀ²ßÀ³&À³'À³yÀ³ÈÀ³âÀ´0À´|À´ÉÀ´êÀµ.ÀµVÀµšÀµÍÀ¶À¶4À¶€À¶ÀÀ·À·À·À·6À·RÀ·…À·¹À·ºÀ·öÀ¸À¸,À¸3À¸4À¸PÀ¸QÀ¸tÀ¸ÑÀ¹*À¹eÀ¹½ÀºÀºÀº#ÀºOÀºaÀºtÀº¤Àº®ÀºòÀ» À»@À»[À»vÀ»|À»}À»¡À»şÀ¼ZÀ¼˜À¼ğÀ½?À½NÀ½VÀ½tÀ½’À½˜À½™À½ÑÀ¾À¾@À¾[À¾†À¾ºÀ¿À¿oÀ¿À¿¼À¿ûÀÀÀÀ5ÀÀAÀÀKÀÀhÀÀpÀÀvÀÀwÀÀÀÀÏÀÀèÀÁ#ÀÁ@ÀÁhÀÁƒÀÁ°ÀÁÒÀÂÀÂ5ÀÂ‚ÀÂ®ÀÂÃÀÃ	ÀÃ(ÀÃ6ÀÃBÀÃLÀÃTÀÃ¤ÀÃĞÀÃâÀÃõÀÄ%ÀÄ/ÀÄsÀÄÀÄ¡ÀÄÁÀÅÀÅÀÅ:ÀÅZÀÅuÀÅ{ÀÅ|ÀÅ¡ÀÅÖÀÆÀÆbÀÆ‘ÀÆÁÀÆÂÀÆèÀÇEÀÇÀÇ½ÀÈÀÈ<ÀÈxÀÈ¤ÀÈ¶ÀÈÉÀÈùÀÉÀÉGÀÉ£ÀÉÑÀÉñÀÊÀÊ'ÀÊ-ÀÊ.ÀÊsÀÊ®ÀÊîÀË@ÀËeÀËoÀËwÀË}ÀËËÀËãÀËçÀËèÀÌ2ÀÌ8ÀÌ‰ÀÌÕÀÍ#ÀÍXÀÍ^ÀÍ®ÀÍÒÀÍØÀÎ'ÀÎwÀÎ®ÀÎãÀÎéÀÏ8ÀÏlÀÏ}ÀÏ®ÀÏºÀÏîÀĞ@ÀĞGÀĞSÀĞjÀĞ¿ÀĞÆÀĞÒÀÑÀÑÀÑ†ÀÑÜÀÑòÀÒÀÒ7ÀÒ_ÀÒyÀÒÅÀÓÀÓ@ÀÓ]ÀÓŠÀÓÀÓ«ÀÓÌÀÓèÀÔÀÔÀÔ4ÀÔRÀÔVÀÔWÀÔÀÔ«ÀÔèÀÔìÀÔíÀÕ%ÀÕ+ÀÕsÀÕÂÀÕúÀÖ ÀÖHÀÖYÀÖ…ÀÖ¾ÀÖøÀ×À×9À×ZÀ×‰À×À×áÀØ2ÀØƒÀØÎÀØ÷ÀÙÀÙ^ÀÙ“ÀÙ¦ÀÙ°ÀÙÉÀÙÍÀÙÎÀÚÀÚÀÚhÀÚ¹ÀÚèÀÚõÀÛ1ÀÛjÀÛÀÛ¯ÀÛÒÀÜÀÜ8ÀÜSÀÜ[ÀÜaÀÜbÀÜtÀÜxÀÜyÀÜÊÀÜşÀİÀİÀİAÀİzÀİ—ÀİÙÀİîÀİòÀİóÀŞÀŞIÀŞkÀŞ‰ÀŞ¯ÀŞÚÀŞäÀŞêÀŞîÀŞïÀßÀßMÀß[ÀßaÀß³ÀßàÀßúÀà'ÀàKÀàwÀàÀàƒÀà„Àà¶Àà¼ÀàôÀá.Àá~Àá²Àá¸ÀáãÀâÀâ%ÀâGÀâOÀâaÀâeÀâfÀâºÀâÀÀâøÀã2Àã‚Àã²Àã¸ÀäÀä5ÀäOÀäsÀäœÀä¤Àä¹Àä½Àä¾ÀåÀåXÀå¬ÀåúÀæKÀæ˜ÀæîÀç Àç;ÀçNÀçTÀçŒÀçŸÀç¥ÀçµÀççÀçûÀèiÀètÀè|ÀèÀè™ÀèÆÀèàÀèòÀéÀéJÀé«ÀéûÀêNÀê¯ÀêØÀë(Àë>ÀëwÀë†Àë¤ÀìÀìÀì Àì*Àì„Àì–Àì¥Àì°ÀìÅÀìÑÀìôÀíÀí!ÀíFÀítÀíˆÀíŒÀíÀíØÀíùÀíÿÀîHÀî“Àî£Àî©Àî÷ÀïFÀï—ÀïèÀïîÀğ>ÀğDÀğ“ÀğÂÀğÏÀğîÀñÀñ,ÀñiÀñÄÀñáÀòÀò&ÀòfÀò¾ÀòÈÀòİÀòéÀóIÀóOÀóPÀóZÀó€ÀóÀóèÀôÀô4ÀôJÀôvÀôÀôŸÀô¯ÀôèÀõ ÀõdÀõvÀõŸÀõ¹ÀõüÀö
ÀöÀö+Àö~ÀöªÀöÊÀöÔÀöÜÀ÷À÷(À÷PÀ÷eÀ÷qÀ÷–À÷ÚÀ÷ÛÀ÷òÀøÀø!ÀøGÀøOÀøUÀøYÀøZÀøŠÀø°ÀøÀÀøÛÀù ÀùÀù&ÀùrÀù…ÀùÀù“Àù”ÀùáÀúÀúÀúaÀú²Àú×ÀúİÀûÀû#ÀûpÀû¾ÀüÀü^Àü¥Àü²ÀüÚÀüıÀıÀı7ÀıŒÀıœÀıÎÀıûÀş>ÀşHÀşPÀşcÀşmÀşqÀşrÀşÂÀÿÀÿÀÿjÀÿ¤Àÿ²À À À gÀ £À ©À öÀÀÀiÀ¹ÀÀÀÀmÀÀ›À¬ÀĞÀÀfÀ´ÀÿÀNÀ|ÀŒÀ·ÀñÀùÀÀÀÀÀYÀ”ÀªÀÅÀÕÀÀJÀRÀeÀoÀ‘ÀµÀÕÀöÀ/À3À4ÀjÀ­ÀÅÀÀ7À;À<À‚ÀˆÀØÀ	)À	rÀ	ÂÀ	ÈÀ
À
À
mÀ
•À
¦À
ºÀ
õÀÀ1À~À®ÀÀBÀ^À‡À¡À¿ÀÑÀöÀüÀÀ6À<À@ÀAÀ‡ÀÀİÀ.À|ÀÇÀÀ3À9ÀqÀwÀÇÀÍÀÀDÀUÀkÀ¤ÀÀ3ÀuÀŸÀ§ÀøÀFÀ–ÀæÀ3ÀOÀUÀtÀ¦ÀªÀ«ÀÀÀ:ÀKÀgÀ¢À¦À§ÀîÀôÀCÀ‘ÀâÀ*À0ÀÀ•À›ÀèÀ6ÀjÀpÀÀÀÆÀÀ:ÀKÀ^À™ÀúÀÀCÀ‹À®ÀÊÀøÀşÀHÀ|ÀÀªÀÛÀßÀàÀ0ÀÀ¼ÀÂÀÀdÀjÀ¸ÀÀSÀ¤ÀòÀ=ÀŒÀØÀèÀîÀ;À‹ÀÕÀ &À gÀ mÀ ¹À ÙÀ!À!À!$À!IÀ!YÀ!’À!ÊÀ"À".À"~À"ºÀ#À#RÀ#xÀ#…À#æÀ#òÀ#úÀ$À$À$0À$4À$5À$AÀ$TÀ$dÀ$À$íÀ%À%TÀ%”À%°À&À&=À&„À&‘À&äÀ&ğÀ&øÀ'À'SÀ'ŒÀ'¨À'úÀ(JÀ(›À(èÀ),À)9À)RÀ)gÀ)·À*	À*]À*¯À*ĞÀ*İÀ*öÀ+IÀ+UÀ+]À+pÀ+zÀ+µÀ+ÅÀ+çÀ,À,cÀ,xÀ,ËÀ- À-tÀ-ÇÀ-ıÀ.
À.]À.iÀ.qÀ.›À.ÓÀ/À/(À/kÀ/»À0À0NÀ0šÀ0»À0ÈÀ1À1hÀ1tÀ1|À1¤À1ÜÀ25À2JÀ2ŸÀ2òÀ3CÀ3tÀ3À3ÔÀ4!À4-À45À4_À4yÀ4±À5À5(À5zÀ5ÍÀ6À6nÀ6¸À6ÅÀ7À7xÀ7„À7ŒÀ7®À7æÀ7şÀ8YÀ8fÀ8{À8ÕÀ92À9ŒÀ9ãÀ:	À:À:iÀ:ÉÀ:ŞÀ;8À;€À;À;™À;¡À;´À;¾À;ãÀ<À<	À<À<À<À<`À<ˆÀ<´À<µÀ<êÀ<úÀ=3À=kÀ=¼À=ØÀ>)À>@À>MÀ>bÀ>±À?À?PÀ?]À?iÀ?qÀ?„À?À?ŸÀ?£À?¤À?şÀ@À@LÀ@ƒÀ@‡À@ˆÀ@”À@îÀA!ÀACÀArÀA¡ÀA¥ÀA¦ÀA²ÀB	ÀBBÀBÀBÀBãÀBéÀCÀC"ÀC&ÀC'ÀC3ÀCuÀC¼ÀCÀÀCÁÀCÍÀD(ÀDaÀD„ÀDˆÀD‰ÀDÜÀDùÀDÿÀEVÀEªÀE¼ÀEÂÀEÒÀF%ÀF2ÀFTÀFˆÀFŒÀFÀF«ÀFäÀGÀGÀGÀG+ÀGdÀGÀG¾ÀHÀH$ÀH*ÀHMÀHQÀHRÀH^ÀH ÀHÙÀHúÀIÀIYÀIhÀIpÀI“ÀI™ÀIåÀJÀJÀJÀJ ÀJfÀJŸÀJÀÀJçÀKÀKFÀKkÀKsÀK–ÀKœÀKÆÀKÊÀKËÀK×ÀLÀLPÀLqÀLÀLÛÀMÀMÀM1ÀM7ÀMHÀMLÀMMÀMYÀM›ÀMÔÀMõÀN)ÀNLÀNRÀNVÀNWÀNÀN•ÀNëÀO<ÀOÀOºÀP	ÀPCÀPTÀPuÀPÕÀQÀQ3ÀQ7ÀQ8ÀQvÀQ†ÀQ»ÀQóÀRÀRQÀRtÀRÀRÙÀRîÀSAÀSYÀS~ÀS ÀS¹ÀTÀTÀT&ÀT.ÀTAÀTKÀT\ÀT`ÀTaÀT¨ÀT®ÀTãÀUÀU9ÀUSÀU†ÀU­ÀUÈÀUÎÀUæÀVÀVÀV*ÀV.ÀV/ÀV~ÀV„ÀVÕÀWÀW/ÀW`ÀW}ÀW˜ÀW¯ÀWÊÀWĞÀWâÀWæÀWçÀWóÀX,ÀXgÀXkÀXlÀX ÀX¬ÀY
ÀYÀYÀYjÀY¼ÀYÀÀYÁÀYÍÀZÀZ=ÀZ†ÀZ¾À[À[À[oÀ[ƒÀ[£À[²À[ÈÀ[áÀ[ıÀ\$À\-À\4À\bÀ\¬À\ãÀ]À]TÀ]dÀ]šÀ]ØÀ]ãÀ^2À^BÀ^lÀ^ÂÀ^ÎÀ^ãÀ^ùÀ_-À_GÀ_WÀ_’À_À_¦À_¬À_°À_±À_½À_ïÀ`/À`SÀ`‚À`ŠÀ`ŸÀ`£À`¤À`íÀ`óÀa6Àa†ÀaÓÀb&ÀbnÀbŠÀb Àb¡ÀbòÀcAÀc^Àc_ÀcšÀcºÀc»Àd	Àd*Àd0ÀdvÀd½ÀeÀe#Àe=ÀewÀe®Àe¼ÀeÂÀeİÀfÀf&ÀfIÀf‚Àf¬ÀfòÀg	ÀgÀgXÀg§ÀgÃÀh/Àh‡ÀhŞÀi4Ài‰ÀiÜÀjÀjÀjxÀjƒÀjºÀjÕÀkÀksÀk‚ÀkÀk™ÀkÌÀkùÀl1ÀlÀl«ÀmÀm1Àm>ÀmÀmªÀm²ÀmÅÀmÏÀmàÀmîÀmôÀnÀn*Àn.Àn/Àn}ÀnÀn•ÀnâÀo0ÀojÀopÀo½ÀpÀpAÀpGÀpeÀpkÀpÀp‡Àp×Àq$ÀqbÀqhÀq·ÀrÀrUÀr˜ÀrÀrîÀs?ÀsÀs·Às½ÀsàÀsæÀt9ÀtaÀtgÀt¶ÀtìÀtòÀu>ÀumÀusÀuÌÀuÒÀuçÀuíÀv;Àv‡ÀvÔÀwÀw^ÀwdÀw¯ÀwûÀxÀxKÀx›ÀxêÀy:ÀyrÀyŸÀy¥ÀyïÀz=ÀzcÀziÀz¯ÀzÿÀ{NÀ{[À{aÀ{±À{ıÀ|IÀ|yÀ|À|˜À|À|îÀ}&À},À}|À}ËÀ~À~hÀ~­À~³À~şÀHÀ”ÀäÀ€/À€À€ÉÀÀ`À¯ÀûÀ‚À‚KÀ‚›À‚ëÀƒ:ÀƒˆÀƒÙÀƒßÀ„/À„sÀ„¼À„ÛÀ„ùÀ…À…@À…zÀ…ÈÀ…ÖÀ…ÜÀ…ìÀ†*À†UÀ†uÀ†À†¿À†ĞÀ†úÀ‡À‡À‡À‡)À‡bÀ‡ˆÀ‡¯À‡¿ÀˆÀˆ/ÀˆBÀˆLÀˆVÀˆnÀˆ~ÀˆÀˆ¾Àˆ÷À‰;À‰PÀ‰\À‰bÀ‰wÀ‰{À‰|À‰¥À‰«À‰òÀ‰øÀŠ4ÀŠAÀŠRÀŠlÀŠ€ÀŠ„ÀŠ†ÀŠ‡ÀŠÍÀŠğÀ‹ À‹"À‹<À‹WÀ‹]À‹^À‹uÀ‹vÀ‹‚À‹ĞÀŒÀŒ?ÀŒbÀŒ«ÀŒ±ÀŒÒÀŒãÀŒçÀŒéÀŒêÀ6ÀMÀQÀ™ÀÀ«À¯ÀöÀÀ_À®ÀÃÀÀÀAÀEÀ‘ÀâÀ.ÀiÀmÀ™ÀÀ±À‘À‘7À‘;À‘yÀ‘}À‘ÊÀ‘ÚÀ‘ŞÀ‘ìÀ‘ğÀ’;À’À’ĞÀ’ìÀ“À“YÀ“_À“¬À“ùÀ”À”À”lÀ”»À”äÀ•À•+À•oÀ•À•À•ÍÀ•ÓÀ–!À–MÀ–‘À–®À–ÍÀ–ÎÀ— À—À—OÀ—–À—·À—½À˜À˜[À˜§À˜øÀ™DÀ™JÀ™˜À™ÙÀš ÀšoÀš¶Àš¼À›	À›LÀ›RÀ›bÀ›hÀ›±Àœ ÀœMÀœ`Àœ±ÀœÏÀÀÀ\ÀuÀ…À•ÀöÀ	ÀÀCÀgÀÀºÀÁÀÅÀÆÀöÀŸ ÀŸ#ÀŸ9ÀŸ“ÀŸëÀ 9À ?À SÀ WÀ XÀ vÀ À ³À ´À ÀÀ¡À¡À¡À¡cÀ¡À¡¯À¡øÀ¢À¢dÀ¢jÀ¢nÀ¢pÀ¢qÀ¢ÂÀ¢ØÀ¢ÜÀ£À£À£*À£.À£wÀ£¼À¤	À¤HÀ¤IÀ¤šÀ¤¤À¤¨À¤ùÀ¤ıÀ¥À¥À¥YÀ¥À¥ëÀ¦<À¦=À¦À¦­À¦±À¦öÀ§:À§MÀ§QÀ§ŸÀ§ìÀ¨:À¨…À¨ÎÀ©À©À©,À©0À©zÀ©¿ÀªÀª[Àª\ÀªÀª’ÀªÖÀªÚÀ«À«SÀ«WÀ«eÀ«iÀ«²À«úÀ¬FÀ¬˜À¬™À¬ÊÀ¬ÎÀ­À­\À­`À­‰À­»À®À®'À®(À®;À®<À®]À®iÀ®™À®šÀ®¦À®ÛÀ®ÜÀ®èÀ¯À¯;À¯WÀ¯À¯£À¯¿À¯ÃÀ¯ÄÀ¯ÛÀ°+À°cÀ°gÀ°hÀ°·À±À±FÀ±LÀ±šÀ±ËÀ±×À²À²À²1À²;À²MÀ²nÀ²ƒÀ²À²¦À²¸À²ÚÀ²ïÀ²ûÀ³)À³BÀ³bÀ³…À³ŸÀ³ÍÀ³ÚÀ³ëÀ´$À´mÀ´zÀ´…À´À´À´ìÀµ7ÀµpÀµvÀµ€Àµ±ÀµÏÀµèÀ¶À¶%À¶SÀ¶`À¶qÀ¶ªÀ¶óÀ· À·À·À·CÀ·IÀ·MÀ·NÀ·À·êÀ·şÀ¸À¸À¸À¸*À¸YÀ¸sÀ¸‹À¸‘À¸•À¸–À¸¢À¸ÆÀ¸ãÀ¸öÀ¹À¹À¹À¹À¹`À¹’À¹ÜÀºÀºÀºÀºXÀºYÀºeÀºÀº­ÀºÎÀºèÀºìÀºîÀºïÀ»3À»dÀ»®À¼À¼À¼HÀ¼€À¼˜À¼øÀ½À½!À½tÀ½»À¾À¾À¾)À¾1À¾DÀ¾NÀ¾rÀ¾À¾™À¾¶À¿À¿TÀ¿nÀ¿uÀ¿‘À¿ÔÀ¿ØÀ¿ÙÀ¿åÀÀÀÀÀÀSÀÀYÀÀ¢ÀÀòÀÁÀÁGÀÁhÀÁiÀÁuÀÁ‹ÀÁ£ÀÁ»ÀÁ¿ÀÁÀÀÁÌÀÁãÀÂ&ÀÂtÀÂ„ÀÂ·ÀÂïÀÃ>ÀÃ¡ÀÃ¶ÀÄÀÄXÀÄeÀÄqÀÄyÀÄŒÀÄ–ÀÄ¦ÀÄæÀÄùÀÅÀÅ&ÀÅ6ÀÅpÀÅƒÀÅÀÅ¦ÀÅªÀÅ«ÀÅ·ÀÅÑÀÅóÀÆÀÆ>ÀÆDÀÆ`ÀÆdÀÆeÀÆqÀÆ›ÀÆ¸ÀÆÙÀÇÀÇ<ÀÇ™ÀÇ©ÀÇÜÀÈÀÈiÀÈ…ÀÈŞÀÈëÀÉ ÀÉ]ÀÉ¨ÀÉµÀÉÁÀÉÉÀÉÜÀÉæÀÊ ÀÊÀÊÀÊÀÊ%ÀÊ;ÀÊQÀÊ¢ÀÊğÀË'ÀË‡ÀËÀË¡ÀË¢ÀË®ÀËÄÀËÜÀËôÀËøÀËùÀÌÀÌÀÌ-ÀÌBÀÌRÀÌ•ÀÌªÀÌ²ÀÌèÀÍ<ÀÍVÀÍ»ÀÎÀÎÀÎÀÎ%ÀÎ@ÀÎŠÀÎ¾ÀÎÑÀÎÕÀÎÖÀÎâÀÏ3ÀÏCÀÏ~ÀÏÁÀÏùÀĞÀĞ®ÀĞ»ÀĞ×ÀÑ8ÀÑ‘ÀÑãÀÒ8ÀÒYÀÒfÀÒ{ÀÒëÀÓ]ÀÓ·ÀÓÄÀÓĞÀÓØÀÔÀÔSÀÔkÀÔìÀÔùÀÕÀÕoÀÕÂÀÖÀÖMÀÖ¨ÀÖµÀÖÊÀ× À×uÀ×µÀØÀØ#ÀØ0ÀØEÀØÀØÚÀÙ)ÀÙ|ÀÙ¶ÀÙÃÀÙÏÀÙ×ÀÙêÀÙôÀÚMÀÚQÀÚRÀÚ ÀÚğÀÛ?ÀÛxÀÛ~ÀÛÍÀÜÀÜVÀÜ‡ÀÜ®ÀÜ¯ÀÜ»ÀÜÜÀÜÿÀİ"Àİ&Àİ'Àİ3Àİ†ÀİèÀİìÀİíÀİùÀŞ>ÀŞiÀŞÎÀŞÒÀŞÔÀŞÕÀßÀßMÀßvÀß Àß¡Àß­ÀßàÀßáÀßíÀàÀàMÀànÀà‹Àà¬ÀàÄÀàŞÀàâÀàãÀáÀá"ÀárÀá½ÀáÜÀáéÀâÀâ9Àâ=Àâ>ÀâŠÀâ™ÀâŸÀâæÀã-Àã:ÀãqÀãsÀãtÀãºÀãÿÀäIÀä€ÀäÀäĞÀäÛÀäáÀå*Àå?Àå`ÀåpÀå€ÀåÀå£Àå­ÀåÅÀåÙÀåßÀæ4Àæ8Àæ9ÀæoÀæ ÀæÊÀæóÀç0ÀçsÀç{ÀçÀç‚Àç°ÀçëÀçñÀçõÀçöÀèEÀè‹Àè¢Àè¨ÀèõÀéFÀéqÀéwÀéËÀêÀêeÀê{ÀêÀêÒÀëÀëiÀëoÀë¼ÀìÀìÀìEÀìÀì”ÀìÙÀìßÀí/ÀíÀíÏÀîÀînÀîºÀîìÀï)ÀïYÀïŸÀïÀÀïÄÀïÅÀïÑÀğÀğ<Àğ@ÀğBÀğCÀğ‰Àğ·ÀñÀñ3Àñ4Àñ}Àñ~ÀñŠÀñ¨ÀñáÀò'Àò‡ÀòÏÀòÓÀòÔÀòàÀòüÀóÀó/ÀóBÀóLÀójÀónÀóoÀó­ÀóËÀóÑÀôÀôHÀôÀôÅÀôËÀõÀõGÀõ`ÀõfÀõ·Àõ½ÀõÍÀõÓÀöÀöXÀö¢Àö´ÀöıÀ÷IÀ÷™À÷¿À÷ÌÀ÷ûÀøÀø"Àø#ÀømÀøsÀø³ÀøêÀù7Àù…Àù‹ÀùÎÀúÀú ÀúqÀúwÀú‡ÀúÀúÖÀûÀû^ÀûpÀû¹Àü
ÀüZÀü€ÀüÀüÈÀüìÀüğÀüñÀıGÀıMÀı–ÀıåÀışÀşÀşQÀşšÀş­Àş³ÀşúÀÿ9Àÿ?ÀÿOÀÿUÀÿ¡Àÿ³ÀÿıÀ FÀ ’À âÀÀÀTÀzÀ~ÀÀ³À¹ÀõÀûÀ9À€À†À–ÀœÀåÀ!ÀmÀÀÉÀÀ?ÀLÀÀÄÀÈÀÉÀ9À?ÀÀàÀæÀ6ÀQÀ^ÀoÀ›À¾ÀÂÀÃÀÀFÀLÀ„ÀŠÀÍÀÙÀÀJÀjÀpÀtÀuÀÆÀõÀûÀ	FÀ	•À	ßÀ	åÀ	õÀ	ûÀ
IÀ
ŠÀ
–À
ÈÀÀ@ÀRÀ„À³ÀêÀÀÀ<ÀHÀtÀ«ÀØÀŞÀâÀäÀåÀ-À1ÀÀÇÀæÀêÀÀÀeÀiÀ—À›ÀáÀåÀ6ÀOÀSÀ¡À­À±ÀüÀÀÀjÀºÀ ÀQÀ†ÀŠÀÕÀ#ÀEÀIÀjÀnÀ³ÀıÀDÀ‹ÀºÀ¾ÀÊÀıÀÀ!À_À‰À™ÀŞÀâÀöÀ:À€À¡ÀÈÀ×ÀßÀãÀğÀöÀşÀÀÀÀ]À–ÀšÀæÀ4À{ÀÉÀÀÀXÀ§ÀòÀBÀÀÈÀÌÀÀaÀ{ÀÀ™ÀÀçÀ4ÀÀŸÀ£ÀòÀBÀ’ÀâÀ%À)ÀyÀÆÀÀgÀ¯ÀÿÀ(À,ÀxÀÆÀ À bÀ fÀ «À ¯À úÀ!JÀ!kÀ!oÀ!«À!¯À!şÀ"OÀ"À"ÏÀ#À#aÀ#À#¢À#èÀ$6À$À$ƒÀ$ĞÀ%À%]À%aÀ%ˆÀ%ŒÀ%ÛÀ&)À&xÀ&ÆÀ&ØÀ&ÜÀ&÷À&ûÀ'FÀ'‹À'ÖÀ( À(mÀ(¼À(ÉÀ(ÍÀ)À)hÀ)›À)ŸÀ)íÀ*=À*ŒÀ*ÉÀ*îÀ*òÀ+À+!À+^À+«À+úÀ,À,À,kÀ,»À,ÛÀ,ßÀ,üÀ- À-KÀ-œÀ-éÀ.-À.bÀ.¬À.äÀ.åÀ/À/!À/eÀ/qÀ/“À/ĞÀ/ëÀ/ïÀ/ğÀ0À0À0À0OÀ0PÀ0qÀ0}À0­À0®À0ãÀ0äÀ1 À1AÀ1„À1ÒÀ2"À2XÀ2¦À2»À2ÍÀ3À3(À32À3GÀ3SÀ3wÀ3}À3À3ÓÀ3ìÀ3ôÀ4À4À4>À4BÀ4CÀ4iÀ4™À4»À4ßÀ5À5À5À5VÀ5À5¹À5óÀ6EÀ6tÀ6„À6èÀ6óÀ7À7PÀ7À7ÍÀ8À8GÀ8eÀ8³À8×À8æÀ96À9lÀ9|À9ÇÀ9×À9÷À:@À:À:«À;À;.À;?À;]À;£À;ôÀ<&À<5À<LÀ<—À<çÀ=6À=jÀ=yÀ=À=ØÀ>'À>lÀ>—À>¦À>ÄÀ?À?QÀ?`À?nÀ?˜À?ıÀ@À@À@"À@,À@0À@1À@{À@œÀ@öÀA)ÀA^ÀA•ÀA–ÀAåÀAşÀBIÀB—ÀB¼ÀCÀC@ÀCÀCÛÀD#ÀDqÀDŠÀDËÀEÀEZÀEœÀEêÀFÀFÀFOÀF†ÀFÀÀFÿÀGHÀG…ÀG‘ÀG¨ÀG¾ÀGÜÀGäÀHÀHÀHÀHMÀHbÀHjÀH—ÀH¼ÀHÌÀHèÀIÀI%ÀI.ÀIAÀIKÀI^ÀIbÀIcÀIoÀI ÀIÂÀIÒÀIñÀJÀJÀJ[ÀJ‡ÀJ—ÀJ·ÀJÊÀJÔÀJäÀKÀKÀK(ÀKEÀKfÀKÀK¡ÀK¢ÀK®ÀKæÀLÀL$ÀL4ÀL[ÀLnÀLxÀL´ÀL¸ÀL¹ÀLâÀLòÀM(ÀM;ÀMEÀMIÀMJÀMVÀM‘ÀM«ÀMçÀMëÀMìÀNÀN)ÀNIÀNdÀNtÀN“ÀN¦ÀN°ÀNûÀOÀO+ÀO>ÀOHÀOÀOƒÀO„ÀOÀO¦ÀO¾ÀOÊÀOèÀP5ÀPaÀPhÀPlÀPmÀPyÀPŒÀP˜ÀP¼ÀQÀQ%ÀQ,ÀQsÀQˆÀQ”ÀQ²ÀQüÀR(ÀR/ÀRcÀRÀR›ÀRŸÀR ÀRêÀSÀSÀS'ÀSoÀS’ÀSÌÀTÀTSÀT†ÀTäÀU.ÀU=ÀUKÀUUÀUyÀUÉÀVÀViÀV°ÀWÀWÀW#ÀW-ÀWHÀW~ÀW„ÀWˆÀW‰ÀW•ÀWºÀWÜÀWüÀXÀX8ÀXˆÀXŞÀXâÀXãÀXïÀYÀYNÀYcÀYªÀYºÀYìÀZÀZ-ÀZnÀZŠÀZ÷À[À[(À[”À[¥À[¾À\!À\vÀ\‡À\—À\¤À\¯À\·À\ÊÀ\ÔÀ]&À]iÀ]”À]ìÀ^?À^EÀ^IÀ^JÀ^VÀ^tÀ^¤À^õÀ_ À_&À_8À_<À_=À_À_‡À_ÕÀ`#À`rÀ`ÃÀ`ûÀaÀaÀasÀatÀa¾ÀaÄÀbÀbÀb_ÀbeÀb´ÀcÀcWÀc©ÀcûÀdNÀdŸÀd×ÀdäÀeÀe$ÀeCÀebÀegÀehÀešÀe ÀeîÀfÀf(Àf~ÀfÀf‹ÀfĞÀfûÀgÀgkÀgrÀgvÀgxÀgyÀgÉÀgÙÀgİÀh+ÀhKÀhXÀh{Àh³ÀhµÀiÀi9ÀiHÀimÀi§Ài«ÀiÔÀiÖÀi×Àj
ÀjÀjTÀjˆÀj¬ÀjøÀkÀk!ÀkRÀkXÀk‘ÀkâÀl2ÀlvÀl˜Àl¿ÀlÓÀlùÀlıÀlşÀm
Àm;ÀmkÀm‡Àm¤ÀmÆÀmÊÀmÌÀmÍÀnÀnUÀnŸÀnßÀnàÀnìÀoÀo#ÀoAÀoEÀoFÀoRÀo•Ào¨Ào¬Ào­Ào¹ÀpÀp!Àp%Àp&Àp2ÀpuÀpˆÀpŒÀpÀp™ÀpËÀpöÀpúÀpüÀpıÀqPÀqTÀqoÀqsÀq¹Àr
ÀrHÀr‹ÀrÕÀs#Às$Às7Às8ÀsDÀssÀsÀs¥Às«Às¯Às°Às¼ÀsàÀsıÀtÀt.Àt2Àt3Àt?ÀtpÀt’ÀtëÀtïÀtğÀtüÀu5ÀuRÀusÀuÌÀuĞÀuÑÀuİÀv ÀvbÀv©ÀvÃÀv÷ÀwÀwFÀwJÀwKÀwWÀw¬Àw¿ÀwÃÀwÄÀwĞÀxÀxUÀxœÀx¶ÀxßÀxşÀy-Ày1Ày3Ày4Ày†ÀyŠÀyĞÀz"ÀzrÀz³Àz·ÀzÅÀzÉÀ{À{<À{ŠÀ{·À{ùÀ|CÀ|À|ÖÀ|×À|ãÀ}6À}KÀ}iÀ}ÆÀ}ÊÀ}ËÀ}ÿÀ~À~RÀ~hÀ~uÀ~ŠÀ~®À~ıÀ~şÀÀnÀ’ÀĞÀÑÀİÀ€.À€‰À€¯À€ãÀ$ÀSÀWÀXÀdÀ‚ÀšÀ½ÀàÀæÀ‚AÀ‚gÀ‚‘À‚ÓÀƒÀƒÀƒÀƒÀƒVÀƒ±Àƒ×À„À„!À„PÀ„TÀ„UÀ„aÀ„À„½À„îÀ…À…À…À…À…À…%À…IÀ…pÀ…¡À…ÄÀ…âÀ…æÀ…çÀ†'À†7À†bÀ†„À†£À†äÀ‡ À‡nÀ‡À‡˜À‡ïÀˆ-Àˆ>ÀˆfÀˆ¹ÀˆÊÀ‰	À‰À‰&À‰1À‰9À‰LÀ‰VÀ‰gÀ‰kÀ‰lÀ‰xÀ‰µÀ‰ûÀŠ7ÀŠLÀŠPÀŠQÀŠ]ÀŠÀŠ°ÀŠöÀ‹&À‹_À‹“À‹°À‹·À‹ÓÀŒÀŒ4ÀŒfÀŒ—ÀŒ ÀŒ¾ÀŒŞÀŒäÀŒşÀÀÀÀGÀdÀªÀÚÀûÀWÀwÀˆÀµÀâÀéÀ	ÀÀÀÀVÀZÀ¦ÀóÀ2À{À¹ÀØÀ‘À‘eÀ‘ŒÀ‘À‘™À‘ªÀ‘×À‘ìÀ’*À’.À’/À’;À’LÀ’jÀ’|À’€À’À’À’²À’ÑÀ“À“À“À“NÀ“eÀ“xÀ“~À“´À“êÀ” À”yÀ”„À”À•À•À•)À•€À•ÚÀ–À–"À–5À–…À–ÔÀ—À—qÀ—ÀÀ—ËÀ—ŞÀ˜-À˜€À˜ÔÀ˜ßÀ˜éÀ˜ïÀ™ À™À™À™À™VÀ™ZÀ™ªÀ™¾À™ÓÀšÀš.Àš/ÀšXÀšqÀšrÀš~Àš·Àš¹ÀšºÀšàÀšûÀ›À›&À›TÀ›YÀ›”À›®À›ÀÀ›àÀ›öÀœ&Àœ+ÀœPÀœbÀœdÀœeÀœ™Àœ¿ÀœÃÀÀQÀ ÀçÀ ÀÀÀÀeÀ·ÀÂÀêÀŸ5ÀŸbÀŸcÀŸ¯ÀŸÊÀŸÛÀŸÜÀ À (À )À 5À XÀ „À ˜À À ïÀ óÀ ôÀ¡ À¡1À¡3À¡4À¡yÀ¡À¡ÃÀ¡òÀ¡óÀ¢$À¢%À¢1À¢kÀ¢mÀ¢nÀ¢‘À¢¨À¢©À¢µÀ¢îÀ¢ğ   €æ/// @docImport 'dart:ui';
///
/// @docImport 'package:flutter/animation.dart';
/// @docImport 'package:flutter/material.dart';
/// @docImport 'package:flutter/widgets.dart';
/// @docImport 'package:flutter_test/flutter_test.dart';
–   «   Æ   ğ   ‚   ‚1   ‚F   ‚c   ‚‚   ‚§   ‚È‚õƒƒƒ¼„„„@„e„g„„¬„®„×………>…ƒ (Š*ŠŠ#  Š2Š8 Š8ŠB         ‹ÿ„‹ÿUO/// A key that takes its identity from the object used as its value.
///
/// Used to tie the identity of a widget to the identity of an object used to
/// generate that widget.
///
/// See also:
///
///  * [Key], the base class for all keys.
///  * The discussion at [Widget.key] for more information about how widgets use
///    keys. tgÅ ÅÎ H/// Creates a key that uses [identical] on [value] for its [operator==].Ï
ÕÔ   ßW11A/// The object whose identity is used by this key's [operator==]. õR		   õö ;€¶UU  X`_  ;<K€Í^^   KL ì˜‡à/// A key that is unique across the entire app.
///
/// Global keys uniquely identify elements. Global keys provide access to other
/// objects that are associated with those elements, such as [BuildContext].
/// For [StatefulWidget]s, global keys also provide access to [State].
///
/// Widgets that have global keys reparent their subtrees when they are moved
/// from one location in the tree to another location in the tree. In order to
/// reparent its subtree, a widget must arrive at its new location in the tree
/// in the same animation frame in which it was removed from its old location in
/// the tree.
///
/// Reparenting an [Element] using a global key is relatively expensive, as
/// this operation will trigger a call to [State.deactivate] on the associated
/// [State] and all of its descendants; then force all widgets that depends
/// on an [InheritedWidget] to rebuild.
///
/// If you don't need any of the features listed above, consider using a [Key],
/// [ValueKey], [ObjectKey], or [UniqueKey] instead.
///
/// You cannot simultaneously include two widgets in the tree with the same
/// global key. Attempting to do so will assert at runtime.
///
/// ## Pitfalls
///
/// GlobalKeys should not be re-created on every build. They should usually be
/// long-lived objects owned by a [State] object, for example.
///
/// Creating a new GlobalKey on every build will throw away the state of the
/// subtree associated with the old key and create a new fresh subtree for the
/// new key. Besides harming performance, this can also cause unexpected
/// behavior in widgets in the subtree. For example, a [GestureDetector] in the
/// subtree will be unable to track ongoing gestures since it will be recreated
/// on each build.
///
/// Instead, a good practice is to let a State object own the GlobalKey, and
/// instantiate it outside the build method, such as in [State.initState].
///
/// See also:
///
///  * The discussion at [Widget.key] for more information about how widgets use
///    keys.˜(˜(˜(˜Y™+ ™+™4 €¿/// Creates a [LabeledGlobalKey], which is a [GlobalKey] with a label used for
/// debugging.
///
/// The label is purely for debugging and not used for comparing the identity
/// of the key.™6™?™>   ™r€Ášššš š€Š/// Creates a global key without a label.
///
/// Used by subclasses because the factory constructor shadows the implicit
/// constructor. š%š*š+š0š1 š7]šDšD    š˜€ä›Z›Z€§/// The build context in which the widget with this key builds.
///
/// The current context is null if there is no widget in the tree that matches
/// this global key.   ›€€ãœ:œ:€¥/// The widget in the tree that currently has this global key.
///
/// The current widget is null if there is no widget in the tree that matches
/// this global key.   œgŸšš!/// The [State] for the widget in the tree that currently has this global key.
///
/// The current state is null if (1) there is no widget in the tree that
/// matches this global key, (2) that widget is not a [StatefulWidget], or the
/// associated [State] object is not a subtype of `T`.     —ı—ş
ƒ#
Ä€¡/// A global key with a debugging label.
///
/// The debug label is useful for documentation and for debugging. The label
/// does not affect the key's identity.ÕÕÕŸ€üŸÒ ŸÒŸâ f/// Creates a global key with a debugging label.
///
/// The label does not affect the key's identity.ŸãŸéŸè  Ÿ÷ŸüŸı  	        -€ş @ @    - .¬­¡/‡Æ¡/¤ƒV/// A global key that takes its identity from the object used as its value.
///
/// Used to tie the identity of a widget to the identity of an object used to
/// generate that widget.
///
/// Any [GlobalObjectKey] created for the same object will match.
///
/// If the object is not private, then it is possible that collisions will occur
/// where independent widgets will reuse the same object as their
/// [GlobalObjectKey] value in a different part of the tree, leading to a global
/// key conflict. To avoid this problem, create a private [GlobalObjectKey]
/// subclass, as in:
///
/// ```dart
/// class _MyKey extends GlobalObjectKey {
///   const _MyKey(super.value);
/// }
/// ```
///
/// Since the [runtimeType] of the key is part of its identity, this will
/// prevent clashes with other [GlobalObjectKey]s even if they have the same
/// value.¤®¤®¤®¤è€Š¥@ ¥@¥O O/// Creates a global key that uses [identical] on [value] for its [operator==].¥P
¥V¥U  ¥^¥c¥d¥o¥p¥vV¥Ç¥ÇA/// The object whose identity is used by this key's [operator==]. ¦”8¦¨¦¨   ¦”¦• ¥Ñ€¿¥ë¥ë  ¥î¥ö¥õ  ¥Ñ¥Ò¦Ğ‚#¦ã¦ã   ¦Ğ¦Ñ¤†¤‡¨÷”™¨÷°"‡/// Describes the configuration for an [Element].
///
/// Widgets are the central class hierarchy in the Flutter framework. A widget
/// is an immutable description of part of a user interface. Widgets can be
/// inflated into elements, which manage the underlying render tree.
///
/// Widgets themselves have no mutable state (all their fields must be final).
/// If you wish to associate mutable state with a widget, consider using a
/// [StatefulWidget], which creates a [State] object (via
/// [StatefulWidget.createState]) whenever it is inflated into an element and
/// incorporated into the tree.
///
/// A given widget can be included in the tree zero or more times. In particular
/// a given widget can be placed in the tree multiple times. Each time a widget
/// is placed in the tree, it is inflated into an [Element], which means a
/// widget that is incorporated into the tree multiple times will be inflated
/// multiple times.
///
/// The [key] property controls how one widget replaces another widget in the
/// tree. If the [runtimeType] and [key] properties of the two widgets are
/// [operator==], respectively, then the new widget replaces the old widget by
/// updating the underlying element (i.e., by calling [Element.update] with the
/// new widget). Otherwise, the old element is removed from the tree, the new
/// widget is inflated into an element, and the new element is inserted into the
/// tree.
///
/// See also:
///
///  * [StatefulWidget] and [State], for widgets that can build differently
///    several times over their lifetime.
///  * [InheritedWidget], for widgets that introduce ambient state that can
///    be read by descendant widgets.
///  * [StatelessWidget], for widgets that always build the same way given a
///    particular configuration and ambient state. °HA°v °v°| %/// Initializes [key] for subclasses.°~°„°ƒ   °„_´é´é„$/// Controls how one widget replaces another widget in the tree.
///
/// If the [runtimeType] and [key] properties of the two widgets are
/// [operator==], respectively, then the new widget replaces the old widget by
/// updating the underlying element (i.e., by calling [Element.update] with the
/// new widget). Otherwise, the old element is removed from the tree, the new
/// widget is inflated into an element, and the new element is inserted into the
/// tree.
///
/// In addition, using a [GlobalKey] as the widget's [key] allows the element
/// to be moved around the tree (changing parent) without losing state. When a
/// new widget is found (its key and type do not match a previous widget in
/// the same location), but there was a widget with that same global key
/// elsewhere in the tree in the previous frame, then that widget's element is
/// moved to the new location.
///
/// Generally, a widget that is the only child of another widget does not need
/// an explicit key.
///
/// See also:
///
///  * The discussions at [Key] and [GlobalKey]. ¸=¸À¸À   ¸¸Ÿ¸ª¸« ´ñÈ¶©¶©‰/// Inflates this configuration to a concrete instance.
///
/// A given widget can be included in the tree zero or more times. In particular
/// a given widget can be placed in the tree multiple times. Each time a widget
/// is placed in the tree, it is inflated into an [Element], which means a
/// widget that is incorporated into the tree multiple times will be inflated
/// multiple times.  ¶‰¶Š¶–¶—¶½€Ä··0/// A short, textual description of this widget.  ¶ğ¶ñ·…€Æ·–·–  ·ª&·Ç·Æ  ·…·†¸OK¸w¸w  ¸z¸‚¸  ¸O¸P¸[¸\¸ß‚½»»‚/// Whether the `newWidget` can be used to update an [Element] that currently
/// has the `oldWidget` as its configuration.
///
/// An element that uses a given widget as its configuration can be updated to
/// use another widget as its configuration if, and only if, the two widgets
/// have [runtimeType] and [key] properties that are [operator==].
///
/// If the widgets have no key (their key is null), then they are considered a
/// match if they have the same type, even if their children are completely
/// different. »»»  »(»0»/   ¼ì€¢¼÷¼÷  ½½½   °°	½’‚½’À RŞ•</// A widget that does not require mutable state.
///
/// A stateless widget is a widget that describes part of the user interface by
/// building a constellation of other widgets that describe the user interface
/// more concretely. The building process continues recursively until the
/// description of the user interface is fully concrete (e.g., consists
/// entirely of [RenderObjectWidget]s, which describe concrete [RenderObject]s).
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=wE7khGHVkYY}
///
/// Stateless widget are useful when the part of the user interface you are
/// describing does not depend on anything other than the configuration
/// information in the object itself and the [BuildContext] in which the widget
/// is inflated. For compositions that can change dynamically, e.g. due to
/// having an internal clock-driven state, or depending on some system state,
/// consider using [StatefulWidget].
///
/// ## Performance considerations
///
/// The [build] method of a stateless widget is typically only called in three
/// situations: the first time the widget is inserted in the tree, when the
/// widget's parent changes its configuration (see [Element.rebuild]), and when
/// an [InheritedWidget] it depends on changes.
///
/// If a widget's parent will regularly change the widget's configuration, or if
/// it depends on inherited widgets that frequently change, then it is important
/// to optimize the performance of the [build] method to maintain a fluid
/// rendering performance.
///
/// There are several techniques one can use to minimize the impact of
/// rebuilding a stateless widget:
///
///  * Minimize the number of nodes transitively created by the build method and
///    any widgets it creates. For example, instead of an elaborate arrangement
///    of [Row]s, [Column]s, [Padding]s, and [SizedBox]es to position a single
///    child in a particularly fancy manner, consider using just an [Align] or a
///    [CustomSingleChildLayout]. Instead of an intricate layering of multiple
///    [Container]s and with [Decoration]s to draw just the right graphical
///    effect, consider a single [CustomPaint] widget.
///
///  * Use `const` widgets where possible, and provide a `const` constructor for
///    the widget so that users of the widget can also do so.
///
///  * Consider refactoring the stateless widget into a stateful widget so that
///    it can use some of the techniques described at [StatefulWidget], such as
///    caching common parts of subtrees and using [GlobalKey]s when changing the
///    tree structure.
///
///  * If the widget is likely to get rebuilt frequently due to the use of
///    [InheritedWidget]s, consider refactoring the stateless widget into
///    multiple widgets, with the parts of the tree that change being pushed to
///    the leaves. For example instead of building a tree with four widgets, the
///    inner-most widget depending on the [Theme], consider factoring out the
///    part of the build function that builds the inner-most widget into its own
///    widget, so that only the inner-most widget needs to be rebuilt when the
///    theme changes.
/// {@template flutter.flutter.widgets.framework.prefer_const_over_helper}
///  * When trying to create a reusable piece of UI, prefer using a widget
///    rather than a helper method. For example, if there was a function used to
///    build a widget, a [State.setState] call would require Flutter to entirely
///    rebuild the returned wrapping widget. If a [Widget] was used instead,
///    Flutter would be able to efficiently re-render only those parts that
///    really need to be updated. Even better, if the created widget is `const`,
///    Flutter would short-circuit most of the rebuild work.
/// {@endtemplate}
///
/// This video gives more explanations on why `const` constructors are important
/// and why a [Widget] is better than a helper method.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=IOyq-eTRhvo}
///
/// {@tool snippet}
///
/// The following is a skeleton of a stateless widget subclass called `GreenFrog`.
///
/// Normally, widgets have more constructor arguments, each of which corresponds
/// to a `final` property.
///
/// ```dart
/// class GreenFrog extends StatelessWidget {
///   const GreenFrog({ super.key });
///
///   @override
///   Widget build(BuildContext context) {
///     return Container(color: const Color(0xFF2DBD3A));
///   }
/// }
/// ```
/// {@end-tool}
///
/// {@tool snippet}
///
/// This next example shows the more generic widget `Frog` which can be given
/// a color and a child:
///
/// ```dart
/// class Frog extends StatelessWidget {
///   const Frog({
///     super.key,
///     this.color = const Color(0xFF2DBD3A),
///     this.child,
///   });
///
///   final Color color;
///   final Widget? child;
///
///   @override
///   Widget build(BuildContext context) {
///     return ColoredBox(color: color, child: child);
///   }
/// }
/// ```
/// {@end-tool}
///
/// By convention, widget constructors only use named arguments. Also by
/// convention, the first argument is [key], and the last argument is `child`,
/// `children`, or the equivalent.
///
/// See also:
///
///  * [StatefulWidget] and [State], for widgets that can build differently
///    several times over their lifetime.
///  * [InheritedWidget], for widgets that introduce ambient state that can
///    be read by descendant widgets. À SKÀ S/ À S/À S> %/// Initializes [key] for subclasses.À S@	À SGÀ SF      À SP€ÛÀ TÀ T€/// Creates a [StatelessElement] to manage this widget's location in the tree.
///
/// It is uncommon for subclasses to override this method.  À SäÀ SåÀ T/‡ãÀ [öÀ [ö‡f/// Describes the part of the user interface represented by this widget.
///
/// The framework calls this method when this widget is inserted into the tree
/// in a given [BuildContext] and when the dependencies of this widget change
/// (e.g., an [InheritedWidget] referenced by this widget changes). This
/// method can potentially be called in every frame and should not have any side
/// effects beyond building a widget.
///
/// The framework replaces the subtree below this widget with the widget
/// returned by this method, either by updating the existing subtree or by
/// removing the subtree and inflating a new subtree, depending on whether the
/// widget returned by this method can update the root of the existing
/// subtree, as determined by calling [Widget.canUpdate].
///
/// Typically implementations return a newly created constellation of widgets
/// that are configured with information from this widget's constructor and
/// from the given [BuildContext].
///
/// The given [BuildContext] contains information about the location in the
/// tree at which this widget is being built. For example, the context
/// provides the set of inherited widgets for this location in the tree. A
/// given widget might be built with multiple different [BuildContext]
/// arguments over time if the widget is moved around the tree or if the
/// widget is inserted into the tree in multiple places at once.
///
/// The implementation of this method must only depend on:
///
/// * the fields of the widget, which themselves must not change over time,
///   and
/// * any ambient state obtained from the `context` using
///   [BuildContext.dependOnInheritedWidgetOfExactType].
///
/// If a widget's [build] method is to depend on anything else, use a
/// [StatefulWidget] instead.
///
/// See also:
///
///  * [StatelessWidget], which contains the discussion on performance considerations. À [üÀ \
À \	  À [âÀ [ã À \¨mÀ \À ×£±/// A widget that has mutable state.
///
/// State is information that (1) can be read synchronously when the widget is
/// built and (2) might change during the lifetime of the widget. It is the
/// responsibility of the widget implementer to ensure that the [State] is
/// promptly notified when such state changes, using [State.setState].
///
/// A stateful widget is a widget that describes part of the user interface by
/// building a constellation of other widgets that describe the user interface
/// more concretely. The building process continues recursively until the
/// description of the user interface is fully concrete (e.g., consists
/// entirely of [RenderObjectWidget]s, which describe concrete [RenderObject]s).
///
/// Stateful widgets are useful when the part of the user interface you are
/// describing can change dynamically, e.g. due to having an internal
/// clock-driven state, or depending on some system state. For compositions that
/// depend only on the configuration information in the object itself and the
/// [BuildContext] in which the widget is inflated, consider using
/// [StatelessWidget].
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=AqCMFXEmf3w}
///
/// [StatefulWidget] instances themselves are immutable and store their mutable
/// state either in separate [State] objects that are created by the
/// [createState] method, or in objects to which that [State] subscribes, for
/// example [Stream] or [ChangeNotifier] objects, to which references are stored
/// in final fields on the [StatefulWidget] itself.
///
/// The framework calls [createState] whenever it inflates a
/// [StatefulWidget], which means that multiple [State] objects might be
/// associated with the same [StatefulWidget] if that widget has been inserted
/// into the tree in multiple places. Similarly, if a [StatefulWidget] is
/// removed from the tree and later inserted in to the tree again, the framework
/// will call [createState] again to create a fresh [State] object, simplifying
/// the lifecycle of [State] objects.
///
/// A [StatefulWidget] keeps the same [State] object when moving from one
/// location in the tree to another if its creator used a [GlobalKey] for its
/// [key]. Because a widget with a [GlobalKey] can be used in at most one
/// location in the tree, a widget that uses a [GlobalKey] has at most one
/// associated element. The framework takes advantage of this property when
/// moving a widget with a global key from one location in the tree to another
/// by grafting the (unique) subtree associated with that widget from the old
/// location to the new location (instead of recreating the subtree at the new
/// location). The [State] objects associated with [StatefulWidget] are grafted
/// along with the rest of the subtree, which means the [State] object is reused
/// (instead of being recreated) in the new location. However, in order to be
/// eligible for grafting, the widget must be inserted into the new location in
/// the same animation frame in which it was removed from the old location.
///
/// ## Performance considerations
///
/// There are two primary categories of [StatefulWidget]s.
///
/// The first is one which allocates resources in [State.initState] and disposes
/// of them in [State.dispose], but which does not depend on [InheritedWidget]s
/// or call [State.setState]. Such widgets are commonly used at the root of an
/// application or page, and communicate with subwidgets via [ChangeNotifier]s,
/// [Stream]s, or other such objects. Stateful widgets following such a pattern
/// are relatively cheap (in terms of CPU and GPU cycles), because they are
/// built once then never update. They can, therefore, have somewhat complicated
/// and deep build methods.
///
/// The second category is widgets that use [State.setState] or depend on
/// [InheritedWidget]s. These will typically rebuild many times during the
/// application's lifetime, and it is therefore important to minimize the impact
/// of rebuilding such a widget. (They may also use [State.initState] or
/// [State.didChangeDependencies] and allocate resources, but the important part
/// is that they rebuild.)
///
/// There are several techniques one can use to minimize the impact of
/// rebuilding a stateful widget:
///
///  * Push the state to the leaves. For example, if your page has a ticking
///    clock, rather than putting the state at the top of the page and
///    rebuilding the entire page each time the clock ticks, create a dedicated
///    clock widget that only updates itself.
///
///  * Minimize the number of nodes transitively created by the build method and
///    any widgets it creates. Ideally, a stateful widget would only create a
///    single widget, and that widget would be a [RenderObjectWidget].
///    (Obviously this isn't always practical, but the closer a widget gets to
///    this ideal, the more efficient it will be.)
///
///  * If a subtree does not change, cache the widget that represents that
///    subtree and re-use it each time it can be used. To do this, assign
///    a widget to a `final` state variable and re-use it in the build method. It
///    is massively more efficient for a widget to be re-used than for a new (but
///    identically-configured) widget to be created. Another caching strategy
///    consists in extracting the mutable part of the widget into a [StatefulWidget]
///    which accepts a child parameter.
///
///  * Use `const` widgets where possible. (This is equivalent to caching a
///    widget and re-using it.)
///
///  * Avoid changing the depth of any created subtrees or changing the type of
///    any widgets in the subtree. For example, rather than returning either the
///    child or the child wrapped in an [IgnorePointer], always wrap the child
///    widget in an [IgnorePointer] and control the [IgnorePointer.ignoring]
///    property. This is because changing the depth of the subtree requires
///    rebuilding, laying out, and painting the entire subtree, whereas just
///    changing the property will require the least possible change to the
///    render tree (in the case of [IgnorePointer], for example, no layout or
///    repaint is necessary at all).
///
///  * If the depth must be changed for some reason, consider wrapping the
///    common parts of the subtrees in widgets that have a [GlobalKey] that
///    remains consistent for the life of the stateful widget. (The
///    [KeyedSubtree] widget may be useful for this purpose if no other widget
///    can conveniently be assigned the key.)
///
/// {@macro flutter.flutter.widgets.framework.prefer_const_over_helper}
///
/// This video gives more explanations on why `const` constructors are important
/// and why a [Widget] is better than a helper method.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=IOyq-eTRhvo}
///
/// For more details on the mechanics of rebuilding a widget, see
/// the discussion at [Element.rebuild].
///
/// {@tool snippet}
///
/// This is a skeleton of a stateful widget subclass called `YellowBird`.
///
/// In this example, the [State] has no actual state. State is normally
/// represented as private member fields. Also, normally widgets have more
/// constructor arguments, each of which corresponds to a `final` property.
///
/// ```dart
/// class YellowBird extends StatefulWidget {
///   const YellowBird({ super.key });
///
///   @override
///   State<YellowBird> createState() => _YellowBirdState();
/// }
///
/// class _YellowBirdState extends State<YellowBird> {
///   @override
///   Widget build(BuildContext context) {
///     return Container(color: const Color(0xFFFFE306));
///   }
/// }
/// ```
/// {@end-tool}
/// {@tool snippet}
///
/// This example shows the more generic widget `Bird` which can be given a
/// color and a child, and which has some internal state with a method that
/// can be called to mutate it:
///
/// ```dart
/// class Bird extends StatefulWidget {
///   const Bird({
///     super.key,
///     this.color = const Color(0xFFFFE306),
///     this.child,
///   });
///
///   final Color color;
///   final Widget? child;
///
///   @override
///   State<Bird> createState() => _BirdState();
/// }
///
/// class _BirdState extends State<Bird> {
///   double _size = 1.0;
///
///   void grow() {
///     setState(() { _size += 0.1; });
///   }
///
///   @override
///   Widget build(BuildContext context) {
///     return Container(
///       color: widget.color,
///       transform: Matrix4.diagonal3Values(_size, _size, 1.0),
///       child: widget.child,
///     );
///   }
/// }
/// ```
/// {@end-tool}
///
/// By convention, widget constructors only use named arguments. Also by
/// convention, the first argument is [key], and the last argument is `child`,
/// `children`, or the equivalent.
///
/// See also:
///
///  * [State], where the logic behind a [StatefulWidget] is hosted.
///  * [StatelessWidget], for widgets that always build the same way given a
///    particular configuration and ambient state.
///  * [InheritedWidget], for widgets that introduce ambient state that can
///    be read by descendant widgets. À ùJÀ €' À €'À €5 %/// Initializes [key] for subclasses.À €7	À €>À €=      À €G€ØÀ €öÀ €ö€Œ/// Creates a [StatefulElement] to manage this widget's location in the tree.
///
/// It is uncommon for subclasses to override this method.  À €ÚÀ €ÛÀ #ƒ^À „sÀ „sƒ/// Creates the mutable state for this widget at a given location in the tree.
///
/// Subclasses should override this method to return a newly created
/// instance of their associated [State] subclass:
///
/// ```dart
/// @override
/// State<SomeWidget> createState() => _SomeWidgetState();
/// ```
///
/// The framework can call this method multiple times over the lifetime of
/// a [StatefulWidget]. For example, if the widget is inserted into the tree
/// in multiple locations, the framework will create a separate [State] object
/// for each location. Similarly, if the widget is removed from the tree and
/// later inserted into the tree again, the framework will call [createState]
/// again to create a fresh [State] object, simplifying the lifecycle of
/// [State] objects.  À „UÀ „VÀ „bÀ „c À ‡BÀ }À ‡BÀ K–ç/// The logic and internal state for a [StatefulWidget].
///
/// State is information that (1) can be read synchronously when the widget is
/// built and (2) might change during the lifetime of the widget. It is the
/// responsibility of the widget implementer to ensure that the [State] is
/// promptly notified when such state changes, using [State.setState].
///
/// [State] objects are created by the framework by calling the
/// [StatefulWidget.createState] method when inflating a [StatefulWidget] to
/// insert it into the tree. Because a given [StatefulWidget] instance can be
/// inflated multiple times (e.g., the widget is incorporated into the tree in
/// multiple places at once), there might be more than one [State] object
/// associated with a given [StatefulWidget] instance. Similarly, if a
/// [StatefulWidget] is removed from the tree and later inserted in to the tree
/// again, the framework will call [StatefulWidget.createState] again to create
/// a fresh [State] object, simplifying the lifecycle of [State] objects.
///
/// [State] objects have the following lifecycle:
///
///  * The framework creates a [State] object by calling
///    [StatefulWidget.createState].
///  * The newly created [State] object is associated with a [BuildContext].
///    This association is permanent: the [State] object will never change its
///    [BuildContext]. However, the [BuildContext] itself can be moved around
///    the tree along with its subtree. At this point, the [State] object is
///    considered [mounted].
///  * The framework calls [initState]. Subclasses of [State] should override
///    [initState] to perform one-time initialization that depends on the
///    [BuildContext] or the widget, which are available as the [context] and
///    [widget] properties, respectively, when the [initState] method is
///    called.
///  * The framework calls [didChangeDependencies]. Subclasses of [State] should
///    override [didChangeDependencies] to perform initialization involving
///    [InheritedWidget]s. If [BuildContext.dependOnInheritedWidgetOfExactType] is
///    called, the [didChangeDependencies] method will be called again if the
///    inherited widgets subsequently change or if the widget moves in the tree.
///  * At this point, the [State] object is fully initialized and the framework
///    might call its [build] method any number of times to obtain a
///    description of the user interface for this subtree. [State] objects can
///    spontaneously request to rebuild their subtree by calling their
///    [setState] method, which indicates that some of their internal state
///    has changed in a way that might impact the user interface in this
///    subtree.
///  * During this time, a parent widget might rebuild and request that this
///    location in the tree update to display a new widget with the same
///    [runtimeType] and [Widget.key]. When this happens, the framework will
///    update the [widget] property to refer to the new widget and then call the
///    [didUpdateWidget] method with the previous widget as an argument. [State]
///    objects should override [didUpdateWidget] to respond to changes in their
///    associated widget (e.g., to start implicit animations). The framework
///    always calls [build] after calling [didUpdateWidget], which means any
///    calls to [setState] in [didUpdateWidget] are redundant. (See also the
///    discussion at [Element.rebuild].)
///  * During development, if a hot reload occurs (whether initiated from the
///    command line `flutter` tool by pressing `r`, or from an IDE), the
///    [reassemble] method is called. This provides an opportunity to
///    reinitialize any data that was prepared in the [initState] method.
///  * If the subtree containing the [State] object is removed from the tree
///    (e.g., because the parent built a widget with a different [runtimeType]
///    or [Widget.key]), the framework calls the [deactivate] method. Subclasses
///    should override this method to clean up any links between this object
///    and other elements in the tree (e.g. if you have provided an ancestor
///    with a pointer to a descendant's [RenderObject]).
///  * At this point, the framework might reinsert this subtree into another
///    part of the tree. If that happens, the framework will ensure that it
///    calls [build] to give the [State] object a chance to adapt to its new
///    location in the tree. If the framework does reinsert this subtree, it
///    will do so before the end of the animation frame in which the subtree was
///    removed from the tree. For this reason, [State] objects can defer
///    releasing most resources until the framework calls their [dispose]
///    method.
///  * If the framework does not reinsert this subtree by the end of the current
///    animation frame, the framework will call [dispose], which indicates that
///    this [State] object will never build again. Subclasses should override
///    this method to release any resources retained by this object (e.g.,
///    stop any active animations).
///  * After the framework calls [dispose], the [State] object is considered
///    unmounted and the [mounted] property is false. It is an error to call
///    [setState] at this point. This stage of the lifecycle is terminal: there
///    is no way to remount a [State] object that has been disposed.
///
/// See also:
///
///  * [StatefulWidget], where the current configuration of a [State] is hosted,
///    and whose documentation has sample code for [State].
///  * [StatelessWidget], for widgets that always build the same way given a
///    particular configuration and ambient state.
///  * [InheritedWidget], for widgets that introduce ambient state that can
///    be read by descendant widgets.
///  * [Widget], for an overview of widgets in general.À QÀ QÀ Q À  ¨
À  «À  «  À  · À ¡©À ¡©€Ù/// The current stage in the lifecycle for this state object.
///
/// This field is used by the framework when asserts are enabled to verify
/// that [State] objects move through their lifecycle in an orderly fashion.À ¡ÀÀ ¡ÏÀ ¡ĞÀ ¦EÀ ¦VÀ ¦V  À ƒ‚"À  ’À  ’ö/// The current configuration.
///
/// A [State] object's configuration is the corresponding [StatefulWidget]
/// instance. This property is initialized by the framework before calling
/// [initState]. If the parent updates this location in the tree to a new
/// widget with the same [runtimeType] and [Widget.key] as the current
/// configuration, the framework will update this property to refer to the new
/// widget and then call [didUpdateWidget], passing the old configuration as
/// an argument.   À ¢ƒ³À ¤¢À ¤¢î/// The location in the tree where this widget builds.
///
/// The framework associates [State] objects with a [BuildContext] after
/// creating them with [StatefulWidget.createState] and before calling
/// [initState]. The association is permanent: the [State] object will never
/// change its [BuildContext]. However, the [BuildContext] itself can be moved
/// around the tree.
///
/// After calling [dispose], the framework severs the [State] object's
/// connection with the [BuildContext].   À ¦cùÀ ¨@À ¨@Á/// Whether this [State] object is currently in a tree.
///
/// After creating a [State] object and before calling [initState], the
/// framework "mounts" the [State] object by associating it with a
/// [BuildContext]. The [State] object remains mounted until the framework
/// calls [dispose], after which time the framework will never ask the [State]
/// object to [build] again.
///
/// It is an error to call [setState] unless [mounted] is true.    À ¡Ü€®À ¢XÀ ¢Xr/// Verifies that the [State] that was created is one that expects to be
/// created for that particular [Widget]. À ¢lÀ ¢tÀ ¢s   À ¨`†À ®RÀ ®R…/// Called when this object is inserted into the tree.
///
/// The framework will call this method exactly once for each [State] object
/// it creates.
///
/// Override this method to perform initialization that depends on the
/// location at which this object was inserted into the tree (i.e., [context])
/// or on the widget used to configure this object (i.e., [widget]).
///
/// {@template flutter.widgets.State.initState}
/// If a [State]'s [build] method depends on an object that can itself
/// change state, for example a [ChangeNotifier] or [Stream], or some
/// other object to which one can subscribe to receive notifications, then
/// be sure to subscribe and unsubscribe properly in [initState],
/// [didUpdateWidget], and [dispose]:
///
///  * In [initState], subscribe to the object.
///  * In [didUpdateWidget] unsubscribe from the old object and subscribe
///    to the new one if the updated widget configuration requires
///    replacing the object.
///  * In [dispose], unsubscribe from the object.
///
/// {@endtemplate}
///
/// You should not use [BuildContext.dependOnInheritedWidgetOfExactType] from this
/// method. However, [didChangeDependencies] will be called immediately
/// following this method, and [BuildContext.dependOnInheritedWidgetOfExactType] can
/// be used there.
///
/// Implementations of this method should start with a call to the inherited
/// method, as in `super.initState()`.  À ®/À ®0À ®<À ®=À ®å„&À ²âÀ ²âƒ¯/// Called whenever the widget configuration changes.
///
/// If the parent widget rebuilds and requests that this location in the tree
/// update to display a new widget with the same [runtimeType] and
/// [Widget.key], the framework will update the [widget] property of this
/// [State] object to refer to the new widget and then call this method
/// with the previous widget as an argument.
///
/// Override this method to respond when the [widget] changes (e.g., to start
/// implicit animations).
///
/// The framework always calls [build] after calling [didUpdateWidget], which
/// means any calls to [setState] in [didUpdateWidget] are redundant.
///
/// {@macro flutter.widgets.State.initState}
///
/// Implementations of this method should start with a call to the inherited
/// method, as in `super.didUpdateWidget(oldWidget)`.
///
/// _See the discussion at [Element.rebuild] for more information on when this
/// method is called._ À ²òÀ ²ÿÀ ²ş  À ²¿À ²ÀÀ ²ĞÀ ²ÑÀ ³çÀ ´çÀ ´ç/// {@macro flutter.widgets.Element.reassemble}
///
/// In addition to this method being invoked, it is guaranteed that the
/// [build] method will be invoked when a reassemble is signaled. Most
/// widgets therefore do not need to do anything in the [reassemble] method.
///
/// See also:
///
///  * [Element.reassemble]
///  * [BindingBase.reassembleApplication]
///  * [Image], which uses this to reload images.  À ´ÄÀ ´ÅÀ ´ÑÀ ´ÒÀ ´ú•À È‡À È‡’¦/// Notify the framework that the internal state of this object has changed.
///
/// Whenever you change the internal state of a [State] object, make the
/// change in a function that you pass to [setState]:
///
/// ```dart
/// setState(() { _myState = newValue; });
/// ```
///
/// The provided callback is immediately called synchronously. It must not
/// return a future (the callback cannot be `async`), since then it would be
/// unclear when the state was actually being set.
///
/// Calling [setState] notifies the framework that the internal state of this
/// object has changed in a way that might impact the user interface in this
/// subtree, which causes the framework to schedule a [build] for this [State]
/// object.
///
/// If you just change the state directly without calling [setState], the
/// framework might not schedule a [build] and the user interface for this
/// subtree might not be updated to reflect the new state.
///
/// Generally it is recommended that the [setState] method only be used to
/// wrap the actual changes to the state, not any computation that might be
/// associated with the change. For example, here a value used by the [build]
/// function is incremented, and then the change is written to disk, but only
/// the increment is wrapped in the [setState]:
///
/// ```dart
/// Future<void> _incrementCounter() async {
///   setState(() {
///     _counter++;
///   });
///   Directory directory = await getApplicationDocumentsDirectory(); // from path_provider package
///   final String dirName = directory.path;
///   await File('$dirName/counter.txt').writeAsString('$_counter');
/// }
/// ```
///
/// Sometimes, the changed state is in some other object not owned by the
/// widget [State], but the widget nonetheless needs to be updated to react to
/// the new state. This is especially common with [Listenable]s, such as
/// [AnimationController]s.
///
/// In such cases, it is good practice to leave a comment in the callback
/// passed to [setState] that explains what state changed:
///
/// ```dart
/// void _update() {
///   setState(() { /* The animation changed. */ });
/// }
/// //...
/// animation.addListener(_update);
/// ```
///
/// It is an error to call this method after the framework calls [dispose].
/// You can determine whether it is legal to call this method by checking
/// whether the [mounted] property is true. That said, it is better practice
/// to cancel whatever work might trigger the [setState] rather than merely
/// checking for [mounted] before calling [setState], as otherwise CPU cycles
/// will be wasted.
///
/// ## Design discussion
///
/// The original version of this API was a method called `markNeedsBuild`, for
/// consistency with [RenderObject.markNeedsLayout],
/// [RenderObject.markNeedsPaint], _et al_.
///
/// However, early user testing of the Flutter framework revealed that people
/// would call `markNeedsBuild()` much more often than necessary. Essentially,
/// people used it like a good luck charm, any time they weren't sure if they
/// needed to call it, they would call it, just in case.
///
/// Naturally, this led to performance issues in applications.
///
/// When the API was changed to take a callback instead, this practice was
/// greatly reduced. One hypothesis is that prompting developers to actually
/// update their state in a callback caused developers to think more carefully
/// about what exactly was being updated, and thus improved their understanding
/// of the appropriate times to call the method.
///
/// In practice, the [setState] method's implementation is trivial: it calls
/// the provided callback synchronously, then calls [Element.markNeedsBuild].
///
/// ## Performance considerations
///
/// There is minimal _direct_ overhead to calling this function, and as it is
/// expected to be called at most once per frame, the overhead is irrelevant
/// anyway. Nonetheless, it is best to avoid calling this function redundantly
/// (e.g. in a tight loop), as it does involve creating a closure and calling
/// it. The method is idempotent, there is no benefit to calling it more than
/// once per [State] per frame.
///
/// The _indirect_ cost of causing this function, however, is high: it causes
/// the widget to rebuild, possibly triggering rebuilds for the entire subtree
/// rooted at this widget, and further triggering a relayout and repaint of
/// the entire corresponding [RenderObject] subtree.
///
/// For this reason, this method should only be called when the [build] method
/// will, as a result of whatever state change was detected, change its result
/// meaningfully.
///
/// See also:
///
///  * [StatefulWidget], the API documentation for which has a section on
///    performance considerations that are relevant here. À ÈÀ ÈÀ È  À ÈuÀ ÈvÀ Ó“…íÀ ÙqÀ Ùq…†/// Called when this object is removed from the tree.
///
/// The framework calls this method whenever it removes this [State] object
/// from the tree. In some cases, the framework will reinsert the [State]
/// object into another part of the tree (e.g., if the subtree containing this
/// [State] object is grafted from one location in the tree to another due to
/// the use of a [GlobalKey]). If that happens, the framework will call
/// [activate] to give the [State] object a chance to reacquire any resources
/// that it released in [deactivate]. It will then also call [build] to give
/// the [State] object a chance to adapt to its new location in the tree. If
/// the framework does reinsert this subtree, it will do so before the end of
/// the animation frame in which the subtree was removed from the tree. For
/// this reason, [State] objects can defer releasing most resources until the
/// framework calls their [dispose] method.
///
/// Subclasses should override this method to clean up any links between
/// this object and other elements in the tree (e.g. if you have provided an
/// ancestor with a pointer to a descendant's [RenderObject]).
///
/// Implementations of this method should end with a call to the inherited
/// method, as in `super.deactivate()`.
///
/// See also:
///
///  * [dispose], which is called after [deactivate] if the widget is removed
///    from the tree permanently.  À ÙNÀ ÙOÀ Ù[À Ù\À Ù„†¨À àÀ à†;/// Called when this object is reinserted into the tree after having been
/// removed via [deactivate].
///
/// In most cases, after a [State] object has been deactivated, it is _not_
/// reinserted into the tree, and its [dispose] method will be called to
/// signal that it is ready to be garbage collected.
///
/// In some cases, however, after a [State] object has been deactivated, the
/// framework will reinsert it into another part of the tree (e.g., if the
/// subtree containing this [State] object is grafted from one location in
/// the tree to another due to the use of a [GlobalKey]). If that happens,
/// the framework will call [activate] to give the [State] object a chance to
/// reacquire any resources that it released in [deactivate]. It will then
/// also call [build] to give the object a chance to adapt to its new
/// location in the tree. If the framework does reinsert this subtree, it
/// will do so before the end of the animation frame in which the subtree was
/// removed from the tree. For this reason, [State] objects can defer
/// releasing most resources until the framework calls their [dispose] method.
///
/// The framework does not call this method the first time a [State] object
/// is inserted into the tree. Instead, the framework calls [initState] in
/// that situation.
///
/// Implementations of this method should start with a call to the inherited
/// method, as in `super.activate()`.
///
/// See also:
///
///  * [Element.activate], the corresponding method when an element
///    transitions from the "inactive" to the "active" lifecycle state.  À ßüÀ ßıÀ à	À à
À à0ˆäÀ è9À è9‡‰/// Called when this object is removed from the tree permanently.
///
/// The framework calls this method when this [State] object will never
/// build again. After the framework calls [dispose], the [State] object is
/// considered unmounted and the [mounted] property is false. It is an error
/// to call [setState] at this point. This stage of the lifecycle is terminal:
/// there is no way to remount a [State] object that has been disposed.
///
/// Subclasses should override this method to release any resources retained
/// by this object (e.g., stop any active animations).
///
/// {@macro flutter.widgets.State.initState}
///
/// Implementations of this method should end with a call to the inherited
/// method, as in `super.dispose()`.
///
/// ## Caveats
///
/// This method is _not_ invoked at times where a developer might otherwise
/// expect it, such as application shutdown or dismissal via platform
/// native methods.
///
/// ### Application shutdown
///
/// There is no way to predict when application shutdown will happen. For
/// example, a user's battery could catch fire, or the user could drop the
/// device into a swimming pool, or the operating system could unilaterally
/// terminate the application process due to memory pressure.
///
/// Applications are responsible for ensuring that they are well-behaved
/// even in the face of a rapid unscheduled termination.
///
/// To artificially cause the entire widget tree to be disposed, consider
/// calling [runApp] with a widget such as [SizedBox.shrink].
///
/// To listen for platform shutdown messages (and other lifecycle changes),
/// consider the [AppLifecycleListener] API.
///
/// {@macro flutter.widgets.runApp.dismissal}
///
/// See the method used to bootstrap the app (e.g. [runApp] or [runWidget])
/// for suggestions on how to release resources more eagerly.
///
/// See also:
///
///  * [deactivate], which is called prior to [dispose].  À èÀ èÀ è#À è$À é•À şÀ ş“ô/// Describes the part of the user interface represented by this widget.
///
/// The framework calls this method in a number of different situations. For
/// example:
///
///  * After calling [initState].
///  * After calling [didUpdateWidget].
///  * After receiving a call to [setState].
///  * After a dependency of this [State] object changes (e.g., an
///    [InheritedWidget] referenced by the previous [build] changes).
///  * After calling [deactivate] and then reinserting the [State] object into
///    the tree at another location.
///
/// This method can potentially be called in every frame and should not have
/// any side effects beyond building a widget.
///
/// The framework replaces the subtree below this widget with the widget
/// returned by this method, either by updating the existing subtree or by
/// removing the subtree and inflating a new subtree, depending on whether the
/// widget returned by this method can update the root of the existing
/// subtree, as determined by calling [Widget.canUpdate].
///
/// Typically implementations return a newly created constellation of widgets
/// that are configured with information from this widget's constructor, the
/// given [BuildContext], and the internal state of this [State] object.
///
/// The given [BuildContext] contains information about the location in the
/// tree at which this widget is being built. For example, the context
/// provides the set of inherited widgets for this location in the tree. The
/// [BuildContext] argument is always the same as the [context] property of
/// this [State] object and will remain the same for the lifetime of this
/// object. The [BuildContext] argument is provided redundantly here so that
/// this method matches the signature for a [WidgetBuilder].
///
/// ## Design discussion
///
/// ### Why is the [build] method on [State], and not [StatefulWidget]?
///
/// Putting a `Widget build(BuildContext context)` method on [State] rather
/// than putting a `Widget build(BuildContext context, State state)` method
/// on [StatefulWidget] gives developers more flexibility when subclassing
/// [StatefulWidget].
///
/// For example, [AnimatedWidget] is a subclass of [StatefulWidget] that
/// introduces an abstract `Widget build(BuildContext context)` method for its
/// subclasses to implement. If [StatefulWidget] already had a [build] method
/// that took a [State] argument, [AnimatedWidget] would be forced to provide
/// its [State] object to subclasses even though its [State] object is an
/// internal implementation detail of [AnimatedWidget].
///
/// Conceptually, [StatelessWidget] could also be implemented as a subclass of
/// [StatefulWidget] in a similar manner. If the [build] method were on
/// [StatefulWidget] rather than [State], that would not be possible anymore.
///
/// Putting the [build] function on [State] rather than [StatefulWidget] also
/// helps avoid a category of bugs related to closures implicitly capturing
/// `this`. If you defined a closure in a [build] function on a
/// [StatefulWidget], that closure would implicitly capture `this`, which is
/// the current widget instance, and would have the (immutable) fields of that
/// instance in scope:
///
/// ```dart
/// // (this is not valid Flutter code)
/// class MyButton extends StatefulWidgetX {
///   MyButton({super.key, required this.color});
///
///   final Color color;
///
///   @override
///   Widget build(BuildContext context, State state) {
///     return SpecialWidget(
///       handler: () { print('color: $color'); },
///     );
///   }
/// }
/// ```
///
/// For example, suppose the parent builds `MyButton` with `color` being blue,
/// the `$color` in the print function refers to blue, as expected. Now,
/// suppose the parent rebuilds `MyButton` with green. The closure created by
/// the first build still implicitly refers to the original widget and the
/// `$color` still prints blue even through the widget has been updated to
/// green; should that closure outlive its widget, it would print outdated
/// information.
///
/// In contrast, with the [build] function on the [State] object, closures
/// created during [build] implicitly capture the [State] instance instead of
/// the widget instance:
///
/// ```dart
/// class MyButton extends StatefulWidget {
///   const MyButton({super.key, this.color = Colors.teal});
///
///   final Color color;
///   // ...
/// }
///
/// class MyButtonState extends State<MyButton> {
///   // ...
///   @override
///   Widget build(BuildContext context) {
///     return SpecialWidget(
///       handler: () { print('color: ${widget.color}'); },
///     );
///   }
/// }
/// ```
///
/// Now when the parent rebuilds `MyButton` with green, the closure created by
/// the first build still refers to [State] object, which is preserved across
/// rebuilds, but the framework has updated that [State] object's [widget]
/// property to refer to the new `MyButton` instance and `${widget.color}`
/// prints green, as expected.
///
/// See also:
///
///  * [StatefulWidget], which contains the discussion on performance considerations. À şÀ şÀ ş  À ı÷À ıøÀ ş+ƒ?ÀPÀP‚å/// Called when a dependency of this [State] object changes.
///
/// For example, if the previous call to [build] referenced an
/// [InheritedWidget] that later changed, the framework would call this
/// method to notify this object about the change.
///
/// This method is also called immediately after [initState]. It is safe to
/// call [BuildContext.dependOnInheritedWidgetOfExactType] from this method.
///
/// Subclasses rarely override this method because the framework always
/// calls [build] after a dependency changes. Some subclasses do override
/// this method because they need to do some expensive work (e.g., network
/// fetches) when their dependencies change, and that work would be too
/// expensive to do for every build.  À-À.À:À;Àn‚.ÀÀ  À“&À°À¯  ÀnÀoÀ *À +ÀH…JÀHÀƒ'/// A widget that has a child widget provided to it, instead of building a new
/// widget.
///
/// Useful as a base class for other widgets, such as [InheritedWidget] and
/// [ParentDataWidget].
///
/// See also:
///
///  * [InheritedWidget], for widgets that introduce ambient state that can
///    be read by descendant widgets.
///  * [ParentDataWidget], for widgets that populate the
///    [RenderObject.parentData] slot of their child's [RenderObject] to
///    configure the parent widget's layout.
///  * [StatefulWidget] and [State], for widgets that can build differently
///    several times over their lifetime.
///  * [StatelessWidget], for widgets that always build the same way given a
///    particular configuration and ambient state.
///  * [Widget], for an overview of widgets in general. ÀnÀŞ ÀŞÀé 7/// Creates a widget that has exactly one child widget.Àë	ÀòÀñ  ÀöÀÀ   ÀÀ	ŠÀ	Š^/// The widget below this widget in the tree.
///
/// {@template flutter.widgets.ProxyWidget.child}
/// This widget can only have one child. To lay out multiple children, let this
/// widget's child be a widget such as [Row], [Column], or [Stack], which have a
/// `children` property, and then provide the children to that widget.
/// {@endtemplate}     À	”œ1À	”Àì‡H/// Base class for widgets that hook [ParentData] information to children of
/// [RenderObjectWidget]s.
///
/// This can be used to provide per-child configuration for
/// [RenderObjectWidget]s with more than one child. For example, [Stack] uses
/// the [Positioned] parent data widget to position each child.
///
/// A [ParentDataWidget] is specific to a particular kind of [ParentData]. That
/// class is `T`, the [ParentData] type argument.
///
/// {@tool snippet}
///
/// This example shows how you would build a [ParentDataWidget] to configure a
/// `FrogJar` widget's children by specifying a [Size] for each one.
///
/// ```dart
/// class FrogSize extends ParentDataWidget<FrogJarParentData> {
///   const FrogSize({
///     super.key,
///     required this.size,
///     required super.child,
///   });
///
///   final Size size;
///
///   @override
///   void applyParentData(RenderObject renderObject) {
///     final FrogJarParentData parentData = renderObject.parentData! as FrogJarParentData;
///     if (parentData.size != size) {
///       parentData.size = size;
///       final RenderFrogJar targetParent = renderObject.parent! as RenderFrogJar;
///       targetParent.markNeedsLayout();
///     }
///   }
///
///   @override
///   Type get debugTypicalAncestorWidgetClass => FrogJar;
/// }
/// ```
/// {@end-tool}
///
/// See also:
///
///  * [RenderObject], the superclass for layout algorithms.
///  * [RenderObject.parentData], the slot that this class configures.
///  * [ParentData], the superclass of the data that will be placed in
///    [RenderObject.parentData] slots. The `T` type parameter for
///    [ParentDataWidget] is a [ParentData].
///  * [RenderObjectWidget], the class for widgets that wrap [RenderObject]s.
///  * [StatefulWidget] and [State], for widgets that can build differently
///    several times over their lifetime.ÀıÀıÀıÀ+€ÓÀÊ ÀÊÀÚ €”/// Abstract const constructor. This constructor enables subclasses to provide
/// const constructors so that they can be used in const expressions.ÀÜ	ÀãÀâ  ÀçÀ÷Àö    À›ƒíÀhÀhƒ—/// Describes the [RenderObjectWidget] that is typically used to set up the
/// [ParentData] that [applyParentData] will write to.
///
/// This is only used in error messages to tell users what widget typically
/// wraps this [ParentDataWidget] through
/// [debugTypicalAncestorWidgetDescription].
///
/// ## Implementations
///
/// The returned Type should describe a subclass of `RenderObjectWidget`. If
/// more than one Type is supported, use
/// [debugTypicalAncestorWidgetDescription], which typically inserts this
/// value but can be overridden to describe more than one Type.
///
/// ```dart
///   @override
///   Type get debugTypicalAncestorWidgetClass => FrogJar;
/// ```
///
/// If the "typical" parent is generic (`Foo<T>`), consider specifying either
/// a typical type argument (e.g. `Foo<int>` if `int` is typically how the
/// type is specialized), or specifying the upper bound (e.g. `Foo<Object?>`).   ÀŒòÀ2À2Š/// Describes the [RenderObjectWidget] that is typically used to set up the
/// [ParentData] that [applyParentData] will write to.
///
/// This is only used in error messages to tell users what widget typically
/// wraps this [ParentDataWidget].
///
/// Returns [debugTypicalAncestorWidgetClass] by default as a String. This can
/// be overridden to describe more than one Type of valid parent.    ÀOÀ#À#   ÀÀÀU‚BÀşÀş‘/// Checks if this widget can apply its parent data to the provided
/// `renderObject`.
///
/// The [RenderObject.parentData] of the provided `renderObject` is
/// typically set up by an ancestor [RenderObjectWidget] of the type returned
/// by [debugTypicalAncestorWidgetClass].
///
/// This is called just before [applyParentData] is invoked with the same
/// [RenderObject] provided to that method. ÀÀ%À$   À‚…%ÀœÀœ  ÀÈÀŞÀİ  Àí%ÀÀ  ÀÀ*À)   À«„cÀ#ãÀ#ã„/// Write the data from this widget into the given render object's parent data.
///
/// The framework calls this function whenever it detects that the
/// [RenderObject] associated with the [child] has outdated
/// [RenderObject.parentData]. For example, if the render object was recently
/// inserted into the render tree, the render object's parent data might not
/// match the data in this widget.
///
/// Subclasses are expected to override this function to copy data from their
/// fields into the [RenderObject.parentData] field of the given render
/// object. The render object's parent is guaranteed to have been created by a
/// widget of type `T`, which usually means that this function can assume that
/// the render object's parent data object inherits from a particular class.
///
/// If this function modifies data that can change the parent's layout or
/// painting, this function is responsible for calling
/// [RenderObject.markNeedsLayout] or [RenderObject.markNeedsPaint] on the
/// parent, as appropriate. À#óÀ$À$   À#ÑÀ#ÒÀ$±À%¡À%¡h/// Whether the [ParentDataElement.applyWidgetOutOfTurn] method is allowed
/// with this widget.
///
/// This should only return true if this widget represents a [ParentData]
/// configuration that will have no impact on the layout or paint phase.
///
/// See also:
///
///  * [ParentDataElement.applyWidgetOutOfTurn], which verifies this in debug
///    mode.  À%À% À%Ç—ıÀ%ÇÀ9‹“´/// Base class for widgets that efficiently propagate information down the tree.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=og-vJqLzg2c}
///
/// To obtain the nearest instance of a particular type of inherited widget from
/// a build context, use [BuildContext.dependOnInheritedWidgetOfExactType].
///
/// Inherited widgets, when referenced in this way, will cause the consumer to
/// rebuild when the inherited widget itself changes state.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=Zbm3hjPjQMk}
///
/// {@tool snippet}
///
/// The following is a skeleton of an inherited widget called `FrogColor`:
///
/// ```dart
/// class FrogColor extends InheritedWidget {
///   const FrogColor({
///     super.key,
///     required this.color,
///     required super.child,
///   });
///
///   final Color color;
///
///   static FrogColor? maybeOf(BuildContext context) {
///     return context.dependOnInheritedWidgetOfExactType<FrogColor>();
///   }
///
///   static FrogColor of(BuildContext context) {
///     final FrogColor? result = maybeOf(context);
///     assert(result != null, 'No FrogColor found in context');
///     return result!;
///   }
///
///   @override
///   bool updateShouldNotify(FrogColor oldWidget) => color != oldWidget.color;
/// }
/// ```
/// {@end-tool}
///
/// ## Implementing the `of` and `maybeOf` methods
///
/// The convention is to provide two static methods, `of` and `maybeOf`, on the
/// [InheritedWidget] which call
/// [BuildContext.dependOnInheritedWidgetOfExactType]. This allows the class to
/// define its own fallback logic in case there isn't a widget in scope.
///
/// The `of` method typically returns a non-nullable instance and asserts if the
/// [InheritedWidget] isn't found, and the `maybeOf` method returns a nullable
/// instance, and returns null if the [InheritedWidget] isn't found. The `of`
/// method is typically implemented by calling `maybeOf` internally.
///
/// Sometimes, the `of` and `maybeOf` methods return some data rather than the
/// inherited widget itself; for example, in this case it could have returned a
/// [Color] instead of the `FrogColor` widget.
///
/// Occasionally, the inherited widget is an implementation detail of another
/// class, and is therefore private. The `of` and `maybeOf` methods in that case
/// are typically implemented on the public class instead. For example, [Theme]
/// is implemented as a [StatelessWidget] that builds a private inherited
/// widget; [Theme.of] looks for that private inherited widget using
/// [BuildContext.dependOnInheritedWidgetOfExactType] and then returns the
/// [ThemeData] inside it.
///
/// ## Calling the `of` or `maybeOf` methods
///
/// When using the `of` or `maybeOf` methods, the `context` must be a descendant
/// of the [InheritedWidget], meaning it must be "below" the [InheritedWidget]
/// in the tree.
///
/// {@tool snippet}
///
/// In this example, the `context` used is the one from the [Builder], which is
/// a child of the `FrogColor` widget, so this works.
///
/// ```dart
/// // continuing from previous example...
/// class MyPage extends StatelessWidget {
///   const MyPage({super.key});
///
///   @override
///   Widget build(BuildContext context) {
///     return Scaffold(
///       body: FrogColor(
///         color: Colors.green,
///         child: Builder(
///           builder: (BuildContext innerContext) {
///             return Text(
///               'Hello Frog',
///               style: TextStyle(color: FrogColor.of(innerContext).color),
///             );
///           },
///         ),
///       ),
///     );
///   }
/// }
/// ```
/// {@end-tool}
///
/// {@tool snippet}
///
/// In this example, the `context` used is the one from the `MyOtherPage`
/// widget, which is a parent of the `FrogColor` widget, so this does not work,
/// and will assert when `FrogColor.of` is called.
///
/// ```dart
/// // continuing from previous example...
///
/// class MyOtherPage extends StatelessWidget {
///   const MyOtherPage({super.key});
///
///   @override
///   Widget build(BuildContext context) {
///     return Scaffold(
///       body: FrogColor(
///         color: Colors.green,
///         child: Text(
///           'Hello Frog',
///           style: TextStyle(color: FrogColor.of(context).color),
///         ),
///       ),
///     );
///   }
/// }
/// ```
/// {@end-tool} {@youtube 560 315 https://www.youtube.com/watch?v=1t-8rBCGBYw}
///
/// See also:
///
/// * [StatefulWidget] and [State], for widgets that can build differently
///   several times over their lifetime.
/// * [StatelessWidget], for widgets that always build the same way given a
///   particular configuration and ambient state.
/// * [Widget], for an overview of widgets in general.
/// * [InheritedNotifier], an inherited widget whose value can be a
///   [Listenable], and which will notify dependents whenever the value sends
///   notifications.
/// * [InheritedModel], an inherited widget that allows clients to subscribe to
///   changes for subparts of the value. À9³€ÒÀ:R À:RÀ:a €”/// Abstract const constructor. This constructor enables subclasses to provide
/// const constructors so that they can be used in const expressions.À:c	À:jÀ:i  À:nÀ:~À:}      À:‰GÀ:¦À:¦   À:‰À:ŠÀ:Ô‚îÀ=ŠÀ=Š‚‹/// Whether the framework should notify widgets that inherit from this widget.
///
/// When this widget is rebuilt, sometimes we need to rebuild the widgets that
/// inherit from this widget but sometimes we do not. For example, if the data
/// held by this widget is the same as the data held by `oldWidget`, then we
/// do not need to rebuild the widgets that inherited the data held by
/// `oldWidget`.
///
/// The framework distinguishes these cases by calling this function with the
/// widget that previously occupied this location in the tree as an argument.
/// The given widget is guaranteed to have the same [runtimeType] as this
/// object. À=#À=¸À=·  À=xÀ=y À=ÆŠRÀ=ÆÀ@˜‚Â/// [RenderObjectWidget]s provide the configuration for [RenderObjectElement]s,
/// which wrap [RenderObject]s, which provide the actual rendering of the
/// application.
///
/// Usually, rather than subclassing [RenderObjectWidget] directly, render
/// object widgets subclass one of:
///
///  * [LeafRenderObjectWidget], if the widget has no children.
///  * [SingleChildRenderObjectWidget], if the widget has exactly one child.
///  * [MultiChildRenderObjectWidget], if the widget takes a list of children.
///  * [SlottedMultiChildRenderObjectWidget], if the widget organizes its
///    children in different named slots.
///
/// Subclasses must implement [createRenderObject] and [updateRenderObject]. À@¾€¿ÀA] ÀA]ÀAo €”/// Abstract const constructor. This constructor enables subclasses to provide
/// const constructors so that they can be used in const expressions.ÀAq	ÀAxÀAw      ÀA€‰ÀAúÀAúK/// RenderObjectWidgets always inflate to a [RenderObjectElement] subclass.  ÀAÏÀAĞÀAÛÀAÜÀB‚<ÀD!ÀD!Û/// Creates an instance of the [RenderObject] class that this
/// [RenderObjectWidget] represents, using the configuration described by this
/// [RenderObjectWidget].
///
/// This method should not do anything with the children of the render object.
/// That should instead be handled by the method that overrides
/// [RenderObjectElement.mount] in the object rendered by this object's
/// [createElement] method. See, for example,
/// [SingleChildRenderObjectElement.mount]. ÀD4ÀDBÀDA  ÀCüÀCıÀD	ÀD
ÀDN‚kÀFiÀFiö/// Copies the configuration described by this [RenderObjectWidget] to the
/// given [RenderObject], which will be of the same type as returned by this
/// object's [createRenderObject].
///
/// This method should not do anything to update the children of the render
/// object. That should instead be handled by the method that overrides
/// [RenderObjectElement.update] in the object rendered by this object's
/// [createElement] method. See, for example,
/// [SingleChildRenderObjectElement.update]. ÀF|ÀFŠÀF‰  ÀF’#ÀFªÀF©  ÀFWÀFXÀF½YÀGØÀGØ /// This method is called when a RenderObject that was previously
/// associated with this widget is removed from the render tree.
/// The provided [RenderObject] will be of the same type as the one created by
/// this widget's [createRenderObject] method. ÀGï#ÀHÀH  ÀGÆÀGÇ ÀH‚#ÀHÀHé€¿/// A superclass for [RenderObjectWidget]s that configure [RenderObject] subclasses
/// that have no children.
///
/// Subclasses must implement [createRenderObject] and [updateRenderObject]. ÀI€ÃÀI¾ ÀI¾ÀIÔ €”/// Abstract const constructor. This constructor enables subclasses to provide
/// const constructors so that they can be used in const expressions.ÀIÖ	ÀIİÀIÜ      ÀIæUÀJ
ÀJ
   ÀIæÀIç ÀJ?ƒíÀJ?ÀL1â/// A superclass for [RenderObjectWidget]s that configure [RenderObject] subclasses
/// that have a single child slot.
///
/// The render object assigned to this widget should make use of
/// [RenderObjectWithChildMixin] to implement a single-child model. The mixin
/// exposes a [RenderObjectWithChildMixin.child] property that allows retrieving
/// the render object belonging to the [child] widget.
///
/// Subclasses must implement [createRenderObject] and [updateRenderObject]. ÀLn€ÖÀM ÀMÀM* €”/// Abstract const constructor. This constructor enables subclasses to provide
/// const constructors so that they can be used in const expressions.ÀM,	ÀM3ÀM2  ÀM7
ÀM=ÀM<   ÀMHzÀM½ÀM½`/// The widget below this widget in the tree.
///
/// {@macro flutter.widgets.ProxyWidget.child}   ÀMÇcÀMòÀMò   ÀMÇÀMÈ ÀN.ŒÀN.ÀRq„3/// A superclass for [RenderObjectWidget]s that configure [RenderObject] subclasses
/// that have a single list of children. (This superclass only provides the
/// storage for that child list, it doesn't actually provide the updating
/// logic.)
///
/// Subclasses must use a [RenderObject] that mixes in
/// [ContainerRenderObjectMixin], which provides the necessary functionality to
/// visit the children of the container render object (the render object
/// belonging to the [children] widgets). Typically, subclasses will use a
/// [RenderBox] that mixes in both [ContainerRenderObjectMixin] and
/// [RenderBoxContainerDefaultsMixin].
///
/// Subclasses must implement [createRenderObject] and [updateRenderObject].
///
/// See also:
///
///  * [Stack], which uses [MultiChildRenderObjectWidget].
///  * [RenderStack], for an example implementation of the associated render
///    object.
///  * [SlottedMultiChildRenderObjectWidget], which configures a
///    [RenderObject] that instead of having a single list of children organizes
///    its children in named slots. ÀR­{ÀRÜ ÀRÜÀRø &/// Initializes fields for subclasses.ÀRú	ÀSÀS   ÀS ÀSÀS
  ÀSÀS#ÀS$ÀSÀS"ÀSÀS,‡*ÀZNÀZN†¦/// The widgets below this widget in the tree.
///
/// If this list is going to be mutated, it is usually wise to put a [Key] on
/// each of the child widgets, so that the framework can match old
/// configurations to new configurations and maintain the underlying render
/// objects.
///
/// Also, a [Widget] in Flutter is immutable, so directly modifying the
/// [children] such as `someMultiChildRenderObjectWidget.children.add(...)` or
/// as the example code below will result in incorrect behaviors. Whenever the
/// children list is modified, a new list object should be provided.
///
/// ```dart
/// // This code is incorrect.
/// class SomeWidgetState extends State<SomeWidget> {
///   final List<Widget> _children = <Widget>[];
///
///   void someHandler() {
///     setState(() {
///       _children.add(const ChildWidget());
///     });
///   }
///
///   @override
///   Widget build(BuildContext context) {
///     // Reusing `List<Widget> _children` here is problematic.
///     return Row(children: _children);
///   }
/// }
/// ```
///
/// The following code corrects the problem mentioned above.
///
/// ```dart
/// class SomeWidgetState extends State<SomeWidget> {
///   final List<Widget> _children = <Widget>[];
///
///   void someHandler() {
///     setState(() {
///       // The key here allows Flutter to reuse the underlying render
///       // objects even if the children list is recreated.
///       _children.add(ChildWidget(key: UniqueKey()));
///     });
///   }
///
///   @override
///   Widget build(BuildContext context) {
///     // Always create a new list of children as a Widget is immutable.
///     return Row(children: _children.toList());
///   }
/// }
/// ```   ÀZ[aÀZ…ÀZ…   ÀZ[ÀZ\ À[‡¥À[À[   À[(À[-À[- À[7À[@1À[SÀ[S À[_À[fÀ[nÀ[gÀ[oÀ[p  À[v‚À[{À[{  À[„À[À[Œ   À]—À]œÀ]œ    À^­YÀ^¹À^¹  À^ĞÀ^ÙÀ^Ø   À`
À`À`  À`À`À`   Àa€æÀaÀa  Àa&Àa/Àa.   Àb€«Àb	Àb	  ÀbÀb Àb    Àd©À Z‡Àd©Àw@’‡/// A handle to the location of a widget in the widget tree.
///
/// This class presents a set of methods that can be used from
/// [StatelessWidget.build] methods and from methods on [State] objects.
///
/// [BuildContext] objects are passed to [WidgetBuilder] functions (such as
/// [StatelessWidget.build]), and are available from the [State.context] member.
/// Some static functions (e.g. [showDialog], [Theme.of], and so forth) also
/// take build contexts so that they can act on behalf of the calling widget, or
/// obtain data specifically for the given context.
///
/// Each widget has its own [BuildContext], which becomes the parent of the
/// widget returned by the [StatelessWidget.build] or [State.build] function.
/// (And similarly, the parent of any children for [RenderObjectWidget]s.)
///
/// In particular, this means that within a build method, the build context of
/// the widget of the build method is not the same as the build context of the
/// widgets returned by that build method. This can lead to some tricky cases.
/// For example, [Theme.of(context)] looks for the nearest enclosing [Theme] of
/// the given build context. If a build method for a widget Q includes a [Theme]
/// within its returned widget tree, and attempts to use [Theme.of] passing its
/// own context, the build method for Q will not find that [Theme] object. It
/// will instead find whatever [Theme] was an ancestor to the widget Q. If the
/// build context for a subpart of the returned tree is needed, a [Builder]
/// widget can be used: the build context passed to the [Builder.builder]
/// callback will be that of the [Builder] itself.
///
/// For example, in the following snippet, the [ScaffoldState.showBottomSheet]
/// method is called on the [Scaffold] widget that the build method itself
/// creates. If a [Builder] had not been used, and instead the `context`
/// argument of the build method itself had been used, no [Scaffold] would have
/// been found, and the [Scaffold.of] function would have returned null.
///
/// ```dart
/// @override
/// Widget build(BuildContext context) {
///   // here, Scaffold.of(context) returns null
///   return Scaffold(
///     appBar: AppBar(title: const Text('Demo')),
///     body: Builder(
///       builder: (BuildContext context) {
///         return TextButton(
///           child: const Text('BUTTON'),
///           onPressed: () {
///             Scaffold.of(context).showBottomSheet(
///               (BuildContext context) {
///                 return Container(
///                   alignment: Alignment.center,
///                   height: 200,
///                   color: Colors.amber,
///                   child: Center(
///                     child: Column(
///                       mainAxisSize: MainAxisSize.min,
///                       children: <Widget>[
///                         const Text('BottomSheet'),
///                         ElevatedButton(
///                           child: const Text('Close BottomSheet'),
///                           onPressed: () {
///                             Navigator.pop(context);
///                           },
///                         )
///                       ],
///                     ),
///                   ),
///                 );
///               },
///             );
///           },
///         );
///       },
///     )
///   );
/// }
/// ```
///
/// The [BuildContext] for a particular widget can change location over time as
/// the widget is moved around the tree. Because of this, values returned from
/// the methods on this class should not be cached beyond the execution of a
/// single synchronous function.
///
/// {@youtube 560 315 https://www.youtube.com/watch?v=rIaaH87z1-g}
///
/// Avoid storing instances of [BuildContext]s because they may become invalid
/// if the widget they are associated with is unmounted from the widget tree.
/// {@template flutter.widgets.BuildContext.asynchronous_gap}
/// If a [BuildContext] is used across an asynchronous gap (i.e. after performing
/// an asynchronous operation), consider checking [mounted] to determine whether
/// the context is still valid before interacting with it:
///
/// ```dart
///   @override
///   Widget build(BuildContext context) {
///     return OutlinedButton(
///       onPressed: () async {
///         await Future<void>.delayed(const Duration(seconds: 1));
///         if (context.mounted) {
///           Navigator.of(context).pop();
///         }
///       },
///       child: const Text('Delayed pop'),
///     );
///   }
/// ```
/// {@endtemplate}
///
/// [BuildContext] objects are actually [Element] objects. The [BuildContext]
/// interface is used to discourage direct manipulation of [Element] objects.   ÀwQ`ÀwªÀwªK/// The current configuration of the [Element] that is this [BuildContext].   Àwµ€˜ÀxGÀxG}/// The [BuildOwner] for this context. The [BuildOwner] is in charge of
/// managing the rendering pipeline for this context.   ÀxQÉÀzÀz£/// Whether the [Widget] this context is associated with is currently
/// mounted in the widget tree.
///
/// Accessing the properties of the [BuildContext] or calling any methods on
/// it is only valid while mounted is true. If mounted is false, assertions
/// will trigger.
///
/// Once unmounted, a given [BuildContext] will never become mounted again.
///
/// {@macro flutter.widgets.BuildContext.asynchronous_gap}   Àz‚ÉÀ|×À|×‚“/// Whether the [widget] is currently updating the widget or render tree.
///
/// For [StatefulWidget]s and [StatelessWidget]s this flag is true while
/// their respective build methods are executing.
/// [RenderObjectWidget]s set this to true while creating or configuring their
/// associated [RenderObject]s.
/// Other [Widget] types may set this to true for conceptually similar phases
/// of their lifecycle.
///
/// When this is true, it is safe for [widget] to establish a dependency to an
/// [InheritedWidget] by calling [dependOnInheritedElement] or
/// [dependOnInheritedWidgetOfExactType].
///
/// Accessing this flag in release mode is not valid.   À‚@„+À†fÀ†fƒõ/// The size of the [RenderBox] returned by [findRenderObject].
///
/// This getter will only return a valid result after the layout phase is
/// complete. It is therefore not valid to call this from a build method.
/// It should only be called from paint callbacks or interaction event
/// handlers (e.g. gesture callbacks).
///
/// For details on the different phases of a frame, see the discussion at
/// [WidgetsBinding.drawFrame].
///
/// This getter will only return a valid result if [findRenderObject] actually
/// returns a [RenderBox]. If [findRenderObject] returns a render object that
/// is not a subtype of [RenderBox] (e.g., [RenderView]), this getter will
/// throw an exception in debug mode and will return null in release mode.
///
/// Calling this getter is theoretically relatively expensive (O(N) in the
/// depth of the tree), but in practice is usually cheap because the tree
/// usually has many render objects and therefore the distance to the nearest
/// render object is usually short.    À|ë…QÀ‚)À‚)„ÿ/// The current [RenderObject] for the widget. If the widget is a
/// [RenderObjectWidget], this is the render object that the widget created
/// for itself. Otherwise, it is the render object of the first descendant
/// [RenderObjectWidget].
///
/// This method will only return a valid result after the build phase is
/// complete. It is therefore not valid to call this from a build method.
/// It should only be called from interaction event handlers (e.g.
/// gesture callbacks) or layout or paint callbacks. It is also not valid to
/// call if [State.mounted] returns false.
///
/// If the render object is a [RenderBox], which is the common case, then the
/// size of the render object can be obtained from the [size] getter. This is
/// only valid after the layout phase, and should therefore only be examined
/// from paint callbacks or interaction event handlers (e.g. gesture
/// callbacks).
///
/// For details on the different phases of a frame, see the discussion at
/// [WidgetsBinding.drawFrame].
///
/// Calling this method is theoretically relatively expensive (O(N) in the
/// depth of the tree), but in practice is usually cheap because the tree
/// usually has many render objects and therefore the distance to the nearest
/// render object is usually short.   À†o‚]Àˆ†Àˆ†ğ/// Registers this build context with [ancestor] such that when
/// [ancestor]'s widget changes this build context is rebuilt.
///
/// Returns `ancestor.widget`.
///
/// This method is rarely called directly. Most applications should use
/// [dependOnInheritedWidgetOfExactType], which calls this method after finding
/// the appropriate [InheritedElement] ancestor.
///
/// All of the qualifications about when [dependOnInheritedWidgetOfExactType] can
/// be called apply to this method as well. ÀˆŸÀˆ±Àˆ°  Àˆ»ÀˆÄÀˆÃ   ÀˆĞŠ2À’²À’²‰„/// Returns the nearest widget of the given type `T` and creates a dependency
/// on it, or null if no appropriate widget is found.
///
/// The widget found will be a concrete [InheritedWidget] subclass, and
/// calling [dependOnInheritedWidgetOfExactType] registers this build context
/// with the returned widget. When that widget changes (or a new widget of
/// that type is introduced, or the widget goes away), this build context is
/// rebuilt so that it can obtain new values from that widget.
///
/// {@template flutter.widgets.BuildContext.dependOnInheritedWidgetOfExactType}
/// This is typically called implicitly from `of()` static methods, e.g.
/// [Theme.of].
///
/// This method should not be called from widget constructors or from
/// [State.initState] methods, because those methods would not get called
/// again if the inherited value were to change. To ensure that the widget
/// correctly updates itself when the inherited value changes, only call this
/// (directly or indirectly) from build methods, layout and paint callbacks,
/// or from [State.didChangeDependencies] (which is called immediately after
/// [State.initState]).
///
/// This method should not be called from [State.dispose] because the element
/// tree is no longer stable at that time. To refer to an ancestor from that
/// method, save a reference to the ancestor in [State.didChangeDependencies].
/// It is safe to use this method from [State.deactivate], which is called
/// whenever the widget is removed from the tree.
///
/// It is also possible to call this method from interaction event handlers
/// (e.g. gesture callbacks) or timers, to obtain a value once, as long as
/// that value is not cached and/or reused later.
///
/// Calling this method is O(1) with a small constant factor, but will lead to
/// the widget being rebuilt more often.
///
/// Once a widget registers a dependency on a particular type by calling this
/// method, it will be rebuilt, and [State.didChangeDependencies] will be
/// called, whenever changes occur relating to that widget until the next time
/// the widget or one of its ancestors is moved (for example, because an
/// ancestor is added or removed).
///
/// The [aspect] parameter is only used when `T` is an
/// [InheritedWidget] subclasses that supports partial updates, like
/// [InheritedModel]. It specifies what "aspect" of the inherited
/// widget this context depends on.
/// {@endtemplate}À’ÕÀ’ÕÀ’ÕÀ’ñÀ’úÀ’ù   À“„„À—OÀ—O„/// Returns the nearest widget of the given [InheritedWidget] subclass `T` or
/// null if an appropriate ancestor is not found.
///
/// This method does not introduce a dependency the way that the more typical
/// [dependOnInheritedWidgetOfExactType] does, so this context will not be
/// rebuilt if the [InheritedWidget] changes. This function is meant for those
/// uncommon use cases where a dependency is undesirable.
///
/// This method should not be called from [State.dispose] because the element
/// tree is no longer stable at that time. To refer to an ancestor from that
/// method, save a reference to the ancestor in [State.didChangeDependencies].
/// It is safe to use this method from [State.deactivate], which is called
/// whenever the widget is removed from the tree.
///
/// It is also possible to call this method from interaction event handlers
/// (e.g. gesture callbacks) or timers, to obtain a value once, as long as
/// that value is not cached and/or reused later.
///
/// Calling this method is O(1) with a small constant factor.À—mÀ—mÀ—m  À—„À›\À›\ƒ—/// Obtains the element corresponding to the nearest widget of the given type `T`,
/// which must be the type of a concrete [InheritedWidget] subclass.
///
/// Returns null if no such element is found.
///
/// {@template flutter.widgets.BuildContext.getElementForInheritedWidgetOfExactType}
/// Calling this method is O(1) with a small constant factor.
///
/// This method does not establish a relationship with the target in the way
/// that [dependOnInheritedWidgetOfExactType] does.
///
/// This method should not be called from [State.dispose] because the element
/// tree is no longer stable at that time. To refer to an ancestor from that
/// method, save a reference to the ancestor by calling
/// [dependOnInheritedWidgetOfExactType] in [State.didChangeDependencies]. It is
/// safe to use this method from [State.deactivate], which is called whenever
/// the widget is removed from the tree.
/// {@endtemplate}À›„À›„À›„  À›¥†iÀ¡ÜÀ¡Ü…ÿ/// Returns the nearest ancestor widget of the given type `T`, which must be the
/// type of a concrete [Widget] subclass.
///
/// {@template flutter.widgets.BuildContext.findAncestorWidgetOfExactType}
/// In general, [dependOnInheritedWidgetOfExactType] is more useful, since
/// inherited widgets will trigger consumers to rebuild when they change. This
/// method is appropriate when used in interaction event handlers (e.g.
/// gesture callbacks) or for performing one-off tasks such as asserting that
/// you have or don't have a widget of a specific type as an ancestor. The
/// return value of a Widget's build method should not depend on the value
/// returned by this method, because the build context will not rebuild if the
/// return value of this method changes. This could lead to a situation where
/// data used in the build method changes, but the widget is not rebuilt.
///
/// Calling this method is relatively expensive (O(N) in the depth of the
/// tree). Only call this method if the distance from this widget to the
/// desired ancestor is known to be small and bounded.
///
/// This method should not be called from [State.deactivate] or [State.dispose]
/// because the widget tree is no longer stable at that time. To refer to
/// an ancestor from one of those methods, save a reference to the ancestor
/// by calling [findAncestorWidgetOfExactType] in [State.didChangeDependencies].
///
/// Returns null if a widget of the requested type does not appear in the
/// ancestors of this context.
/// {@endtemplate}À¡úÀ¡úÀ¡ú  À¢†õÀ¨ÜÀ¨Ü†„/// Returns the [State] object of the nearest ancestor [StatefulWidget] widget
/// that is an instance of the given type `T`.
///
/// {@template flutter.widgets.BuildContext.findAncestorStateOfType}
/// This should not be used from build methods, because the build context will
/// not be rebuilt if the value that would be returned by this method changes.
/// In general, [dependOnInheritedWidgetOfExactType] is more appropriate for such
/// cases. This method is useful for changing the state of an ancestor widget in
/// a one-off manner, for example, to cause an ancestor scrolling list to
/// scroll this build context's widget into view, or to move the focus in
/// response to user interaction.
///
/// In general, though, consider using a callback that triggers a stateful
/// change in the ancestor rather than using the imperative style implied by
/// this method. This will usually lead to more maintainable and reusable code
/// since it decouples widgets from each other.
///
/// Calling this method is relatively expensive (O(N) in the depth of the
/// tree). Only call this method if the distance from this widget to the
/// desired ancestor is known to be small and bounded.
///
/// This method should not be called from [State.deactivate] or [State.dispose]
/// because the widget tree is no longer stable at that time. To refer to
/// an ancestor from one of those methods, save a reference to the ancestor
/// by calling [findAncestorStateOfType] in [State.didChangeDependencies].
/// {@endtemplate}
///
/// {@tool snippet}
///
/// ```dart
/// ScrollableState? scrollable = context.findAncestorStateOfType<ScrollableState>();
/// ```
/// {@end-tool}À¨ôÀ¨ôÀ¨ô  À©‚QÀ«-À«-‚/// Returns the [State] object of the furthest ancestor [StatefulWidget] widget
/// that is an instance of the given type `T`.
///
/// {@template flutter.widgets.BuildContext.findRootAncestorStateOfType}
/// Functions the same way as [findAncestorStateOfType] but keeps visiting subsequent
/// ancestors until there are none of the type instance of `T` remaining.
/// Then returns the last one found.
///
/// This operation is O(N) as well though N is the entire widget tree rather than
/// a subtree.
/// {@endtemplate}À«IÀ«IÀ«I  À«`…gÀ°À°… /// Returns the [RenderObject] object of the nearest ancestor [RenderObjectWidget] widget
/// that is an instance of the given type `T`.
///
/// {@template flutter.widgets.BuildContext.findAncestorRenderObjectOfType}
/// This should not be used from build methods, because the build context will
/// not be rebuilt if the value that would be returned by this method changes.
/// In general, [dependOnInheritedWidgetOfExactType] is more appropriate for such
/// cases. This method is useful only in esoteric cases where a widget needs
/// to cause an ancestor to change its layout or paint behavior. For example,
/// it is used by [Material] so that [InkWell] widgets can trigger the ink
/// splash on the [Material]'s actual render object.
///
/// Calling this method is relatively expensive (O(N) in the depth of the
/// tree). Only call this method if the distance from this widget to the
/// desired ancestor is known to be small and bounded.
///
/// This method should not be called from [State.deactivate] or [State.dispose]
/// because the widget tree is no longer stable at that time. To refer to
/// an ancestor from one of those methods, save a reference to the ancestor
/// by calling [findAncestorRenderObjectOfType] in [State.didChangeDependencies].
/// {@endtemplate}À°­À°­À°­  À°ËƒÛÀ´mÀ´mƒz/// Walks the ancestor chain, starting with the parent of this build context's
/// widget, invoking the argument for each ancestor.
///
/// {@template flutter.widgets.BuildContext.visitAncestorElements}
/// The callback is given a reference to the ancestor widget's corresponding
/// [Element] object. The walk stops when it reaches the root widget or when
/// the callback returns false. The callback must not return null.
///
/// This is useful for inspecting the widget tree.
///
/// Calling this method is relatively expensive (O(N) in the depth of the tree).
///
/// This method should not be called from [State.deactivate] or [State.dispose]
/// because the element tree is no longer stable at that time. To refer to
/// an ancestor from one of those methods, save a reference to the ancestor
/// by calling [visitAncestorElements] in [State.didChangeDependencies].
/// {@endtemplate} À´ƒ!À´À´   À´ª„vÀ¸õÀ¸õ„/// Walks the children of this widget.
///
/// {@template flutter.widgets.BuildContext.visitChildElements}
/// This is useful for applying changes to children after they are built
/// without waiting for the next frame, especially if the children are known,
/// and especially if there is exactly one child (as is always the case for
/// [StatefulWidget]s or [StatelessWidget]s).
///
/// Calling this method is very cheap for build contexts that correspond to
/// [StatefulWidget]s or [StatelessWidget]s (O(1), since there's only one
/// child).
///
/// Calling this method is potentially expensive for build contexts that
/// correspond to [RenderObjectWidget]s (O(N) in the number of children).
///
/// Calling this method recursively is extremely expensive (O(N) in the number
/// of descendants), and should be avoided if possible. Generally it is
/// significantly cheaper to use an [InheritedWidget] and have the descendants
/// pull data down, than it is to use [visitChildElements] recursively to push
/// data down to them.
/// {@endtemplate} À¹À¹À¹   À¹$.Àº"Àº"€î/// Start bubbling this notification at the given build context.
///
/// The notification will be delivered to any [NotificationListener] widgets
/// with the appropriate type parameters that are ancestors of the given
/// [BuildContext]. Àº7ÀºEÀºD   ÀºVÀ»…À»…/// Returns a description of the [Element] associated with the current build context.
///
/// The `name` is typically something like "The element being rebuilt was".
///
/// See also:
///
///  * [Element.describeElements], which can be used to describe a list of elements. À»šÀ»¢À»¡  À»­?À»ÃÀ»Â  À»ÊÀ»ŞÀ»ßÀ»÷'À¼±À¼±€£/// Returns a description of the [Widget] associated with the current build context.
///
/// The `name` is typically something like "The widget being rebuilt was". À¼ÅÀ¼ÍÀ¼Ì  À¼Ø?À¼îÀ¼í  À¼õÀ½	À½
À½"À¾À¾€À/// Adds a description of a specific type of widget missing from the current
/// build context's ancestry tree.
///
/// You can find an example of using this method in [debugCheckHasMaterial]. À¾"À¾)À¾(   À¾C€ëÀ¿
À¿
€®/// Adds a description of the ownership chain from a specific [Element]
/// to the error report.
///
/// The ownership chain is useful for debugging the source of an element. À¿!À¿)À¿(    À¿2ŸĞÀ¿2ÀÁÍ‚/// A class that determines the scope of a [BuildOwner.buildScope] operation.
///
/// The [BuildOwner.buildScope] method rebuilds all dirty [Element]s who share
/// the same [Element.buildScope] as its `context` argument, and skips those
/// with a different [Element.buildScope].
///
/// [Element]s by default have the same `buildScope` as their parents. Special
/// [Element]s may override [Element.buildScope] to create an isolated build scope
/// for its descendants. The [LayoutBuilder] widget, for example, establishes its
/// own [BuildScope] such that no descendant [Element]s may rebuild prematurely
/// until the incoming constraints are known. ÀÁÜmÀÂ& ÀÂ&ÀÂ0 G/// Creates a [BuildScope] with an optional [scheduleRebuild] callback.ÀÂ2ÀÂ8ÀÂ7   ÀÂwÀÂ|ÀÂ| ÀÂÀÂæÀÂëÀÂë ÀÂ÷ÀÃ‚ÀÅÀÅç/// An optional [VoidCallback] that will be called when [Element]s in this
/// [BuildScope] are marked as dirty for the first time.
///
/// This callback usually signifies that the [BuildOwner.buildScope] method
/// must be called at a later time in this frame to rebuild dirty elements in
/// this [BuildScope]. It will **not** be called if this scope is actively being
/// built by [BuildOwner.buildScope], since the [BuildScope] will be clean when
/// [BuildOwner.buildScope] returns. ÀÅ!gÀÆlÀÆl6/// Whether [_dirtyElements] need to be sorted again as a result of more
/// elements becoming dirty during the build.
///
/// This is necessary to preserve the sort order defined by [Element._sort].
///
/// This field is set to null when [BuildOwner.buildScope] is not actively
/// rebuilding the widget tree. ÀÆŒ0ÀÆ ÀÆ  ÀÆºÀÆ»ÀÆ±ÀÆ¹ÀÆ²  ÀÆÁöÀÇ#ÀÇ#  ÀÇ5ÀÇ>ÀÇ=  ÀÆÁÀÆÂÀÆÈÀÆÜÀÆÉÀÆàÀÆáÀÆçÀÆúÀÆèÀÆşÀÆÿÀÇÀÇÀÇÀÈ»„ÖÀÉJÀÉJ  ÀÉVÀÉ_ÀÉ^  ÀÈ»ÀÈ¼ÀÈÂÀÈÖÀÈÃÀÈÚÀÈÛÀÈáÀÈôÀÈâÀÈøÀÈùÀÈÿÀÉÀÉ ÀÉÀÉÀÉÀÉAÀÉ ÀÍ•…<ÀÍšÀÍš  ÀÍµÀÍ¾ÀÍ½  ÀÍÆÀÍÏÀÍÎ   ÀÒÕ‡QÀÓÀÓ  ÀÓÀÓ.ÀÓ-  ÀÒÕÀÒÖÀÒÜÀÒşÀÒİÀÚ*„ÖÀÚ‹ÀÚ‹  ÀÚ£	ÀÚ¨ÀÚ§  ÀÚ*ÀÚ+ÀÚ1ÀÚEÀÚ2ÀÚIÀÚJÀÚPÀÚcÀÚQÀÚgÀÚhÀÚnÀÚƒÀÚo ÀßÀ `ÀßÀã*„/// Manager class for the widgets framework.
///
/// This class tracks which widgets need rebuilding, and handles other tasks
/// that apply to widget trees as a whole, such as managing the inactive element
/// list for the tree and triggering the "reassemble" command when necessary
/// during hot reload when debugging.
///
/// The main build owner is typically owned by the [WidgetsBinding], and is
/// driven from the operating system along with the rest of the
/// build/layout/paint pipeline.
///
/// Additional build owners can be built to manage off-screen widget trees.
///
/// To assign a build owner to a tree, use the
/// [RootElementMixin.assignOwner] method on the root element of the
/// widget tree.
///
/// {@tool dartpad}
/// This example shows how to build an off-screen widget tree used to measure
/// the layout size of the rendered tree. For some use cases, the simpler
/// [Offstage] widget may be a better alternative to this approach.
///
/// ** See code in examples/api/lib/widgets/framework/build_owner.0.dart **
/// {@end-tool} Àã9‚Àä¹ Àä¹ÀäÃ q/// Creates an object that manages widgets.
///
/// If the `focusManager` argument is not specified or is null, this will
/// construct a new [FocusManager] and register its global input handlers
/// via [FocusManager.registerGlobalHandlers], which will modify static
/// state. Callers wishing to avoid altering this state can explicitly pass
/// a focus manager here.ÀäÅÀäËÀäÊ  ÀäÜÀäëÀäê  ÀåÀäÿÀåÀåÀåÀåGÀåÀå+Àå,Àå-Àå/ÀåEÀåFÀåMvÀå³Àå³S/// Called on each build pass when the first buildable element is marked
/// dirty. ÀåÈ?ÀåàÀåà ÀåôÀæÀæÀæ)ÀæÀæ Àæ0Àæ:‚UÀèƒÀèƒ‚#/// The object in charge of the focus tree.
///
/// Rarely used directly. Instead, consider using [FocusScope.of] to obtain
/// the [FocusScopeNode] for a given [BuildContext].
///
/// See [FocusManager] for more details.
///
/// This field will default to a [FocusManager] that has registered its
/// global input handlers via [FocusManager.registerGlobalHandlers]. Callers
/// wishing to avoid registering those handlers (and modifying the associated
/// static state) can explicitly pass a focus manager to the [BuildOwner.new]
/// constructor. Àò¼ÀòÀÀòÀ Àò×ÀóªÀó¯Àó¯ ÀóÀÀóÉ!ÀóÒÀóÒ  À€\ÀÀ  ÀğIÀÀ À7À8À#À6À$À/ÀĞaÀòÀò ÀĞÀÑÀÀ+ÀÀÀÀ'À À(À)À-À	«€À	æÀ	æ À	«À	¬À
À
BÀ
À
9À
:À
À
8À
À
!À
$À
7À
%À
.À
DÀòÜ7ÀòåÀòå    Àó€Àó‡Àó‡`/// Whether this widget tree is in the build phase.
///
/// Only valid when asserts are enabled.   À
M€¼À
İÀ
İ€ƒ/// The number of [GlobalKey] instances that are currently associated with
/// [Element]s that have been built by this build owner.    Àè”Š$ÀéÀé€/// Adds an element to the dirty elements list so that it will be rebuilt
/// when [WidgetsBinding.drawFrame] calls [buildScope]. Àé0Àé9Àé8   Àóï‚8ÀôİÀôİ€Ş/// Establishes a scope in which calls to [State.setState] are forbidden, and
/// calls the given `callback`.
///
/// This mechanism is used to ensure that, for instance, [State.dispose] does
/// not call [State.setState]. ÀôçÀôõÀôô   Àö+QÀû^Àû^„Î/// Establishes a scope for updating the widget tree, and calls the given
/// `callback`, if any. Then, builds all the elements that were marked as
/// dirty using [scheduleBuildFor], in depth order.
///
/// This mechanism prevents build methods from transitively requiring other
/// build methods to run, potentially causing infinite loops.
///
/// The dirty list is processed after `callback` returns, building all the
/// elements that were marked as dirty using [scheduleBuildFor], in depth
/// order. If elements are marked as dirty while this method is running, they
/// must be deeper than the `context` node, and deeper than any
/// previously-built node in this pass.
///
/// To flush the current dirty list without performing any other work, this
/// function can be called with no callback. This is what the framework does
/// each frame, in [WidgetsBinding.drawFrame].
///
/// Only one [buildScope] can be active at a time.
///
/// A [buildScope] implies a [lockState] scope as well.
///
/// To print a console message every time this method is called, set
/// [debugPrintBuildScope] to true. This is useful when debugging problems
/// involving widgets not getting marked dirty, or getting marked dirty too
/// often. ÀûiÀûrÀûq  Àû{ÀûŠÀû‰  Àû,Àû-Àû3ÀûUÀû4Àá…ÀæÀæ  À.À7À6  À@ÀKÀJ   Àj€‚ÀoÀo  À‡ÀÀ   À€µÀÀ  À6À?À>  ÀFÀOÀN   ÀÆ…ÀËÀË  ÀŞÀéÀè  ÀíÀöÀõ   ÀO¯ÀTÀT  ÀiÀtÀs  ÀxÀÀ€   À ÀÀ  À!À*À)  À1À:À9  À@ÀKÀJ   À@ÀÀ    ÀJ‡pÀOÀO    À$¾—˜À& À& /// Complete the element build pass by unmounting any elements that are no
/// longer active.
///
/// This is called by [WidgetsBinding.drawFrame].
///
/// In debug mode, this also runs some sanity checks, for example checking for
/// duplicate global keys.  À%ÎÀ%ÏÀ%ÕÀ%÷À%ÖÀ<Z‚ªÀ=¼À=¼P/// Cause the entire subtree rooted at the given [Element] to be entirely
/// rebuilt. This is used by development tools when the application code has
/// changed and is being hot-reloaded, to cause the widget tree to pick up any
/// changed implementations.
///
/// This is expensive and should not be called except during development. À=ÇÀ=ĞÀ=Ï    ÀA®GÀA®ÀA´  ÀAÊ-ÀAÊ ÀAÊÀAÛ  ÀAÜÀAâÀAá  ÀAéÀAïÀAî   ÀAûÀBÀB  ÀBÀB1ÀB1    ÀB<€·ÀBAÀBA  ÀBVÀBdÀBc    ÀC¥ÀFàÀC¥ÀPjŒµ/// An instantiation of a [Widget] at a particular location in the tree.
///
/// Widgets describe how to configure a subtree but the same widget can be used
/// to configure multiple subtrees simultaneously because widgets are immutable.
/// An [Element] represents the use of a widget to configure a specific location
/// in the tree. Over time, the widget associated with a given element can
/// change, for example, if the parent widget rebuilds and creates a new widget
/// for this location.
///
/// Elements form a tree. Most elements have a unique child, but some widgets
/// (e.g., subclasses of [RenderObjectElement]) can have multiple children.
///
/// Elements have the following lifecycle:
///
///  * The framework creates an element by calling [Widget.createElement] on the
///    widget that will be used as the element's initial configuration.
///  * The framework calls [mount] to add the newly created element to the tree
///    at a given slot in a given parent. The [mount] method is responsible for
///    inflating any child widgets and calling [attachRenderObject] as
///    necessary to attach any associated render objects to the render tree.
///  * At this point, the element is considered "active" and might appear on
///    screen.
///  * At some point, the parent might decide to change the widget used to
///    configure this element, for example because the parent rebuilt with new
///    state. When this happens, the framework will call [update] with the new
///    widget. The new widget will always have the same [runtimeType] and key as
///    old widget. If the parent wishes to change the [runtimeType] or key of
///    the widget at this location in the tree, it can do so by unmounting this
///    element and inflating the new widget at this location.
///  * At some point, an ancestor might decide to remove this element (or an
///    intermediate ancestor) from the tree, which the ancestor does by calling
///    [deactivateChild] on itself. Deactivating the intermediate ancestor will
///    remove that element's render object from the render tree and add this
///    element to the [owner]'s list of inactive elements, causing the framework
///    to call [deactivate] on this element.
///  * At this point, the element is considered "inactive" and will not appear
///    on screen. An element can remain in the inactive state only until
///    the end of the current animation frame. At the end of the animation
///    frame, any elements that are still inactive will be unmounted.
///  * If the element gets reincorporated into the tree (e.g., because it or one
///    of its ancestors has a global key that is reused), the framework will
///    remove the element from the [owner]'s list of inactive elements, call
///    [activate] on the element, and reattach the element's render object to
///    the render tree. (At this point, the element is again considered "active"
///    and might appear on screen.)
///  * If the element does not get reincorporated into the tree by the end of
///    the current animation frame, the framework will call [unmount] on the
///    element.
///  * At this point, the element is considered "defunct" and will not be
///    incorporated into the tree in the future. ÀP©ÀQ: ÀQ:ÀQA €Š/// Creates an element that uses the given widget as its configuration.
///
/// Typically called by an override of [Widget.createElement].ÀQBÀQJÀQI  ÀQ[ÀQSÀQ]ÀQ°ÀQ¹ÀQ¹  ÀQÄ$ÀQ×ÀQ×  ÀWÔÀWÜÀWÜ  ÀYnÀYwÀYw  À_ÌÀ_ÔÀ_Ô  ÀcÀcšÀcš  ÀjgÀjsÀjs  À€š=À€¬À€¬ À€¾À€ÏÀ€ĞÀÿ¦oÀÿÈÀÿÈ Àÿ¦Àÿ§ÀÿúÀ ÀÿïÀÿüÀ À À À À À À<!=À<LÀ<L  À<b$À<yÀ<y  À<Š(À<À< À<­ÀbŒÀb‘Àb‘ ÀbšÀcCÀcHÀcH ÀcWÀcœÀc¡Àc¡ Àc³ÀV–;ÀWÃÀWÃ/// Information set by parent to define where this child fits in its parent's
/// child list.
///
/// A child widget's slot is determined when the parent's [updateChild] method
/// is called to inflate the child widget. See [RenderObjectElement] for more
/// details on slots.   ÀWæ„ÀX‡ÀX‡€”/// An integer that is guaranteed to be greater than the parent's, if any.
/// The element at the root of the tree must have a depth greater than 0.   À]·‚À_¶À_¶×/// The configuration for this element.
///
/// Avoid overriding this field on [Element] subtypes to provide a more
/// specific widget type (i.e. [StatelessElement] and [StatelessWidget]).
/// Instead, cast at any call sites where the more specific type is required.
/// This avoids significant cast overhead on the getter which is accessed
/// throughout the framework internals during the build phase - and for which
/// the more specific type information is not used.  À_ŸÀ_ À_à0À_õÀ_õ   À_àÀ_áÀ`†À`çÀ`ç€Á/// Returns true if the Element is defunct.
///
/// This getter always returns false in profile and release builds.
/// See the lifecycle documentation for [Element] for additional information.   Àa€ÀbpÀbp€À/// Returns true if the Element is active.
///
/// This getter always returns false in profile and release builds.
/// See the lifecycle documentation for [Element] for additional information.   Àc"iÀc{Àc{:/// The object that manages the lifecycle of this element.  Àc_Àc`Àc¥†CÀiÇÀiÇ…Ö/// A [BuildScope] whose dirty [Element]s can only be rebuilt by
/// [BuildOwner.buildScope] calls whose `context` argument is an [Element]
/// within this [BuildScope].
///
/// The getter typically is only safe to access when this [Element] is [mounted].
///
/// The default implementation returns the parent [Element]'s [buildScope],
/// as in most cases an [Element] is ready to rebuild as soon as its ancestors
/// are no longer dirty. One notable exception is [LayoutBuilder]'s
/// descendants, which must not rebuild until the incoming constraints become
/// available. [LayoutBuilder]'s [Element] overrides [buildScope] to make none
/// of its descendants can rebuild until the incoming constraints are known.
///
/// If you choose to override this getter to establish your own [BuildScope],
/// to flush the dirty [Element]s in the [BuildScope] you need to manually call
/// [BuildOwner.buildScope] with the root [Element] of your [BuildScope] when
/// appropriate, as the Flutter framework does not try to register or manage
/// custom [BuildScope]s.
///
/// Always return the same [BuildScope] instance if you override this getter.
/// Changing the value returned by this getter at runtime is not
/// supported.
///
/// The [updateChild] method ignores [buildScope]: if the parent [Element]
/// calls [updateChild] on a child with a different [BuildScope], the child may
/// still rebuild.
///
/// See also:
///
///  * [LayoutBuilder], a widget that establishes a custom [BuildScope].   Àq ƒÀscÀsc‚/// The render object at (or below) this location in the tree.
///
/// If this object is a [RenderObjectElement], the render object is the one at
/// this location in the tree. Otherwise, this getter will walk down the tree
/// until it finds a [RenderObjectElement].
///
/// Some locations in the tree are not backed by a render object. In those
/// cases, this getter returns null. This can happen, if the element is
/// located outside of a [View] since only the element subtree rooted in a
/// view has a render tree associated with it.   ÀtÁƒxÀwkÀwk‚y/// Returns the child of this [Element] that will insert a [RenderObject] into
/// an ancestor of this Element to construct the render tree.
///
/// Returns null if this Element doesn't have any children who need to attach
/// a [RenderObject] to an ancestor of this [Element]. A [RenderObjectElement]
/// will therefore return null because its children insert their
/// [RenderObject]s into the [RenderObjectElement] itself and not into an
/// ancestor of the [RenderObjectElement].
///
/// Furthermore, this may return null for [Element]s that hoist their own
/// independent render tree and do not extend the ancestor render tree.  ÀwQÀwRÀ$7—æÀ$MÀ$M   À$7À$8À`¦ãÀbyÀby»/// Returns true if the element has been marked as needing rebuilding.
///
/// The flag is true when the element is first created and after
/// [markNeedsBuild] has been called. The flag is typically reset to false in
/// the [performRebuild] implementation, but certain elements (that of the
/// [LayoutBuilder] widget, for example) may choose to override [markNeedsBuild]
/// such that it does not set the [dirty] flag to `true` when called.    >ÀQí„¥ÀVgÀVgƒâ/// Compare two widgets for equality.
///
/// When a widget is rebuilt with another that compares equal according
/// to `operator ==`, it is assumed that the update is redundant and the
/// work to update that branch of the tree is skipped.
///
/// It is generally discouraged to override `operator ==` on any widget that
/// has children, since a correct implementation would have to defer to the
/// children's equality operator also, and that is an O(NÂ²) operation: each
/// child would need to itself walk all its children, each step of the tree.
///
/// It is sometimes reasonable for a leaf widget (one with no children) to
/// implement this method, if rebuilding the widget is known to be much more
/// expensive than checking the widgets' parameters for equality and if the
/// widget is expected to often be rebuilt with identical parameters.
///
/// In general, however, it is more efficient to cache the widgets used
/// in a build method if it is known that they will not change. ÀVjÀVrÀVq  ÀUóÀUôÀVÀVÀY‚‚9ÀYôÀYôb/// Returns result < 0 when [a] < [b], result == 0 when [a] == [b], result > 0
/// when [a] > [b]. ÀYú	ÀZÀZ  ÀZ	ÀZÀZ   À]€¨À]À]  À],À]5À]4   Àj‰…ÀÀoÛÀoÛ„ø/// {@template flutter.widgets.Element.reassemble}
/// Called whenever the application is reassembled during debugging, for
/// example during hot reload.
///
/// This method should rerun any initialization logic that depends on global
/// state, for example, image loading from asset bundles (since the asset
/// bundle may have changed).
///
/// This function will only be called during development. In release builds,
/// the `ext.flutter.reassemble` hook is not available, and so this code will
/// never execute.
///
/// Implementers should not rely on any ordering for hot reload source update,
/// reassemble, and build methods after a hot reload has been initiated. It is
/// possible that a [Timer] (e.g. an [Animation]) or a debugging session
/// attached to the isolate could trigger a build with reloaded code _before_
/// reassemble is called. Code that expects preconditions to be set by
/// reassemble after a hot reload must be resilient to being called out of
/// order, e.g. by fizzling instead of throwing. That said, once reassemble is
/// called, build will be called after it at least once.
/// {@endtemplate}
///
/// See also:
///
///  * [State.reassemble]
///  * [BindingBase.reassembleApplication]
///  * [Image], which uses this to reload images.  Ào¸Ào¹ÀoÉÀoÊÀpM€ÏÀpRÀpR  ÀpgÀppÀpo   Àx=ƒ’Àx_Àx_  Àxx"Àx‡Àx†  Àx=Àx>À{ÓŒÀ|AÀ|AT/// Returns a list of [Element]s from the current build context to the error report. À|RÀ|ZÀ|Y  À|_À|rÀ|q   À}c€ÒÀ}À}  À}”À}œÀ}›  À}§?À}½À}¼  À}cÀ}dÀ}ÄÀ}ØÀ}ÙÀ~9€ÑÀ~UÀ~U  À~iÀ~qÀ~p  À~|?À~’À~‘  À~9À~:À~™À~­À~®À)À*À*  ÀAÀIÀH  ÀÀÀ€Ü‚WÀƒÀƒ‚/// Calls the argument for each child. Must be overridden by subclasses that
/// support having children.
///
/// There is no guaranteed order in which the children will be visited, though
/// it should be consistent over time.
///
/// Calling this during build is dangerous: the child list might still be
/// being updated at that point, so the children might not be constructed yet,
/// or might be old children that are going to be replaced. This method should
/// only be called if it is provable that the children are available. ÀƒÀƒ)Àƒ(   Àƒ7ƒÁÀ†¬À†¬ƒG/// Calls the argument for each child considered onstage.
///
/// Classes like [Offstage] and [Overlay] override this method to hide their
/// children.
///
/// Being onstage affects the element's discoverability during testing when
/// you use Flutter's [Finder] objects. For example, when you instruct the
/// test framework to tap on a widget, by default the finder will look for
/// onstage elements and ignore the offstage ones.
///
/// The default implementation defers to [visitChildren] and therefore treats
/// the element as onstage.
///
/// See also:
///
///  * [Offstage] widget that hides its children.
///  * [Finder] that skips offstage widgets by default.
///  * [RenderObject.visitChildrenForSemantics], in contrast to this method,
///    designed specifically for excluding parts of the UI from the semantics
///    tree. À†ÆÀ†ÖÀ†Õ   À†ü‚ÎÀ‡FÀ‡F6/// Wrapper around [visitChildren] for [BuildContext]. À‡YÀ‡iÀ‡h  À‡5À‡6À‰Î˜œÀ“:À“:ˆ¦/// Update the given child with the given new configuration.
///
/// This method is the core of the widgets system. It is called each time we
/// are to add, update, or remove a child based on an updated configuration.
///
/// The `newSlot` argument specifies the new value for this element's [slot].
///
/// If the `child` is null, and the `newWidget` is not null, then we have a new
/// child for which we need to create an [Element], configured with `newWidget`.
///
/// If the `newWidget` is null, and the `child` is not null, then we need to
/// remove it because it no longer has a configuration.
///
/// If neither are null, then we need to update the `child`'s configuration to
/// be the new configuration given by `newWidget`. If `newWidget` can be given
/// to the existing child (as determined by [Widget.canUpdate]), then it is so
/// given. Otherwise, the old child needs to be disposed and a new child
/// created for the new configuration.
///
/// If both are null, then we don't have a child and won't have a child, so we
/// do nothing.
///
/// The [updateChild] method returns the new child, if it had to create one,
/// or the child that was passed in, if it just had to update the child, or
/// null, if it removed the child and did not replace it.
///
/// The following table summarizes the above:
///
/// |                     | **newWidget == null**  | **newWidget != null**   |
/// | :-----------------: | :--------------------- | :---------------------- |
/// |  **child == null**  |  Returns null.         |  Returns new [Element]. |
/// |  **child != null**  |  Old child is removed, returns null. | Old child updated if possible, returns child or new [Element]. |
///
/// The `newSlot` argument is used only if `newWidget` is not null. If `child`
/// is null (or if the old child cannot be updated), then the `newSlot` is
/// given to the new [Element] that is created for the child, via
/// [inflateWidget]. If `child` is not null (and the old child _can_ be
/// updated), then the `newSlot` is given to [updateSlotForChild] to update
/// its slot, in case it has moved around since it was last built.
///
/// See the [RenderObjectElement] documentation for more information on slots. À“FÀ“PÀ“O  À“VÀ“_À“^  À“iÀ“rÀ“q  À’ÇÀ’ÈÀ’ÔÀ’ÕÀ’ÛÀ’ïÀ’ÜÀ’óÀ’ôÀ’úÀ“À’ûÀ“À“À“À“-À“À¢n©xÀ®yÀ®y‹‘/// Updates the children of this element to use new widgets.
///
/// Attempts to update the given old children list using the given new
/// widgets, removing obsolete elements and introducing new ones as necessary,
/// and then returns the new child list.
///
/// During this function the `oldChildren` list must not be modified. If the
/// caller wishes to remove elements from `oldChildren` reentrantly while
/// this function is on the stack, the caller can supply a `forgottenChildren`
/// argument, which can be modified while this function is on the stack.
/// Whenever this function reads from `oldChildren`, this function first
/// checks whether the child is in `forgottenChildren`. If it is, the function
/// acts as if the child was not in `oldChildren`.
///
/// This function is a convenience wrapper around [updateChild], which updates
/// each individual child. If `slots` is non-null, the value for the `newSlot`
/// argument of [updateChild] is retrieved from that list using the index that
/// the currently processed `child` corresponds to in the `newWidgets` list
/// (`newWidgets` and `slots` must have the same length). If `slots` is null,
/// an [IndexedSlot<Element>] is used as the value for the `newSlot` argument.
/// In that case, [IndexedSlot.index] is set to the index that the currently
/// processed `child` corresponds to in the `newWidgets` list and
/// [IndexedSlot.value] is set to the [Element] of the previous widget in that
/// list (or null if it is the first child).
///
/// When the [slot] value of an [Element] changes, its
/// associated [renderObject] needs to move to a new position in the child
/// list of its parents. If that [RenderObject] organizes its children in a
/// linked list (as is done by the [ContainerRenderObjectMixin]) this can
/// be implemented by re-inserting the child [RenderObject] into the
/// list after the [RenderObject] associated with the [Element] provided as
/// [IndexedSlot.value] in the [slot] object.
///
/// Using the previous sibling as a [slot] is not enough, though, because
/// child [RenderObject]s are only moved around when the [slot] of their
/// associated [RenderObjectElement]s is updated. When the order of child
/// [Element]s is changed, some elements in the list may move to a new index
/// but still have the same previous sibling. For example, when
/// `[e1, e2, e3, e4]` is changed to `[e1, e3, e4, e2]` the element e4
/// continues to have e3 as a previous sibling even though its index in the list
/// has changed and its [RenderObject] needs to move to come before e2's
/// [RenderObject]. In order to trigger this move, a new [slot] value needs to
/// be assigned to its [Element] whenever its index in its
/// parent's child list changes. Using an [IndexedSlot<Element>] achieves
/// exactly that and also ensures that the underlying parent [RenderObject]
/// knows where a child needs to move to in a linked list by providing its new
/// previous sibling. À®À®œÀ®›  À®¬À®ºÀ®¹  À®ËÀ®ÚÀ®Ù  À®ğÀ¯ À®ÿ  À®^À®_ÀËêˆkÀÏ„ÀÏ„ƒa/// Add this element to the tree in the given slot of the given parent.
///
/// The framework calls this function when a newly created element is added to
/// the tree for the first time. Use this method to initialize state that
/// depends on having a parent. State that is independent of the parent can
/// more easily be initialized in the constructor.
///
/// This method transitions the element from the "initial" lifecycle state to
/// the "active" lifecycle state.
///
/// Subclasses that override this method are likely to want to also override
/// [update], [visitChildren], [RenderObjectElement.insertRenderObjectChild],
/// [RenderObjectElement.moveRenderObjectChild], and
/// [RenderObjectElement.removeRenderObjectChild].
///
/// Implementations of this method should start with a call to the inherited
/// method, as in `super.mount(parent, newSlot)`. ÀÏŠÀÏ”ÀÏ“  ÀÏ›ÀÏ¤ÀÏ£  ÀÏnÀÏoÀÔY€’ÀÔ^ÀÔ^  ÀÔÀÔˆÀÔ‡   ÀÔï„İÀÖ`ÀÖ`L/// Change the widget used to configure this element.
///
/// The framework calls this function when the parent wishes to use a
/// different widget to configure this element. The new widget is guaranteed
/// to have the same [runtimeType] as the old widget.
///
/// This function is called only during the "active" lifecycle state. ÀÖgÀÖyÀÖx  ÀÖJÀÖKÀÙĞ‚§ÀÚüÀÚü/// Change the slot that the given child occupies in its parent.
///
/// Called by [MultiChildRenderObjectElement], and other [RenderObjectElement]
/// subclasses that have multiple children, when child moves from one position
/// to another in this element's child list. ÀÛÀÛÀÛ  ÀÛÀÛ'ÀÛ&  ÀÚêÀÚëÀÜ{vÀİ#Àİ#€€/// Called by [updateSlotForChild] when the framework needs to change the slot
/// that this [Element] occupies in its ancestor. Àİ.Àİ7Àİ6  Àİ ÀİÀİÀİÀİõ€øÀİúÀİú  ÀŞÀŞÀŞ   ÀŞñ‘ÀŞöÀŞö    Àà†ŞÀáêÀáêN/// Remove [renderObject] from the render tree.
///
/// The default implementation of this function calls
/// [detachRenderObject] recursively on each child. The
/// [RenderObjectElement.detachRenderObject] override does the actual work of
/// removing [renderObject] from the render tree.
///
/// This is called by [deactivateChild].   Àâh‚TÀäÀä‘/// Add [renderObject] to the render tree at the location specified by `newSlot`.
///
/// The default implementation of this function calls
/// [attachRenderObject] recursively on each child. The
/// [RenderObjectElement.attachRenderObject] override does the actual work of
/// adding [renderObject] to the render tree.
///
/// The `newSlot` argument specifies the new value for this element's [slot]. Àä"Àä+Àä*   ÀäÀˆËÀäÉÀäÉ  ÀäàÀäëÀäê  ÀäïÀä÷Àäö   ÀíŠÉÀñ6Àñ6ƒ/// Create an element for the given widget and add it as a child of this
/// element in the given slot.
///
/// This method is typically called by [updateChild] but can be called
/// directly by subclasses that need finer-grained control over creating
/// elements.
///
/// If the given widget has a global key and an element already exists that
/// has a widget with that global key, this function will reuse that element
/// (potentially grafting it from another location in the tree or reactivating
/// it from the list of inactive elements) rather than creating a new element.
///
/// The `newSlot` argument specifies the new value for this element's [slot].
///
/// The element returned by this function will already have been mounted and
/// will be in the "active" lifecycle state. ÀñDÀñLÀñK  ÀñVÀñ_Àñ^  ÀğÄÀğÅÀğÑÀğÒÀğØÀğìÀğÙÀğğÀğñÀğ÷Àñ
ÀğøÀñÀñÀñÀñ*ÀñÀø\6ÀøaÀøa  ÀøvÀøÀø~   Àù–„ÚÀü¹Àü¹‚ô/// Move the given element to the list of inactive elements and detach its
/// render object from the render tree.
///
/// This method stops the given element from being a child of this element by
/// detaching its render object from the render tree and moving the element to
/// the list of inactive elements.
///
/// This method (indirectly) calls [deactivate] on the child.
///
/// The caller is responsible for removing the child from its child model.
/// Typically [deactivateChild] is called by the element itself while it is
/// updating its child model; however, during [GlobalKey] reparenting, the new
/// parent proactively calls the old parent's [deactivateChild], first using
/// [forgetChild] to cause the old parent to update its child model. ÀüÉÀüÒÀüÑ  Àü§Àü¨À „ÿÀ³À³‚[/// Remove the given child from the element's child list, in preparation for
/// the child being reused elsewhere in the element tree.
///
/// This updates the child model such that, e.g., [visitChildren] does not
/// walk that child anymore.
///
/// The element will still have a valid parent when this is called, and the
/// child's [Element.slot] value will be valid in the context of that parent.
/// After this is called, [deactivateChild] is called to sever the link to
/// this object.
///
/// The [update] is responsible for updating or creating the new child that
/// will replace this [child]. À¿ÀÈÀÇ  ÀÀ‘ÀÀÀ‚À"À"  À6À?À>  ÀFÀOÀN   À6ÀBÀB  ÀWÀ`À_   À>…À
­À
­‚B/// Transition from the "inactive" to the "active" lifecycle state.
///
/// The framework calls this method when a previously deactivated element has
/// been reincorporated into the tree. The framework does not call this method
/// the first time an element becomes active (i.e., from the "initial"
/// lifecycle state). Instead, the framework calls [mount] in that situation.
///
/// See the lifecycle documentation for [Element] for additional information.
///
/// Implementations of this method should start with a call to the inherited
/// method, as in `super.activate()`.  À
—À
˜ÀC†fÀ\À\‚ä/// Transition from the "active" to the "inactive" lifecycle state.
///
/// The framework calls this method when a previously active element is moved
/// to the list of inactive elements. While in the inactive state, the element
/// will not appear on screen. The element can remain in the inactive state
/// only until the end of the current animation frame. At the end of the
/// animation frame, if the element has not be reactivated, the framework will
/// unmount the element.
///
/// This is (indirectly) called by [deactivateChild].
///
/// See the lifecycle documentation for [Element] for additional information.
///
/// Implementations of this method should end with a call to the inherited
/// method, as in `super.deactivate()`.  ÀFÀGÀ­€øÀRÀR€ˆ/// Called, in debug mode, after children have been deactivated (see [deactivate]).
///
/// This method is not called in release builds.  À<À=À©†5ÀRÀRƒn/// Transition from the "inactive" to the "defunct" lifecycle state.
///
/// Called when the framework determines that an inactive element will never
/// be reactivated. At the end of each animation frame, the framework calls
/// [unmount] on any remaining inactive elements, preventing inactive elements
/// from remaining inactive for longer than a single animation frame.
///
/// After this function is called, the element will not be incorporated into
/// the tree again.
///
/// Any resources this element holds should be released at this point. For
/// example, [RenderObjectElement.unmount] calls [RenderObject.dispose] and
/// nulls out its reference to the render object.
///
/// See the lifecycle documentation for [Element] for additional information.
///
/// Implementations of this method should end with a call to the inherited
/// method, as in `super.unmount()`.  À<À=Àâ†4À àÀ à…Æ/// Whether the child in the provided `slot` (or one of its descendants) must
/// insert a [RenderObject] into its ancestor [RenderObjectElement] by calling
/// [RenderObjectElement.insertRenderObjectChild] on it.
///
/// This method is used to define non-rendering zones in the element tree (see
/// [WidgetsBinding] for an explanation of rendering and non-rendering zones):
///
/// Most branches of the [Element] tree are expected to eventually insert a
/// [RenderObject] into their [RenderObjectElement] ancestor to construct the
/// render tree. However, there is a notable exception: an [Element] may
/// expect that the occupant of a certain child slot creates a new independent
/// render tree and therefore is not allowed to insert a render object into
/// the existing render tree. Those elements must return false from this
/// method for the slot in question to signal to the child in that slot that
/// it must not call [RenderObjectElement.insertRenderObjectChild] on its
/// ancestor.
///
/// As an example, the element backing the [ViewAnchor] returns false from
/// this method for the [ViewAnchor.view] slot to enforce that it is occupied
/// by e.g. a [View] widget, which will ultimately bootstrap a separate
/// render tree for that view. Another example is the [ViewCollection] widget,
/// which returns false for all its slots for the same reason.
///
/// Overriding this method is not common, as elements behaving in the way
/// described above are rare. À! À!	À!   À!ƒÀ!4À!4   À!À!À<·‚ëÀ<¼À<¼    À?¦€àÀ@À@W/// Returns `true` if [dependOnInheritedElement] was previously called with [ancestor]. À@/À@AÀ@@  À@ À@À@ŠÀ@¦À@¦  À@¿À@ÑÀ@Ğ  À@ÛÀ@äÀ@ã  À@ŠÀ@‹ÀA¨}ÀA·ÀA· ÀAÚÀAÚÀAÚÀAöÀAÿÀAş  ÀA¨ÀA©ÀC)€–ÀC8ÀC8 ÀCVÀCVÀCV ÀC)ÀC*ÀCÃ€ÄÀCáÀCá ÀD	ÀD	ÀD	 ÀCÃÀCÄÀD‹‚ ÀF9ÀF9‰/// Called in [Element.mount] and [Element.activate] to register this element in
/// the notification tree.
///
/// This method is only exposed so that [NotifiableElementMixin] can be implemented.
/// Subclasses of [Element] that wish to respond to notifications should mix that
/// in instead.
///
/// See also:
///   * [NotificationListener], a widget that allows listening to notifications.  ÀF'ÀF(ÀF€ÀF”ÀF”    ÀG!/ÀG0ÀG0 ÀGNÀGNÀGN ÀG!ÀG"ÀHT¾ÀHcÀHc ÀH{ÀH{ÀH{ ÀHTÀHUÀJ³ÀJ%ÀJ% ÀJAÀJAÀJA ÀJÀJÀKÍ~ÀKÜÀKÜ ÀKûÀKûÀKû ÀKÍÀKÎÀMOÀM`ÀM`  ÀMv!ÀM‘ÀM  ÀMOÀMPÀNY‚İÀP[ÀP[Û/// Called when a dependency of this element changes.
///
/// The [dependOnInheritedWidgetOfExactType] registers this element as depending on
/// inherited information of the given type. When the information of that type
/// changes at this location in the tree (e.g., because the [InheritedElement]
/// updated to a new [InheritedWidget] and
/// [InheritedWidget.updateShouldNotify] returned true), the framework calls
/// this function to notify this element of the change.  ÀPEÀPFÀQ:ƒ%ÀQ?ÀQ?  ÀQaÀQiÀQh   ÀTcÊÀTìÀTì{/// Returns a description of what caused this element to be created.
///
/// Useful for debugging the source of an element. ÀU	ÀUÀU   ÀV1´ÀWÀW€Ë/// Returns the parent chain from this element back to the root of the tree.
///
/// Useful for debug display of a tree of Elements with only nodes in the path
/// from the root to this Element expanded.   ÀWé€ÀWúÀWú  ÀXÀXÀX  ÀWéÀWêÀXn€›ÀXµÀXµ1/// A short, textual description of this element.  ÀX¢ÀX£ÀY€²ÀY)ÀY)  ÀY<ÀYEÀYD  ÀYJÀYaÀY`  ÀYÀYÀYÃ…ìÀYÔÀYÔ  ÀYè&ÀZÀZ  ÀYÃÀYÄÀ_³€ïÀ_ÕÀ_Õ   À_³À_´Àc½ŠpÀe*Àe*Y/// Marks the element as dirty and adds it to the global list of widgets to
/// rebuild in the next frame.
///
/// Since it is inefficient to build an element twice in one frame,
/// applications and widgets should be structured so as to only mark
/// widgets dirty during event handlers before the frame begins, not during
/// the build itself.   Àn1›IÀ… À… •·/// Cause the widget to update itself. In debug builds, also verify various
/// invariants.
///
/// Called by the [BuildOwner] when [BuildOwner.scheduleBuildFor] has been
/// called to mark this element dirty, by [mount] when the element is first
/// built, and by [update] when the widget has changed.
///
/// The method will only rebuild if [dirty] is true. To rebuild regardless
/// of the [dirty] flag, set `force` to true. Forcing a rebuild is convenient
/// from [update], during which [dirty] is false.
///
/// ## When rebuilds happen
///
/// ### Terminology
///
/// [Widget]s represent the configuration of [Element]s. Each [Element] has a
/// widget, specified in [Element.widget]. The term "widget" is often used
/// when strictly speaking "element" would be more correct.
///
/// While an [Element] has a current [Widget], over time, that widget may be
/// replaced by others. For example, the element backing a [ColoredBox] may
/// first have as its widget a [ColoredBox] whose [ColoredBox.color] is blue,
/// then later be given a new [ColoredBox] whose color is green.
///
/// At any particular time, multiple [Element]s in the same tree may have the
/// same [Widget]. For example, the same [ColoredBox] with the green color may
/// be used in multiple places in the widget tree at the same time, each being
/// backed by a different [Element].
///
/// ### Marking an element dirty
///
/// An [Element] can be marked dirty between frames. This can happen for various
/// reasons, including the following:
///
/// * The [State] of a [StatefulWidget] can cause its [Element] to be marked
///   dirty by calling the [State.setState] method.
///
/// * When an [InheritedWidget] changes, descendants that have previously
///   subscribed to it will be marked dirty.
///
/// * During a hot reload, every element is marked dirty (using [Element.reassemble]).
///
/// ### Rebuilding
///
/// Dirty elements are rebuilt during the next frame. Precisely how this is
/// done depends on the kind of element. A [StatelessElement] rebuilds by
/// using its widget's [StatelessWidget.build] method. A [StatefulElement]
/// rebuilds by using its widget's state's [State.build] method. A
/// [RenderObjectElement] rebuilds by updating its [RenderObject].
///
/// In many cases, the end result of rebuilding is a single child widget
/// or (for [MultiChildRenderObjectElement]s) a list of children widgets.
///
/// These child widgets are used to update the [widget] property of the
/// element's child (or children) elements. The new [Widget] is considered to
/// correspond to an existing [Element] if it has the same [Type] and [Key].
/// (In the case of [MultiChildRenderObjectElement]s, some effort is put into
/// tracking widgets even when they change order; see
/// [RenderObjectElement.updateChildren].)
///
/// If there was no corresponding previous child, this results in a new
/// [Element] being created (using [Widget.createElement]); that element is
/// then itself built, recursively.
///
/// If there was a child previously but the build did not provide a
/// corresponding child to update it, then the old child is discarded (or, in
/// cases involving [GlobalKey] reparenting, reused elsewhere in the element
/// tree).
///
/// The most common case, however, is that there was a corresponding previous
/// child. This is handled by asking the child [Element] to update itself
/// using the new child [Widget]. In the case of [StatefulElement]s, this
/// is what triggers [State.didUpdateWidget].
///
/// ### Not rebuilding
///
/// Before an [Element] is told to update itself with a new [Widget], the old
/// and new objects are compared using `operator ==`.
///
/// In general, this is equivalent to doing a comparison using [identical] to
/// see if the two objects are in fact the exact same instance. If they are,
/// and if the element is not already marked dirty for other reasons, then the
/// element skips updating itself as it can determine with certainty that
/// there would be no value in updating itself or its descendants.
///
/// It is strongly advised to avoid overriding `operator ==` on [Widget]
/// objects. While doing so seems like it could improve performance, in
/// practice, for non-leaf widgets, it results in O(NÂ²) behavior. This is
/// because by necessity the comparison would have to include comparing child
/// widgets, and if those child widgets also implement `operator ==`, it
/// ultimately results in a complete walk of the widget tree... which is then
/// repeated at each level of the tree. In practice, just rebuilding is
/// cheaper. (Additionally, if _any_ subclass of [Widget] used in an
/// application implements `operator ==`, then the compiler cannot inline the
/// comparison anywhere, because it has to treat the call as virtual just in
/// case the instance happens to be one that has an overridden operator.)
///
/// Instead, the best way to avoid unnecessary rebuilds is to cache the
/// widgets that are returned from [State.build], so that each frame the same
/// widgets are used until such time as they change. Several mechanisms exist
/// to encourage this: `const` widgets, for example, are a form of automatic
/// caching (if a widget is constructed using the `const` keyword, the same
/// instance is returned each time it is constructed with the same arguments).
///
/// Another example is the [AnimatedBuilder.child] property, which allows the
/// non-animating parts of a subtree to remain static even as the
/// [AnimatedBuilder.builder] callback recreates the other components. À…)À…/À….  À„¾À„¿À„ÅÀ„ÙÀ„ÆÀ„İÀ„ŞÀ„äÀ„÷À„åÀ„ûÀ„üÀ…À…À…À…6À‰~ÀŠYÀŠY€­/// Cause the widget to update itself.
///
/// Called by [rebuild] after the appropriate checks have been made.
///
/// The base implementation only clears the [dirty] flag.  ÀŠ6ÀŠ7ÀŠCÀŠD ÀŠ‡‚aÀŠ‡ÀŠ  ÀŠÏ€ÀŠÏ ÀŠÏÀŠí  ÀŠô
ÀŠûÀŠú  À‹À‹À‹  À‹&À‹6À‹5  À‹@À‹FÀ‹E  À‹PÀ‹`À‹kÀ‹k    À‹xnÀ‹™À‹™  À‹£)À‹ÅÀ‹Ä  À‹xÀ‹y À“`ÀÀ’òƒÜ/// A widget that renders an exception's message.
///
/// This widget is used when a build method fails, to help with determining
/// where the problem lies. Exceptions are also logged to the console, which you
/// can read using `flutter logs`. The console will also include additional
/// information such as the stack trace for the exception.
///
/// It is possible to override this widget.
///
/// {@tool dartpad}
/// This example shows how to override the standard error widget builder in release
/// mode, but use the standard one in debug mode.
///
/// The error occurs when you click the "Error Prone" button.
///
/// ** See code in examples/api/lib/widgets/framework/error_widget.0.dart **
/// {@end-tool}
///
/// See also:
///
///  * [FlutterError.onError], which can be set to a method that exits the
///    application if that is preferable to showing an error message.
///  * <https://docs.flutter.dev/testing/errors>, more information about error
///    handling in Flutter. À“!‚lÀ”æ À”æÀ”ñ ²/// Creates a widget that displays the given exception.
///
/// The message will be the stringification of the given exception, unless
/// computing that value itself throws an exception, in which case it will
/// be the string "Error".
///
/// If this object is inspected from an IDE or the devtools, and the original
/// exception is a [FlutterError] object, the original exception itself will
/// be shown in the inspection output.À”òÀ”úÀ”ù  À•À•
À•À•À•(À•À•?À•1À•[À•gÀ•KÀ•AÀ•NÀ•]À•iÀ•uÀ•zÀ•‹À•~À•{À•€À•‰À•ŠÀ•‘;À–OÀ–ZÀ–[À–fÀ–[€µ/// Creates a widget that displays the given error message.
///
/// An explicit [FlutterError] can be provided to be reported to inspection
/// tools. It need not match the message.À–hÀ–nÀ–m  À–{À–ŠÀ–‰  À–wÀ–¥À–—À–§À–´À–¹À–ÊÀ–½À–ºÀ–¿À–ÈÀ–ÉÀ–Ğ†?ÀœëÀœë…Æ/// The configurable factory for [ErrorWidget].
///
/// When an error occurs while building a widget, the broken widget is
/// replaced by the widget returned by this function. By default, an
/// [ErrorWidget] is returned.
///
/// The system is typically in an unstable state when this function is called.
/// An exception has just been thrown in the middle of build (and possibly
/// layout), so surrounding widgets and render objects may be in a rather
/// fragile state. The framework itself (especially the [BuildOwner]) may also
/// be confused, and additional exceptions are quite likely to be thrown.
///
/// Because of this, it is highly recommended that the widget returned from
/// this function perform the least amount of work possible. A
/// [LeafRenderObjectWidget] is the best choice, especially one that
/// corresponds to a [RenderBox] that can handle the most absurd of incoming
/// constraints. The default constructor maps to a [RenderErrorBox].
///
/// The default behavior is to show the exception's message in debug mode,
/// and to show nothing but a gray background in release builds.
///
/// See also:
///
///  * [FlutterError.onError], which is typically called with the same
///    [FlutterErrorDetails] object immediately prior to this callback being
///    invoked, and which can also be configured to control how errors are
///    reported.
///  * <https://docs.flutter.dev/testing/errors>, more information about error
///    handling in Flutter.ÀœõÀ Z2À …À …/// The message to display. À !À ¤À ¤    À°À"À"  À=ÀRÀQ   ÀÈÀÖÀÖ  ÀáÀêÀé   À ¶ZÀ ÌÀ Ì  À ßÀ íÀ ì  À ¶À ·À¡YÀ¡%À¡%  À¡9&À¡VÀ¡U  À¡À¡ À¬™Œ€À¬™À­˜€ï/// An [Element] that composes other [Element]s.
///
/// Rather than creating a [RenderObject] directly, a [ComponentElement] creates
/// [RenderObject]s indirectly by creating other [Element]s.
///
/// Contrast with [RenderObjectElement]. À­½iÀ® À®À® G/// Creates an element that uses the given widget as its configuration.À®À®À®   À®*À®3À®3  À®>À®CÀ®C À®VÀ®_9À®tÀ®t   À®_À®`À®œ>À®µÀ®µ   À®œÀ® À®Ş€äÀ®ïÀ®ï  À®õÀ®ÿÀ®ş  À¯À¯À¯  À®ŞÀ®ßÀ¯Æ€ À¯ËÀ¯Ë    À°j†âÀ²À²V/// Calls the [StatelessWidget.build] method of the [StatelessWidget] object
/// (for stateless widgets) or the [State.build] method of the [State] object
/// (for stateful widgets) and then updates the widget tree.
///
/// Called automatically during [mount] to generate the first build, and by
/// [rebuild] when the element needs updating.  À±ÍÀ±ÎÀ±ÙÀ±ÚÀ±àÀ²À±áÀ·P€ÌÀ¸À¸€©/// Subclasses should override this function to actually call the appropriate
/// `build` function (e.g., [StatelessWidget.build] or [State.build]) for
/// their widget.  À¸ À¸À¸ tÀ¸1À¸1  À¸?À¸OÀ¸N  À¸ À¸!À¸˜À¸©À¸©  À¸µÀ¸¾À¸½  À¸˜À¸™ À¹ÒÀ¹À¹fD/// An [Element] that uses a [StatelessWidget] as its configuration. À¹”yÀ¹Ş À¹ŞÀ¹î G/// Creates an element that uses the given widget as its configuration.À¹ïÀºÀº      ÀºFÀº$Àº$   ÀºÀºÀº[€ÀºlÀºl  ÀºsÀº„Àºƒ  Àº[Àº\ Àºï£äÀºïÀ»9C/// An [Element] that uses a [StatefulWidget] as its configuration. À»f„qÀ»° À»°À»¿ G/// Creates an element that uses the given widget as its configuration.À»ÀÀ»ĞÀ»Ï  À»àÀ»ÙÀ»âÀ»èÀ»éÀ»ôÀ»õÀ»øÀ»ıÀ¼À»şÀÁIÀÁ`ÀÁ`  ÀÚT‚XÀÜÀÜ‚"/// This controls whether we should call [State.didChangeDependencies] from
/// the start of [build], to avoid calls when the [State] will not get built.
/// This can happen when the widget has dropped out of the tree, but depends
/// on an [InheritedWidget] that is still in the tree.
///
/// It is set initially to false, since [_firstBuild] makes the initial call
/// on the [state]. When it is true, [build] will call
/// `state.didChangeDependencies` and then sets it to false. Subsequent calls
/// to [didChangeDependencies] set it to true.ÀÜ§ÀÀ7ÀÁ5ÀÁ5/// The [State] instance associated with this location in the tree.
///
/// There is a one-to-one relationship between [State] objects and the
/// [StatefulElement] objects that hold them. The [State] objects are created
/// by [StatefulElement] in [mount].    À¿Û0À¿îÀ¿î   À¿ÛÀ¿ÜÀÁkSÀÁ|ÀÁ|   ÀÁkÀÁlÀÁÂƒçÀÁÓÀÁÓ   ÀÁÂÀÁÃÀÅ­€¶ÀÅ¾ÀÅ¾   ÀÅ­ÀÅ®ÀÆgƒœÀÆxÀÆx  ÀÆÀÆÀÆ  ÀÆgÀÆhÀÊ™ÀÊÀÊ   ÀÊÀÊÀË¤SÀËµÀËµ   ÀË¤ÀË¥ÀËû‚ÙÀÌÀÌ   ÀËûÀËüÀÎØ‹xÀÎôÀÎô  ÀÏÀÏÀÏ  ÀÏ ÀÏ)ÀÏ(  ÀÎØÀÎÙÀÜ±tÀÜÂÀÜÂ   ÀÜ±ÀÜ²Àİ)€ÂÀİEÀİE  ÀİXÀİaÀİ`  ÀİfÀİ}Àİ|  Àİ)Àİ*Àİï€âÀŞ ÀŞ   ÀŞ&ÀŞ1ÀŞ0  ÀİïÀİğ ÀŞÕ„ÀŞÕÀß%@/// An [Element] that uses a [ProxyWidget] as its configuration. ÀßOPÀßx ÀßxÀß„ &/// Initializes fields for subclasses.Àß…Àß˜Àß—      Àß£<Àß¶Àß¶   Àß£Àß¤Àßã€şÀßôÀßô  ÀßûÀàÀà  ÀßãÀßäÀàåWÀáğÀáğ€î/// Called during build when the [widget] has changed.
///
/// By default, calls [notifyClients]. Subclasses may override this method to
/// avoid calling [notifyClients] unnecessarily (e.g. if the old and new
/// widgets are equivalent). ÀáøÀâÀâ  ÀáŞÀáßÀâ@0ÀãAÀãA€ä/// Notify other objects that the widget associated with this element has
/// changed.
///
/// Called during [update] (via [updated]) after changing the widget
/// associated with this element but before rebuilding this element. ÀãOÀãfÀãe  Àã/Àã0 ÀãtŒÍÀãtÀãÀE/// An [Element] that uses a [ParentDataWidget] as its configuration.ÀãÒÀãÒÀãÒÀä~ÀäK ÀäKÀä\ G/// Creates an element that uses the given widget as its configuration.Àä] ÀäxÀäw    Àäƒ´ÀåJÀåJ€³/// Returns the [Type] of [ParentData] that this element has been configured
/// for.
///
/// This is only available in debug mode. It will throw in profile and
/// release modes.    Àæ;¹Àæ@Àæ@  ÀæQÀæfÀæe   Àçø‡ËÀîóÀîó†µ/// Calls [ParentDataWidget.applyParentData] on the given widget, passing it
/// the [RenderObject] whose parent data this element is ultimately
/// responsible for.
///
/// This allows a render object's [RenderObject.parentData] to be modified
/// without triggering a build. This is generally ill-advised, but makes sense
/// in situations such as the following:
///
///  * Build and layout are currently under way, but the [ParentData] in question
///    does not affect layout, and the value to be applied could not be
///    determined before build and layout (e.g. it depends on the layout of a
///    descendant).
///
///  * Paint is currently under way, but the [ParentData] in question does not
///    affect layout or paint, and the value to be applied could not be
///    determined before paint (e.g. it depends on the compositing phase).
///
/// In either case, the next build is expected to cause this element to be
/// configured with the given new widget (or a widget with equivalent data).
///
/// Only [ParentDataWidget]s that return true for
/// [ParentDataWidget.debugCanApplyOutOfTurn] can be applied this way.
///
/// The new widget must have the same child as the current widget.
///
/// An example of when this is used is the [AutomaticKeepAlive] widget. If it
/// receives a notification during the build of one of its descendants saying
/// that its child must be kept alive, it will apply a [KeepAlive] widget out
/// of turn. This is safe, because by definition the child is already alive,
/// and therefore this will not change the behavior of the parent this frame.
/// It is more efficient than requesting an additional frame just for the
/// purpose of updating the [KeepAlive] widget. ÀïÀïÀï   ÀïÇxÀïØÀïØ  ÀïæÀïûÀïú  ÀïÇÀïÈ ÀğCœ ÀğCÀğE/// An [Element] that uses an [InheritedWidget] as its configuration. Àğ¹yÀñ ÀñÀñ G/// Creates an element that uses the given widget as its configuration.ÀñÀñ+Àñ*   Àñ6EÀñRÀñR Àñ`ÀñgÀñxÀñhÀñqÀñwÀñyÀñz  	Àñ€RÀñ‘Àñ‘   Àñ€ÀñÀòÖ€—ÀòçÀòç   ÀòÖÀò×Àóq„°À÷ÖÀ÷Ö„/// Returns the dependencies value recorded for [dependent]
/// with [setDependencies].
///
/// Each dependent element is mapped to a single object value
/// which represents how the element depends on this
/// [InheritedElement]. This value is null by default and by default
/// dependent elements are rebuilt unconditionally.
///
/// Subclasses can manage these values with [updateDependencies]
/// so that they can selectively rebuild dependents in
/// [notifyDependent].
///
/// This method is typically only called in overrides of [updateDependencies].
///
/// See also:
///
///  * [updateDependencies], which is called each time a dependency is
///    created with [dependOnInheritedWidgetOfExactType].
///  * [setDependencies], which sets dependencies value for a dependent
///    element.
///  * [notifyDependent], which can be overridden to use a dependent's
///    dependencies value to decide if the dependent needs to be rebuilt.
///  * [InheritedModel], which is an example of a class that uses this method
///    to manage dependency values. À÷æÀ÷ïÀ÷î  À÷ÁÀ÷ÂÀø%„ÊÀü”Àü”„0/// Sets the value returned by [getDependencies] value for [dependent].
///
/// Each dependent element is mapped to a single object value
/// which represents how the element depends on this
/// [InheritedElement]. The [updateDependencies] method sets this value to
/// null by default so that dependent elements are rebuilt unconditionally.
///
/// Subclasses can manage these values with [updateDependencies]
/// so that they can selectively rebuild dependents in [notifyDependent].
///
/// This method is typically only called in overrides of [updateDependencies].
///
/// See also:
///
///  * [updateDependencies], which is called each time a dependency is
///    created with [dependOnInheritedWidgetOfExactType].
///  * [getDependencies], which returns the current value for a dependent
///    element.
///  * [notifyDependent], which can be overridden to use a dependent's
///    [getDependencies] value to decide if the dependent needs to be rebuilt.
///  * [InheritedModel], which is an example of a class that uses this method
///    to manage dependency values. Àü¤Àü­Àü¬  Àü·ÀüÀÀü¿  Àü‚ÀüƒÀüó„ŠÀÀƒê/// Called by [dependOnInheritedWidgetOfExactType] when a new [dependent] is added.
///
/// Each dependent element can be mapped to a single object value with
/// [setDependencies]. This method can lookup the existing dependencies with
/// [getDependencies].
///
/// By default this method sets the inherited dependencies for [dependent]
/// to null. This only serves to record an unconditional dependency on
/// [dependent].
///
/// Subclasses can manage their own dependencies values so that they
/// can selectively rebuild dependents in [notifyDependent].
///
/// See also:
///
///  * [getDependencies], which returns the current value for a dependent
///    element.
///  * [setDependencies], which sets the value for a dependent element.
///  * [notifyDependent], which can be overridden to use a dependent's
///    dependencies value to decide if the dependent needs to be rebuilt.
///  * [InheritedModel], which is an example of a class that uses this method
///    to manage dependency values. À/À8À7  ÀBÀKÀJ  À
ÀÀƒFÀSÀS‚Ÿ/// Called by [notifyClients] for each dependent.
///
/// Calls `dependent.didChangeDependencies()` by default.
///
/// Subclasses can override this method to selectively call
/// [didChangeDependencies] based on the value of [getDependencies].
///
/// See also:
///
///  * [updateDependencies], which is called each time a dependency is
///    created with [dependOnInheritedWidgetOfExactType].
///  * [getDependencies], which returns the current value for a dependent
///    element.
///  * [setDependencies], which sets the value for a dependent element.
///  * [InheritedModel], which is an example of a class that uses this method
///    to manage dependency values. Àc#À~À}  ÀˆÀ‘À  ÀAÀBÀËöÀvÀvy/// Called by [Element.deactivate] to remove the provided `dependent` [Element] from this [InheritedElement].
///
/// After the dependent is removed, [Element.didChangeDependencies] will no
/// longer be called on it when this [InheritedElement] notifies its dependents.
///
/// Subclasses can override this method to release any resources retained for
/// a given [dependent]. À†ÀÀ  ÀSÀTÀ`ÀaÀÅ®ÀàÀà€ı/// Calls [Element.didChangeDependencies] of all dependent elements, if
/// [InheritedWidget.updateShouldNotify] returns true.
///
/// Called by [update], immediately prior to [build].
///
/// Calls [notifyClients] to actually trigger the notifications. ÀèÀùÀø  ÀÏÀĞÀw„jÀ
À
ş/// Notifies all dependent elements that this inherited widget has changed, by
/// calling [Element.didChangeDependencies].
///
/// This method must only be called during the build phase. Usually this
/// method is called automatically when an inherited widget is rebuilt, e.g.
/// as a result of calling [State.setState] above the inherited widget.
///
/// See also:
///
///  * [InheritedNotifier], a subclass of [InheritedWidget] that also calls
///    this method when its [Listenable] sends a notification. À
«À
¼À
»  À
ŒÀ
 ÀåÀ Z’ÀåÀ.<¡G/// An [Element] that uses a [RenderObjectWidget] as its configuration.
///
/// [RenderObjectElement] objects have an associated [RenderObject] widget in
/// the render tree, which handles concrete operations like laying out,
/// painting, and hit testing.
///
/// Contrast with [ComponentElement].
///
/// For details on the lifecycle of an element, see the discussion at [Element].
///
/// ## Writing a RenderObjectElement subclass
///
/// There are three common child models used by most [RenderObject]s:
///
/// * Leaf render objects, with no children: The [LeafRenderObjectElement] class
///   handles this case.
///
/// * A single child: The [SingleChildRenderObjectElement] class handles this
///   case.
///
/// * A linked list of children: The [MultiChildRenderObjectElement] class
///   handles this case.
///
/// Sometimes, however, a render object's child model is more complicated. Maybe
/// it has a two-dimensional array of children. Maybe it constructs children on
/// demand. Maybe it features multiple lists. In such situations, the
/// corresponding [Element] for the [Widget] that configures that [RenderObject]
/// will be a new subclass of [RenderObjectElement].
///
/// Such a subclass is responsible for managing children, specifically the
/// [Element] children of this object, and the [RenderObject] children of its
/// corresponding [RenderObject].
///
/// ### Specializing the getters
///
/// [RenderObjectElement] objects spend much of their time acting as
/// intermediaries between their [widget] and their [renderObject]. It is
/// generally recommended against specializing the [widget] getter and
/// instead casting at the various call sites to avoid adding overhead
/// outside of this particular implementation.
///
/// ```dart
/// class FooElement extends RenderObjectElement {
///   FooElement(super.widget);
///
///   // Specializing the renderObject getter is fine because
///   // it is not performance sensitive.
///   @override
///   RenderFoo get renderObject => super.renderObject as RenderFoo;
///
///   void _foo() {
///     // For the widget getter, though, we prefer to cast locally
///     // since that results in better overall performance where the
///     // casting isn't needed:
///     final Foo foo = widget as Foo;
///     // ...
///   }
///
///   // ...
/// }
/// ```
///
/// ### Slots
///
/// Each child [Element] corresponds to a [RenderObject] which should be
/// attached to this element's render object as a child.
///
/// However, the immediate children of the element may not be the ones that
/// eventually produce the actual [RenderObject] that they correspond to. For
/// example, a [StatelessElement] (the element of a [StatelessWidget])
/// corresponds to whatever [RenderObject] its child (the element returned by
/// its [StatelessWidget.build] method) corresponds to.
///
/// Each child is therefore assigned a _[slot]_ token. This is an identifier whose
/// meaning is private to this [RenderObjectElement] node. When the descendant
/// that finally produces the [RenderObject] is ready to attach it to this
/// node's render object, it passes that slot token back to this node, and that
/// allows this node to cheaply identify where to put the child render object
/// relative to the others in the parent render object.
///
/// A child's [slot] is determined when the parent calls [updateChild] to
/// inflate the child (see the next section). It can be updated by calling
/// [updateSlotForChild].
///
/// ### Updating children
///
/// Early in the lifecycle of an element, the framework calls the [mount]
/// method. This method should call [updateChild] for each child, passing in
/// the widget for that child, and the slot for that child, thus obtaining a
/// list of child [Element]s.
///
/// Subsequently, the framework will call the [update] method. In this method,
/// the [RenderObjectElement] should call [updateChild] for each child, passing
/// in the [Element] that was obtained during [mount] or the last time [update]
/// was run (whichever happened most recently), the new [Widget], and the slot.
/// This provides the object with a new list of [Element] objects.
///
/// Where possible, the [update] method should attempt to map the elements from
/// the last pass to the widgets in the new pass. For example, if one of the
/// elements from the last pass was configured with a particular [Key], and one
/// of the widgets in this new pass has that same key, they should be paired up,
/// and the old element should be updated with the widget (and the slot
/// corresponding to the new widget's new position, also). The [updateChildren]
/// method may be useful in this regard.
///
/// [updateChild] should be called for children in their logical order. The
/// order can matter; for example, if two of the children use [PageStorage]'s
/// `writeState` feature in their build method (and neither has a [Widget.key]),
/// then the state written by the first will be overwritten by the second.
///
/// #### Dynamically determining the children during the build phase
///
/// The child widgets need not necessarily come from this element's widget
/// verbatim. They could be generated dynamically from a callback, or generated
/// in other more creative ways.
///
/// #### Dynamically determining the children during layout
///
/// If the widgets are to be generated at layout time, then generating them in
/// the [mount] and [update] methods won't work: layout of this element's render
/// object hasn't started yet at that point. Instead, the [update] method can
/// mark the render object as needing layout (see
/// [RenderObject.markNeedsLayout]), and then the render object's
/// [RenderObject.performLayout] method can call back to the element to have it
/// generate the widgets and call [updateChild] accordingly.
///
/// For a render object to call an element during layout, it must use
/// [RenderObject.invokeLayoutCallback]. For an element to call [updateChild]
/// outside of its [update] method, it must use [BuildOwner.buildScope].
///
/// The framework provides many more checks in normal operation than it does
/// when doing a build during layout. For this reason, creating widgets with
/// layout-time build semantics should be done with great care.
///
/// #### Handling errors when building
///
/// If an element calls a builder function to obtain widgets for its children,
/// it may find that the build throws an exception. Such exceptions should be
/// caught and reported using [FlutterError.reportError]. If a child is needed
/// but a builder has failed in this way, an instance of [ErrorWidget] can be
/// used instead.
///
/// ### Detaching children
///
/// It is possible, when using [GlobalKey]s, for a child to be proactively
/// removed by another element before this element has been updated.
/// (Specifically, this happens when the subtree rooted at a widget with a
/// particular [GlobalKey] is being moved from this element to an element
/// processed earlier in the build phase.) When this happens, this element's
/// [forgetChild] method will be called with a reference to the affected child
/// element.
///
/// The [forgetChild] method of a [RenderObjectElement] subclass must remove the
/// child element from its child list, so that when it next [update]s its
/// children, the removed child is not considered.
///
/// For performance reasons, if there are many elements, it may be quicker to
/// track which elements were forgotten by storing them in a [Set], rather than
/// proactively mutating the local record of the child list and the identities
/// of all the slots. For example, see the implementation of
/// [MultiChildRenderObjectElement].
///
/// ### Maintaining the render object tree
///
/// Once a descendant produces a render object, it will call
/// [insertRenderObjectChild]. If the descendant's slot changes identity, it
/// will call [moveRenderObjectChild]. If a descendant goes away, it will call
/// [removeRenderObjectChild].
///
/// These three methods should update the render tree accordingly, attaching,
/// moving, and detaching the given child render object from this element's own
/// render object respectively.
///
/// ### Walking the children
///
/// If a [RenderObjectElement] object has any children [Element]s, it must
/// expose them in its implementation of the [visitChildren] method. This method
/// is used by many of the framework's internal mechanisms, and so should be
/// fast. It is also used by the test framework and [debugDumpApp]. À.dÀ.® À.®À.Á G/// Creates an element that uses the given widget as its configuration.À.ÂÀ.ÜÀ.Û   À/òÀ0 À0   À0RÀ0WÀ0W À0jÀ0°1À0ÅÀ0Å  À.çÀ/„À/„y/// The underlying [RenderObject] for this element.
///
/// If this element has been [unmount]ed, this getter will throw.  À/gÀ/hÀ0<À0+À0+   À0À0À0s9À0ˆÀ0ˆ   À0sÀ0t À0æƒ[À0ûÀ0û    À4E‹êÀ4JÀ4J  À4m*À4’À4‘  À4À4¨À4§  À4¿À4ÊÀ4É  À4ã À4ïÀ4î   À@3‰.À@WÀ@W    ÀIe‚;ÀIvÀIv  ÀI|ÀI†ÀI…  ÀIÀI–ÀI•  ÀIeÀIfÀK¤ÀKµÀKµ  ÀK¼&ÀKÚÀKÙ  ÀK¤ÀK¥ÀL»€ÀLÀÀLÀ    ÀML€ÀM˜ÀM˜   ÀMLÀMMÀMî”ÀNPÀNP   ÀMîÀMïÀMõÀN	ÀMöÀNÀNÀNÀN'ÀNÀN+ÀN,ÀN2ÀNGÀN3ÀO†€åÀO—ÀO—   ÀO†ÀO‡ÀPo‚/ÀP€ÀP€   ÀPoÀPpÀR¢„åÀR§ÀR§  ÀR¹-ÀR×ÀRÖ   ÀW‹VÀWœÀWœ  ÀW§ÀW°ÀW¯  ÀW‹ÀWŒÀXå…cÀXöÀXö  ÀY	ÀYÀY  ÀXåÀXæÀ^L€ïÀ^]À^]   À^LÀ^MÀ_?‚3Àa$Àa$Â/// Insert the given child into [renderObject] at the given slot.
///
/// {@template flutter.widgets.RenderObjectElement.insertRenderObjectChild}
/// The semantics of `slot` are determined by this element. For example, if
/// this element has a single child, the slot should always be null. If this
/// element has a list of children, the previous sibling element wrapped in an
/// [IndexedSlot] is a convenient value for the slot.
/// {@endtemplate} Àa<ÀaTÀaS  ÀaZÀamÀal  ÀaÀaÀavƒğÀdëÀdëƒF/// Move the given child from the given old slot to the given new slot.
///
/// The given child is guaranteed to have [renderObject] as its parent.
///
/// {@macro flutter.widgets.RenderObjectElement.insertRenderObjectChild}
///
/// This method is only ever called if [updateChild] can end up being called
/// with an existing [Element] child and a `slot` that differs from the slot
/// that element was previously given. [MultiChildRenderObjectElement] does this,
/// for example. [SingleChildRenderObjectElement] does not (since the `slot` is
/// always null). An [Element] that has a specific set of slots with each child
/// always having the same slot (and where children in different slots are never
/// compared against each other for the purposes of updating one slot with the
/// element from another slot) would never call this. ÀeÀeÀe  Àe(Àe;Àe:  ÀeGÀeZÀeY  ÀdÙÀdÚÀejÀf/Àf/€ª/// Remove the given child from [renderObject].
///
/// The given child is guaranteed to have been inserted at the given `slot`
/// and have [renderObject] as its parent. ÀfGÀf_Àf^  ÀfeÀfxÀfw  ÀfÀfÀf€ôÀf’Àf’  Àf¦&ÀfÃÀfÂ  ÀfÀf‚ Àgy‚\ÀgyÀhÄ€Ñ/// Deprecated. Unused in the framework and will be removed in a future version
/// of Flutter.
///
/// Classes that extend this class can extend [RenderObjectElement] and mixin
/// [RootElementMixin] instead. Ài€ÁÀi­ Ài­ÀiÄ &/// Initializes fields for subclasses.ÀiÅÀiÌÀiË  Ài;Ài<ÀiFÀi©ÀiLÀiq    ÀhKÀhLÀhVÀh³ÀhZÀh}ÀmÍƒ.ÀmÍÀnK/// An [Element] that uses a [LeafRenderObjectWidget] as its configuration. ÀnW€‡Àn¡ Àn¡Àn¸ G/// Creates an element that uses the given widget as its configuration.Àn¹#Àn×ÀnÖ      ÀnâbÀnóÀnó  ÀnÿÀoÀo  ÀnâÀnãÀoHcÀoYÀoY  ÀoqÀoÀo~  Ào…ÀoÀo  ÀoHÀoIÀo¯uÀoÀÀoÀ  ÀoÖÀoäÀoã  ÀoêÀoóÀoò  ÀoûÀpÀp  Ào¯Ào°Àp(cÀp9Àp9  ÀpQÀp_Àp^  ÀpeÀpnÀpm  Àp(Àp)ÀpjÀp±Àp±   ÀpÀp Àpıˆ5ÀpıÀrNJ/// An [Element] that uses a [SingleChildRenderObjectWidget] as its configuration.
///
/// The child is optional.
///
/// This element subclass can be used for [RenderObjectWidget]s whose
/// [RenderObject]s use the [RenderObjectWithChildMixin] mixin. Such widgets are
/// expected to inherit from [SingleChildRenderObjectWidget]. Àr€•Àr× Àr×Àrõ G/// Creates an element that uses the given widget as its configuration.Àrö*ÀsÀs   Às&Às/Às/    Às:tÀsKÀsK  ÀsYÀsiÀsh  Às:Às;Às²ÀsÃÀsÃ  ÀsÏÀsØÀs×  Às²Às³Àt5€¹ÀtFÀtF  ÀtLÀtVÀtU  Àt]ÀtfÀte  Àt5Àt6Àtò€İÀuÀu  Àu
'Àu)Àu(  ÀtòÀtóÀuÓvÀuäÀuä  ÀuüÀv
Àv	  ÀvÀvÀv  ÀuÓÀuÔÀwMuÀw^Àw^  ÀwtÀw‚Àw  ÀwˆÀw‘Àw  Àw™Àw¢Àw¡  ÀwMÀwNÀwÆjÀw×Àw×  ÀwïÀwıÀwü  ÀxÀxÀx  ÀwÆÀwÇ Ày4•ÚÀy4À{½‚‚/// An [Element] that uses a [MultiChildRenderObjectWidget] as its configuration.
///
/// This element subclass can be used for [RenderObjectWidget]s whose
/// [RenderObject]s use the [ContainerRenderObjectMixin] mixin with a parent data
/// type that implements [ContainerParentDataMixin<RenderObject>]. Such widgets
/// are expected to inherit from [MultiChildRenderObjectWidget].
///
/// See also:
///
/// * [IndexedSlot], which is used as [Element.slot]s for the children of a
///   [MultiChildRenderObjectElement].
/// * [RenderObjectElement.updateChildren], which discusses why [IndexedSlot]
///   is used for the slots of the children. À{û€ÚÀ|E À|EÀ|b G/// Creates an element that uses the given widget as its configuration.À|c)À|‡À|†  À|”À|šÀ|ÓÀ|›À|œÀ|ºÀ|ÒÀ|»À|ÃÀ|ÉÀ|ÊÀ ÀÀ  À”:À§À§ À¼ÀÃÀËÀÄÀÌÀÍÀ|Ù€ğÀ}<À}<   À|ÙÀ|ÚÀ}Í/À~¢À~¢€”/// The current list of children of this element.
///
/// This list is filtered to hide elements that have been forgotten (using
/// [forgetChild]).  À~jÀ~kÀ~wÀ~x 	ÀÓƒÀäÀä  ÀüÀ€
À€	  À€À€'À€&  ÀÓÀÔÀZ«ÀkÀk  À†À”À“  ÀÀµÀ´  ÀÁÀØÀ×  ÀZÀ[Àƒ	JÀƒÀƒ  Àƒ2Àƒ@Àƒ?  ÀƒFÀƒOÀƒN  Àƒ	Àƒ
À„W€ÀÀ„hÀ„h  À„vÀ„†À„…  À„WÀ„XÀ…€ÊÀ…,À…,  À…8À…AÀ…@  À…À…À…éƒÀ…îÀ…î  À†À†À†   À‰n€áÀ‰‚À‰‚  À‰À‰˜À‰—  À‰¢À‰«À‰ª  À‰nÀ‰oÀŠS‚®ÀŠdÀŠd  ÀŠjÀŠtÀŠs  ÀŠ{ÀŠ„ÀŠƒ  ÀŠSÀŠTÀ‚ÀÀ  À&À;À:  ÀÀ À‰õÀÀçÇ/// A [RenderObjectElement] used to manage the root of a render tree.
///
/// Unlike any other render object element this element does not attempt to
/// attach its [renderObject] to the closest ancestor [RenderObjectElement].
/// Instead, subclasses must override [attachRenderObject] and
/// [detachRenderObject] to attach/detach the [renderObject] to whatever
/// instance manages the render tree (e.g. by assigning it to
/// [PipelineOwner.rootNode]). À‘nÀ‘g À‘gÀ‘| G/// Creates an element that uses the given widget as its configuration.À‘}À‘„À‘ƒ      À‘€À‘±À‘±  À‘ÄÀ‘ÍÀ‘Ì  À‘À‘À‘›À‘œÀ’1NÀ’SÀ’S   À’1À’2À’=À’>À’ƒ€À’”À’”  À’ŸÀ’¨À’§  À’ƒÀ’„À“…íÀ“À“     À™±À™À™Ä€¶/// A wrapper class for the [Element] that is the creator of a [RenderObject].
///
/// Setting a [DebugCreator] as [RenderObject.debugCreator] will lead to better
/// error messages. À™ÕXÀš ÀšÀš :/// Create a [DebugCreator] instance with input [Element].ÀšÀš%Àš$   Àš1>ÀšhÀšh&/// The creator of the [RenderObject].   ÀštBÀš‡Àš‡   ÀštÀšu Àœe„ÍÀœeÀÈ‚Q/// A value for [Element.slot] used for children of
/// [MultiChildRenderObjectElement]s.
///
/// A slot for a [MultiChildRenderObjectElement] consists of an [index]
/// identifying where the child occupying this slot is located in the
/// [MultiChildRenderObjectElement]'s child list and an arbitrary [value] that
/// can further define where the child occupying this slot fits in its
/// parent's child list.
///
/// See also:
///
///  * [RenderObjectElement.updateChildren], which discusses why this class is
///    used as slot values for the children of a [MultiChildRenderObjectElement].ÀÔÀÔÀÔÀìuÀŸ= ÀŸ=ÀŸH H/// Creates an [IndexedSlot] with the provided [index] and slot [value].ÀŸI
ÀŸOÀŸN  ÀŸU
ÀŸ[ÀŸZ   ÀŸetÀŸÔÀŸÔb/// Information to define where the child occupying this slot fits in its
/// parent's child list. ÀŸŞHÀ !À !6/// The index of this slot in the parent's child list. À ö:À¡
À¡
   À öÀ ÷ À +€ÇÀ EÀ E  À HÀ PÀ O  À +À ,À·À¸À¡48À¡4À¡¤i/// Used as a placeholder in [List<Element>] objects when the actual
/// elements are not yet determined. À¡Å,À¡Å À¡ÅÀ¡Ñ   À¡ÖÀ¡ÛÀ¡ïÀ¡ÜÀ¡âÀ¡íÀ¡îÀ¡õ-À¢	À¢	 À¢À¢ À¢!À¢'CÀ¢<À¢<   À¢'À¢(   À¢n€À¢nÀ¢t  À¢“À¢™ À¢™À¢¤       À¢«BÀ¢¿À¢¿   À¢«À¢¬  À „…‚SÀ „…À „ĞE/// Tracks the lifecycle of [State] objects when asserts are enabled.  À „äbÀ …?À …?V/// The [State] object has been created. [State.initState] is called at this
/// time. À …K€¬À …ìÀ …ì€œ/// The [State.initState] method has been called but the [State] object is
/// not yet ready to build. [State.didChangeDependencies] is called at this time. À …ücÀ †ZÀ †ZY/// The [State] object is ready to build and [State.dispose] has not yet been
/// called. À †dqÀ †ÎÀ †Îe/// The [State.dispose] method has been called and the [State] object is
/// no longer able to build.     ÀZÍ=ÀZÍÀZÒ   ÀZæÀZæÀZæ  ÀZïÀZïÀZï  ÀZ÷ÀZ÷ÀZ÷  À[À[À[          ÀB÷€¬ÀB÷ÀBü  ÀCÀCÀC   Àšº©ÀšºÀšÎ  ÀšâÀšóÀšò  ÀšıÀ›À›  À›À›À›  À›(*À›?À›>    À †ÚfÀ †ÚÀ ‡0/// The signature of [State.setState] functions.  À ‡/À ‡=À ‡<   Àb³Àb³Àc€Ó/// Signature for the callback to [BuildContext.visitChildElements].
///
/// The argument is the child being visited.
///
/// It is safe to call `element.visitChildElements` reentrantly within
/// this callback.  Àc®Àc·Àc¶   ÀcÁ€æÀcÁÀdl€¢/// Signature for the callback to [BuildContext.visitAncestorElements].
///
/// The argument is the ancestor being visited.
///
/// Return false to stop the walk.  Àd–ÀdŸÀd   ÀŒê‚#ÀŒêÀËØ/// Signature for the constructor that is called when an error occurs while
/// building a widget.
///
/// The argument provides information regarding the cause of the error.
///
/// See also:
///
///  * [ErrorWidget.builder], which can be set to override the default
///    [ErrorWidget] builder.
///  * [FlutterError.reportError], which is typically called with the same
///    [FlutterErrorDetails] object immediately prior to [ErrorWidget.builder]
///    being called.  ÀğÀÀ   À¢qÖÀ¢qÀ¤—/// Signature for a function that creates a widget, e.g. [StatelessWidget.build]
/// or [State.build].
///
/// Used by [Builder.builder], [OverlayEntry.builder], etc.
///
/// See also:
///
///  * [IndexedWidgetBuilder], which is similar but also takes an index.
///  * [TransitionBuilder], which is similar but also takes a child.
///  * [ValueWidgetBuilder], which is similar but takes a value and a child.  À¤1À¤?À¤>   À¤IòÀ¤IÀ¥ó¡/// Signature for a function that creates a widget for a given index, e.g., in a
/// list.
///
/// Used by [ListView.builder] and other APIs that use lazily-generated widgets.
///
/// See also:
///
///  * [WidgetBuilder], which is similar but only takes a [BuildContext].
///  * [TransitionBuilder], which is similar but also takes a child.
///  * [NullableIndexedWidgetBuilder], which is similar but may return null.  À¦À¦(À¦'  À¦0	À¦5À¦4   À¦=„À¦=Àª	ƒÃ/// Signature for a function that creates a widget for a given index, e.g., in a
/// list, but may return null.
///
/// Used by [SliverChildBuilderDelegate.builder] and other APIs that
/// use lazily-generated widgets where the child count is not known
/// ahead of time.
///
/// Unlike most builders, this callback can return null, indicating the index
/// is out of range. Whether and when this is valid depends on the semantics
/// of the builder. For example, [SliverChildBuilderDelegate.builder] returns
/// null when the index is out of range, where the range is defined by the
/// [SliverChildBuilderDelegate.childCount]; so in that case the `index`
/// parameter's value may determine whether returning null is valid or not.
///
/// See also:
///
///  * [WidgetBuilder], which is similar but only takes a [BuildContext].
///  * [TransitionBuilder], which is similar but also takes a child.
///  * [IndexedWidgetBuilder], which is similar but not nullable.  Àª9ÀªGÀªF  ÀªO	ÀªTÀªS   Àª\‚;Àª\À¬Né/// A builder that builds a widget given a child.
///
/// The child should typically be part of the returned widget tree.
///
/// Used by [AnimatedBuilder.builder], [ListenableBuilder.builder],
/// [WidgetsApp.builder], and [MaterialApp.builder].
///
/// See also:
///
/// * [WidgetBuilder], which is similar but only takes a [BuildContext].
/// * [IndexedWidgetBuilder], which is similar but also takes an index.
/// * [ValueWidgetBuilder], which is similar but takes a value and a child.  À¬rÀ¬€À¬  À¬ˆÀ¬‘À¬   À?‚¤À?À?Ó€Ä/// Mixin this class to allow receiving [Notification] objects dispatched by
/// child elements.
///
/// See also:
///   * [NotificationListener], for a widget that allows consuming notifications.     À?ù1ÀA ÀA €÷/// Called when a notification of the appropriate type arrives at this
/// location in the tree.
///
/// Return true to cancel the notification bubbling. Return false to
/// allow the notification to continue to be dispatched to further ancestors. ÀAÀAÀA   ÀA.|ÀA?ÀA?   ÀA.ÀA/ Ài×ƒôÀi×Àj€°/// Mixin for the element at the root of the tree.
///
/// Only root elements may have their owner set explicitly. All other
/// elements inherit their owner from their parent.     Àj®‚NÀlŸÀlŸ×/// Set the owner of the element. The owner will be propagated to all the
/// descendants of this element.
///
/// The owner manages the dirty elements list.
///
/// The [WidgetsBinding] introduces the primary owner,
/// [WidgetsBinding.buildOwner], and assigns it to the widget tree in the call
/// to [runApp]. The binding is responsible for driving the build pipeline by
/// calling the build owner's [BuildOwner.buildScope] method. See
/// [WidgetsBinding.drawFrame]. Àl«Àl·Àl¶   Àm €ÉÀmÀm  ÀmÀm!Àm   Àm(Àm1Àm0  Àm Àm ŠIª‹Ú‹Ú/// An annotation used by test_analysis package to verify patterns are followed
/// that allow for tree-shaking of both fields and their initializers. This
/// annotation has no impact on code by itself, but indicates the following pattern
/// should be followed for a given field:
///
/// ```dart
/// class Bar {
///   final Object? bar = kDebugMode ? Object() : null;
/// }
/// ```‹ç‹ñ‹ò   €®  dart:ui  €Ì  package:flutter/animation.dart  €ı  package:flutter/material.dart  -  package:flutter/widgets.dart  \  &package:flutter_test/flutter_test.dart œÃ <€†€¤€¥€¿€Ã€ô$SŒ•–«ÅÆğ‚‚‚1‚F‚c‚‚‚§‚Ç‚È‚ñ‚úƒƒƒ5ƒOƒbƒtƒƒ¸„„g„®……:………†……¼…â††p†»‡‡8‡¨‡İˆ*ˆ´‰l‰‰¥‰õŠŠŠ0ŠFŠHŠIŠ™Šå‹9‹c‹g‹s‹ƒ‹»‹Á‹É‹õ‹ö‹ş‹ÿŒDŒHŒ–Œ°Œ´ŒÂŒÆŒñBOr½Üİ!89Eh”¨®îòóÿHIUk¼ÂLP í‘4‘8‘†‘Õ’$’u’ƒ’‡’Ó“"“n“–“š“ê””#”o”«”¯”¿”Ã••Q•U•¢•ñ–:–Š–Ú–í–ñ—>—‰——›—Ÿ—ğ—ı˜˜W˜¨˜¹˜¿™™!™o™p™œ™¢™ğšš4š5š•š–šØšŞ›/›F›}›~›¿›Åœœ,œdœeœ¶œ¼X‘Åó	
37„¬¾ŸŸ@ŸFŸzŸĞ   * + 7 M ’ ½ ò ø¡(¡,¡.¡/¡{¡¡Í¡ç¡ë¢-¢1¢‚¢Ä££a£v£z£†£±£Ò£Ø£à£ä¤.¤{¤†¤˜¤æ¥8¥s¥t¥¸¥Î¥Ï¥Û¥ş¦*¦>¦D¦¦‘¦’¦¦Í¦Î¦Ú¦ğ§2§˜§õ¨¨G¨l¨µ¨»¨ğ¨ô¨ö¨÷©)©-©|©Èªªª`ª«ªå«3«S«W«¨«ø¬C¬‘¬¥¬©¬÷­B­‘­á®/®€®Š®®œ® ®ì¯¯b¯ˆ¯Õ°°°F°n°Š°‹°Î°Ô±±l±¾²²a²m²s²Ã³³b³­³ş´´%´v´´“´£´©´Ü´î´ïµ)µ/µ‚µÔ¶!¶q¶‡¶”¶Ÿ¶º¶»¶î¶ú··P·~·‚·ƒ··Ô·ÿ¸H¸L¸M¸Y¸g¸›¸œ¸¨¸¶¸Ü¸İ¹-¹]¹c¹´ººHºNºŸºíºş»<»™»»»è¼=¼‘¼ê½½B½N½r½~½‹½½‘½’½Ä½È¾¾g¾±¾ù¿J¿N¿‘¿•¿áÀ @)À @yÀ @ÄÀ AÀ A7À A;À A]À AaÀ A°À AüÀ BLÀ B|À B€À BÑÀ C"À ClÀ C‡À C‹À CÒÀ CõÀ CùÀ DJÀ DšÀ DéÀ E:À E‰À EÕÀ FÀ FÀ FaÀ FŸÀ F£À FóÀ GCÀ G”À G«À G¯À GúÀ HDÀ H”À HåÀ I3À I„À IÓÀ IéÀ J4À JÀ JĞÀ K!À KnÀ KºÀ LÀ LHÀ L[À L_À L°À LçÀ LëÀ M.À M2À MFÀ MJÀ MÀ M¡À MòÀ NÀ NÀ NÀ NKÀ NqÀ NuÀ N…À N°À NêÀ NòÀ NøÀ O À OÀ OÀ O(À O,À OzÀ O“À O—À O£À OÌÀ OßÀ OòÀ P À P4À P>À PBÀ P[À PvÀ PzÀ PŠÀ PµÀ PìÀ PôÀ PúÀ QÀ QÀ QÀ Q_À Q®À QÑÀ QÕÀ QãÀ QçÀ R3À R]À R©À RÏÀ RÿÀ S'À SMÀ SNÀ SŸÀ S¥À SâÀ SîÀ T,À T-À TxÀ T~À TÏÀ UÀ UjÀ U½À UåÀ UëÀ V6À VƒÀ VÔÀ WÀ WYÀ W_À W¯À WıÀ X"À X(À XvÀ X¿À YÀ YUÀ Y À YãÀ YéÀ Z&À Z,À ZzÀ Z†À ZÂÀ ZıÀ [À [KÀ [kÀ [qÀ [À [‡À [àÀ [íÀ \À \À \À \;À \?À \À \ÚÀ ]%À ]lÀ ]pÀ ]¿À ^À ^XÀ ^ À ^ñÀ ^õÀ _AÀ _‡À _ØÀ `&À `iÀ `€À `„À `ÇÀ `ËÀ aÀ a`À a®À aÿÀ b3À b7À btÀ b½À cÀ cVÀ c§À c÷À dÀ d!À dkÀ d¹À eÀ eNÀ ešÀ eéÀ f7À f†À fÖÀ g'À guÀ gÅÀ hÀ hÀ h7À h;À hvÀ hzÀ hËÀ iÀ ijÀ iºÀ j
À jVÀ j§À jÃÀ jÇÀ kÀ k\À k­À köÀ lGÀ lbÀ lfÀ l­À lÏÀ lÓÀ m À mgÀ m·À måÀ méÀ n:À nˆÀ nÏÀ oÀ oQÀ oUÀ o À oêÀ p<À pÀ pÜÀ q1À qYÀ q]À q©À qÉÀ qÍÀ rÀ rnÀ r½À s
À sVÀ s£À sîÀ t<À taÀ teÀ t°À tüÀ u@À uÀ u½À uÁÀ v	À vÀ v^À v•À v™À vÜÀ vàÀ w"À wKÀ wOÀ wcÀ wgÀ w±À wµÀ wıÀ xHÀ x”À x˜À x¤À xÒÀ xùÀ xıÀ yÀ yJÀ yPÀ yTÀ y‹À y›À yÆÀ z À zÀ zÀ zÀ z&À z:À z>À z‰À zÕÀ zõÀ zùÀ {À {-À {@À {SÀ {À {•À {ŸÀ {£À {¼À {×À {ÛÀ {ëÀ |À |"À |&À |QÀ |kÀ |oÀ |ƒÀ |«À |³À |·À |ÇÀ |òÀ }À }+À }lÀ }‹À }–À }À }¤À }¬À }¼À }ÀÀ ~	À ~XÀ ~{À ~À ~À ~‘À ~ÖÀ #À VÀ ¢À ÈÀ ÷À €À €DÀ €EÀ €•À €›À €ØÀ €äÀ  À !À rÀ xÀ ¿À ôÀ úÀ ‚À ‚À ‚UÀ ‚_À ‚eÀ ‚²À ƒÀ ƒRÀ ƒ¡À ƒñÀ „<À „SÀ „`À „kÀ „‚À „„À „…À „ËÀ „âÀ …1À …=À …HÀ …IÀ …–À …êÀ …ùÀ …úÀ †JÀ †XÀ †aÀ †bÀ †­À †ÌÀ †×À †ÙÀ †ÚÀ ‡À ‡AÀ ‡BÀ ‡{À ‡À ‡ÎÀ ˆÀ ˆeÀ ˆ¬À ˆ°À ˆğÀ ‰=À ‰‹À ‰ÚÀ Š$À ŠkÀ Š»À ‹À ‹UÀ ‹YÀ ‹‹À ‹À ‹ÈÀ ‹íÀ Œ:À Œ‰À Œ×À $À AÀ À ÙÀ 'À pÀ À ĞÀ À oÀ ½À À ^À £À òÀ ‘9À ‘…À ‘ÎÀ ‘ŞÀ ’+À ’tÀ ’ÁÀ “À “cÀ “³À ” À ”MÀ ”šÀ ”ÃÀ •À •ZÀ • À •êÀ –7À –†À –×À —$À —qÀ —ªÀ —÷À ˜CÀ ˜À ˜İÀ ™.À ™wÀ ™ÁÀ ™ĞÀ š!À šqÀ š¿À ›
À ›.À ›{À ›ÈÀ œÀ œ]À œaÀ œoÀ œsÀ œÄÀ  À MÀ €À ÌÀ òÀ *À <À À ¢À ¨À õÀ ŸBÀ ŸÀ Ÿ×À  (À  wÀ  ŠÀ  ¦À  ´À  µÀ  õÀ  ûÀ ¡HÀ ¡—À ¡ÙÀ ¡ÚÀ ¢%À ¢QÀ ¢‹À ¢ŒÀ ¢ÅÀ ¢ËÀ £À £_À £®À £ÿÀ ¤À ¤À ¤eÀ ¤À ¤¬À ¤¼À ¤ÚÀ ¤öÀ ¥nÀ ¥øÀ ¦À ¦À ¦À ¦(À ¦>À ¦BÀ ¦CÀ ¦`À ¦aÀ ¦›À ¦¡À ¦ëÀ §0À §}À §ÎÀ §íÀ §óÀ ¨5À ¨]À ¨^À ¨—À ¨À ¨ìÀ ¨şÀ ©À ©MÀ ©À ©åÀ ©ëÀ ªÀ ªfÀ ª®À ªûÀ «?À «gÀ «mÀ «ŸÀ «ëÀ ¬0À ¬OÀ ¬ƒÀ ¬‰À ¬À ¬¤À ¬ùÀ ­CÀ ­šÀ ­¯À ­µÀ ®À ®-À ®:À ®KÀ ®`À ®À ®ŞÀ ®âÀ ®ãÀ ¯À ¯!À ¯qÀ ¯¶À °À °LÀ °{À °À °ÑÀ °íÀ °óÀ ±CÀ ±‹À ±‘À ±ÀÀ ±ÆÀ ²À ²MÀ ²SÀ ²¤À ²½À ²ÎÀ ²ÛÀ ³À ³À ³?À ³EÀ ³À ³ØÀ ´'À ´-À ´=À ´CÀ ´aÀ ´À ´ÂÀ ´ÏÀ ´àÀ ´÷À ´øÀ µGÀ µMÀ µ˜À µĞÀ µÖÀ µäÀ ¶À ¶À ¶!À ¶nÀ ¶½À ¶òÀ ¶øÀ ·HÀ ·—À ·èÀ ·öÀ ·üÀ ¸HÀ ¸•À ¸ÒÀ ¸ØÀ ¹%À ¹sÀ ¹ÃÀ ºÀ ºEÀ ºKÀ ºYÀ ºˆÀ ºÀ º´À ºÀÀ »&À »UÀ »œÀ »¤À »®À »´À ¼ À ¼QÀ ¼œÀ ¼ºÀ ¼ÀÀ ½À ½IÀ ½OÀ ½]À ½tÀ ½«À ½³À ½¿À ½åÀ ½ïÀ ½õÀ ¾CÀ ¾À ¾ŞÀ ¿,À ¿|À ¿’À ¿˜À ¿³À ¿¹À À
À ÀAÀ ÀoÀ ÀuÀ ÀÅÀ ÁÀ ÁfÀ Á¡À Á§À ÁèÀ ÁîÀ Â;À ÂŠÀ ÂÛÀ Ã-À Ã`À ÃfÀ ÃµÀ ÄÀ ÄÀ Ä/À Ä5À Ä…À ÄÔÀ Å%À ÅuÀ ÅÅÀ ÅçÀ ÅíÀ Æ=À ÆÀ ÆÜÀ ÇÀ ÇÀ ÇjÀ Ç»À ÇÏÀ ÇÕÀ ÇåÀ ÇëÀ È7À ÈsÀ È€À È£À È³À ÈğÀ É(À ÉlÀ ÉˆÀ ÉåÀ Ê>À Ê•À ÊÖÀ ÊãÀ ÊøÀ Ë!À ËxÀ ËÍÀ Ì"À Ì7À ÌDÀ ÌYÀ Ì®À ÍÀ ÍQÀ Í¡À Í®À ÍºÀ ÍÂÀ ÎÀ ÎCÀ Î†À Î›À ÎôÀ ÏNÀ Ï«À ÏØÀ ÏåÀ ÏñÀ ÏùÀ ĞÀ ĞÀ ĞBÀ ĞRÀ ĞpÀ Ğ¨À ĞóÀ ÑÀ ÑfÀ Ñ§À Ñ´À ÑÉÀ Ò#À ÒÀ Ò¼À ÒÉÀ ÒÕÀ ÒİÀ Ó-À ÓOÀ ÓbÀ ÓlÀ ÓŒÀ ÓÀ Ó‘À ÓÉÀ ÓÏÀ ÔÀ ÔiÀ ÔºÀ Õ
À ÕTÀ Õ¤À ÕóÀ ÖBÀ Ö’À ÖàÀ ×0À ×^À ×dÀ ×¯À ×şÀ Ø?À ØEÀ Ø’À Ø¼À ØÂÀ ØÒÀ ØØÀ Ù(À ÙLÀ ÙYÀ ÙjÀ ÙÀ Ù‚À ÙÎÀ ÙîÀ ÙôÀ ÚBÀ ÚÀ ÚÄÀ ÚÊÀ ÛÀ ÛfÀ Û³À Ü À ÜPÀ ÜÀ ÜåÀ İ1À İÀ İÉÀ ŞÀ Ş À ŞnÀ Ş»À ŞÑÀ Ş×À ß&À ßNÀ ßTÀ ßdÀ ßjÀ ß°À ßúÀ àÀ àÀ à-À à.À àrÀ àxÀ àÂÀ áÀ á_À á°À áúÀ â À âOÀ âˆÀ âÀ â½À âÃÀ ãÀ ã7À ã=À ãNÀ ãTÀ ã¢À ãêÀ ä À äÀ ä%À ä+À äwÀ äÄÀ åÀ åRÀ åXÀ å£À åŞÀ åäÀ æ0À æpÀ ævÀ æÄÀ æóÀ æùÀ ç)À ç/À ç}À ç½À çÃÀ çÓÀ çÙÀ èÀ è!À è2À èEÀ è€À èÀ èÆÀ èÙÀ èãÀ éÀ éÀ éÀ éaÀ égÀ é¶À éÅÀ éËÀ éïÀ êÀ êHÀ êÀ êÕÀ ë&À ëMÀ ëSÀ ë¢À ëÓÀ ëÙÀ ì$À ìqÀ ìÂÀ íÀ íGÀ íMÀ íÀ íìÀ î7À î=À î‹À îÔÀ ï#À ïqÀ ï½À ğÀ ğKÀ ğQÀ ğlÀ ğrÀ ğ¼À ğÂÀ ñÀ ñ^À ñ«À ñÃÀ ñÉÀ òÀ òeÀ òµÀ óÀ óQÀ ó‹À ó‘À óâÀ ô,À ô|À ô‚À ôÒÀ õ À õbÀ õ±À öÀ öÀ ö!À ö/À öYÀ öˆÀ ö¼À öÂÀ öİÀ öãÀ öõÀ ÷/À ÷OÀ ÷„À ÷‘À ÷›À ÷£À ÷­À ÷³À øÀ øOÀ øŸÀ øìÀ ù9À ù†À ù™À ùŸÀ ùìÀ ú<À úWÀ ú]À úkÀ ú™À úØÀ úŞÀ úùÀ ûÀ ûÀ ûÀ ûJÀ ûYÀ ûkÀ û˜À û¸À ûöÀ üÀ üÀ üÀ üÀ ü%À üvÀ üÆÀ ıÀ ı`À ıÀ ı‡À ı—À ıÀ ıõÀ şÀ ş(À ş)À şhÀ şnÀ ş¯À şùÀ ÿ.À ÿ4À ÿ‚À ÿÑÀ ÿ×À !À mÀ ºÀÀ+À8ÀIÀkÀlÀxÀ½ÀèÀøÀÀ5ÀRÀrÀ¡À¬ÀµÀÈÀÒÀ&À:À’À™ÀÀÀñÀEÀGÀHÀ—À£À§ÀóÀÀÀÀ!ÀmÀ“ÀÌÀÀBÀÀ¸ÀÀ8ÀpÀœÀÖÀÀÀ>ÀDÀxÀÊÀ	À	fÀ	{À	‘À	“À	”À	áÀ	üÀ
 À
<À
ŠÀ
ÊÀ
ÎÀÀPÀTÀhÀlÀ»À ÀÀÀQÀhÀ{À—ÀµÀ¿ÀÃÀÚÀŞÀîÀ&À‚À©ÀËÀÀIÀSÀ[À_ÀoÀªÀ°À¸ÀÈÀÌÀÚÀŞÀÀbÀ©ÀìÀÀgÀ³ÀİÀ)ÀzÀÂÀÿÀ ÀÀRÀSÀ™À¯ÀµÀûÀKÀwÀ}ÀÉÀ÷À4ÀNÀkÀ”À˜À™ÀçÀ À&ÀtÀ ÀÏÀÕÀîÀôÀCÀnÀºÀüÀÀÀ"À_ÀiÀoÀ¿ÀÀ]À‰ÀŠÀØÀÀÀeÀŠÀÀáÀ%ÀÀ€ÀÄÀéÀÀ9À@ÀZÀwÀxÀ—ÀôÀÀ0ÀÀšÀ´À*À5ÀFÀ­À#À,ÀQÀdÀÒÀİÀÿÀÀ’ÀÀ¤À¨À©ÀûÀ À FÀ „À ÔÀ!#À!HÀ!NÀ!À!èÀ"9À"ŠÀ"ÙÀ"ßÀ#+À#dÀ#±À#ÏÀ#ÜÀ$À$À$]À$uÀ${À$ÇÀ%À%À%(À%.À%~À%À%šÀ%ÄÀ%ÆÀ%ÇÀ&À&À&_À&cÀ&´À' À'À'SÀ'À'“À'ÖÀ'ÚÀ'îÀ'òÀ(=À(AÀ(MÀ({À(“À(¦À(ÃÀ(áÀ(ëÀ(ïÀ)À)À)DÀ)ŒÀ)”À)˜À)ÊÀ)şÀ*?À*WÀ*_À*cÀ*sÀ*ÃÀ*ÉÀ*ÑÀ*áÀ*åÀ+À+À+lÀ+À+İÀ,&À,*À,{À,ÊÀ-À-]À-aÀ-°À. À./À.3À.À.ÒÀ/"À/lÀ/±À/üÀ0À0À0HÀ0LÀ0À0ìÀ0ıÀ1À1À1À1iÀ1ŸÀ1£À1¯À1ÚÀ2À2&À2*À2:À2eÀ2~À2™À2ºÀ2ÖÀ3À3(À3HÀ3•À3¨À3¹À3ÈÀ3ÕÀ3àÀ3èÀ3îÀ3öÀ4À4
À4À4"À4lÀ4¼À4ïÀ4óÀ4ÿÀ5*À5.À5^À5„À5ˆÀ5˜À5ÃÀ5ÜÀ5÷À6À61À6MÀ6‘À6 À6­À6¸À6ÀÀ6ÆÀ6ÎÀ7À7!À7/À73À7~À7§À7óÀ8%À8\À8 À8îÀ9À9SÀ9|À9±À:À:JÀ:†À:‡À:“À:ÑÀ:ÒÀ;#À;)À;zÀ;ËÀ<À<cÀ<vÀ<|À<ÌÀ=À=hÀ=vÀ=ƒÀ=ÃÀ=ÅÀ=ÆÀ>À>`À>qÀ>uÀ>ÀÀ>äÀ>èÀ?(À?uÀ?ÄÀ@À@8À@<À@‰À@¼ÀAÀAUÀA~ÀAÀAÍÀAÙÀAäÀBÀBÀBLÀBÀB¹ÀB¿ÀCÀCRÀCœÀCÌÀCúÀDÀDÀDKÀDLÀD™ÀDèÀEÀEÀEaÀE«ÀEöÀF&ÀFUÀFbÀFºÀF»ÀFÿÀGBÀG“ÀGÄÀGÑÀHÀHÀHÀHnÀH‰ÀHÀHÚÀIÀInÀI¶ÀIãÀIäÀIğÀJ<ÀJ>ÀJ?ÀJ“ÀJ¶ÀJºÀJûÀKIÀKšÀKÑÀKÕÀL"ÀLlÀL½ÀMÀMEÀMFÀMvÀM|ÀM­ÀMÄÀMÅÀMÑÀN+ÀN-ÀN.ÀN‚ÀNÎÀOÀO$ÀO(ÀO_ÀO¯ÀOøÀPCÀP‡ÀP®ÀP²ÀPÿÀQÀQÀQÀQPÀQÀQ¬ÀQíÀR>ÀRbÀR«ÀRÔÀS)ÀS*ÀS[ÀSaÀS±ÀSöÀTDÀTSÀTYÀT£ÀTôÀUEÀUŒÀU’ÀU ÀUÁÀUùÀV,ÀV2ÀVOÀVgÀV—ÀV¥ÀV¯ÀVµÀVÇÀVôÀW7ÀWbÀWlÀWtÀW~ÀW„ÀWÃÀWÉÀW×ÀXÀXBÀXHÀXeÀX}ÀXÇÀYÀY@ÀYNÀYXÀY^ÀYpÀYÀYéÀZÀZ'ÀZ/ÀZ9ÀZXÀZYÀZeÀZ½ÀZ¿ÀZÀÀZÌÀZÍÀ[À[À[&À[>À[sÀ[tÀ[—À[ÚÀ[êÀ\À\KÀ\•À\ŸÀ\§À\ºÀ\ÄÀ\ğÀ]À]/À]7À]NÀ]À]”À]•À]¬À]ÀÀ^À^#À^-À^XÀ^hÀ^‰À^ À^¦À^ªÀ^«À^ãÀ_$À_>À_À_´À_ÄÀ_æÀ_ùÀ`À`À`À`&À`<À`fÀ`‹À`ÊÀ`ñÀ`÷ÀaÀaÀaÀa9ÀaOÀaxÀaÀa¼ÀaıÀbÀbÀb*Àb@ÀbPÀb|ÀbÀb™Àb¬Àb°Àb²Àb³ÀbøÀbüÀc)Àc-ÀctÀc‡ÀcÀÀcÁÀd	ÀdÀd=ÀdAÀddÀd¨Àd©ÀdæÀdêÀe)ÀerÀevÀeÂÀfÀf`Àf±ÀfåÀféÀg5ÀgƒÀgÎÀgÒÀh!ÀhpÀh¿ÀiÀi`Ài°ÀişÀjMÀj™ÀjãÀkÀkÀkiÀk´ÀkıÀlMÀl–ÀlšÀl¦Àl´ÀlİÀmÀm%ÀmXÀmoÀm›ÀmºÀmåÀnÀn9ÀndÀnŠÀn½ÀnàÀoÀo0ÀoWÀo‘Ào¿ÀoöÀp"ÀphÀp–ÀpÎÀpïÀqÀq*ÀqEÀq^ÀquÀqŠÀqÀq®Àq½ÀqÊÀqÔÀqİÀqãÀqëÀqïÀr?ÀrÀrÛÀrüÀs ÀsCÀsGÀs–ÀsäÀt"ÀttÀtÅÀu ÀuÀuÀu ÀuKÀujÀuŠÀuÎÀuñÀvÀv*Àv7ÀvcÀvnÀvvÀv~Àv‘Àv•ÀvãÀw1ÀwOÀwÀw²Àw³ÀwıÀx5ÀxNÀxOÀx—Àx¹Àx¿ÀyÀy\ÀypÀyvÀyÄÀyÊÀzÀzÀzÀzhÀznÀz¹ÀzíÀ{>À{`À{°À{ÊÀ{ĞÀ|!À|bÀ|À|”À|ÌÀ|èÀ|éÀ}-À}{À}ÈÀ}äÀ}êÀ~5À~À~ÆÀÀBÀHÀ˜ÀèÀ€7À€~À€À€–À€âÀÀ
ÀWÀ£ÀóÀ‚À‚=À‚>À‚€À‚†À‚ÒÀƒÀƒgÀƒÀƒ–ÀƒâÀ„À„
À„[À„«À„øÀ…EÀ…KÀ…˜À…äÀ†4À†ZÀ†lÀ†mÀ†¯À†ğÀ†öÀ‡À‡À‡gÀ‡¹À‡ìÀ‡òÀˆFÀˆtÀˆÍÀˆÎÀ‰À‰VÀ‰\À‰¦À‰öÀŠCÀŠ’ÀŠÓÀŠÙÀ‹+À‹vÀ‹ˆÀ‹À‹ÖÀŒ"ÀŒoÀŒ¿ÀÀ]ÀwÀ}ÀÍÀÀmÀºÀîÀôÀBÀÀÃÀÉÀÀEÀKÀ›ÀçÀ‘8À‘ƒÀ‘¨À‘®À‘çÀ’.À’rÀ’˜À’­À“À“À“TÀ“ˆÀ“À“ŞÀ”+À”|À”¸À”¾À•À•]À•®À•ûÀ–/À–5À–ƒÀ–ĞÀ—À—
À—JÀ—‹À—ŒÀ—áÀ˜(À˜.À˜^À˜dÀ˜»À˜ûÀ™À™PÀ™†À™ŒÀ™ÜÀš+ÀšeÀš¸À›À›3À›HÀ›¢À›£À›öÀœ"Àœ(ÀœuÀœÂÀÀ]À­ÀúÀGÀ˜ÀèÀŸ4ÀŸ:ÀŸ†ÀŸÑÀ 
À À bÀ ®À üÀ¡OÀ¡UÀ¡¡À¡ÂÀ¡×À¢À¢À¢aÀ¢’À¢˜À¢ßÀ£0À£À£ÕÀ¤(À¤tÀ¤ÀÀ¤äÀ¤êÀ¥7À¥†À¥×À¦	À¦À¦[À¦¦À¦ßÀ¦åÀ§7À§ƒÀ§ÑÀ¨À¨3À¨9À¨OÀ¨UÀ¨cÀ¨»À¨ÅÀ¨×À©À©	À©[À©ŒÀ©’À©İÀª5ÀªÀª¨Àª®À«À«À«(À«]À«^À«ºÀ«ëÀ«ñÀ¬?À¬À¬áÀ­5À­„À­ÔÀ®!À®XÀ®^À®ªÀ®õÀ¯.À¯4À¯†À¯ÒÀ° À°tÀ°‰À°ÈÀ°ÉÀ±À±QÀ±WÀ±œÀ±ëÀ²:À²À²…À²ºÀ²ÀÀ³À³À³kÀ³¸À´À´QÀ´fÀ´§À´¨À´ÑÀ´×ÀµÀµdÀµ´À¶À¶2À¶8À¶†À¶ÒÀ¶àÀ¶æÀ·1À·}À·ƒÀ·ÔÀ¸À¸oÀ¸ÀÀ¸ÙÀ¸îÀ¹!À¹"À¹eÀ¹kÀ¹ºÀºÀºÀºSÀºTÀº¬Àº²À» À»À»À»À»sÀ»–À»©À»îÀ»ôÀ»õÀ¼LÀ¼RÀ¼ŸÀ¼ÁÀ¼ÔÀ½À½À½ À½oÀ½”À½šÀ½éÀ¾@À¾AÀ¾‹À¾¦À¾¬À¾øÀ¿/À¿1À¿2À¿€À¿„À¿ÓÀÀ ÀÀKÀÀOÀÀÀÀñÀÁCÀÁ“ÀÁÁÀÁÚÀÂ$ÀÂJÀÂKÀÂuÀÂ•ÀÂäÀÂşÀÂÿÀÃLÀÃ‡ÀÃÀÃÛÀÄ+ÀÄ~ÀÄĞÀÄ÷ÀÅÀÅÀÅjÀÅšÀÅ ÀÅïÀÅõÀÆBÀÆdÀÆŠÀÆ¾ÀÆ¿ÀÆŞÀÆüÀÇÀÇHÀÇyÀÇšÀÇ½ÀÇàÀÇæÀÈÀÈ.ÀÈMÀÈSÀÈƒÀÈ®ÀÈ´ÀÈ¸ÀÈ¹ÀÈØÀÈöÀÉÀÉCÀÉiÀÉ‹ÀÉ¼ÀÊÀÊ9ÀÊlÀÊ~ÀÊ¾ÀËÀË%ÀË:ÀËFÀË«ÀË±ÀË»ÀËÔÀËíÀÌÀÌBÀÌMÀÌ\ÀÌ“ÀÌİÀÍ-ÀÍ8ÀÍAÀÍGÀÍdÀÍˆÀÍÀÍ’ÀÍ“ÀÍàÀÎCÀÎXÀÎkÀÎqÀÎ¥ÀÎòÀÏ
ÀÏgÀÏ¹ÀÏÂÀÏÓÀĞ2ÀĞ‘ÀĞîÀÑ:ÀÑCÀÑgÀÑ’ÀÑªÀÑİÀÑæÀÒ
ÀÒyÀÒŠÀÒ½ÀÒÆÀÒÎÀÒÒÀÒÓÀÓ ÀÓ@ÀÓŸÀÓÇÀÓñÀÓûÀÔ^ÀÔ•ÀÔÈÀÕÀÕ/ÀÕ9ÀÕAÀÕSÀÕšÀÕ¹ÀÖÀÖ!ÀÖJÀÖ„ÀÖÈÀÖßÀ×CÀ×RÀ×|À×½À×ÛÀØÀØ#ÀØIÀØœÀØºÀØÉÀØ×ÀØáÀØöÀÙÀÙÀÙHÀÙ{ÀÙ£ÀÙ­ÀÙµÀÙÓÀÙşÀÚÀÚ#ÀÚ'ÀÚ(ÀÚGÀÚeÀÚ…ÀÚ°ÀÚÚÀÚòÀÚøÀÛÀÛ0ÀÛZÀÛ•ÀÛòÀÜEÀÜ¢ÀÜÿÀİYÀİ¯ÀİäÀİöÀİüÀŞÀŞ<ÀŞoÀŞÆÀŞÎÀŞáÀŞëÀŞıÀßÀßÀßÀß1Àß5Àß‚ÀßÓÀà ÀàFÀàJÀà–ÀàÖÀà÷ÀàûÀáGÀáKÀázÀá¿ÀáĞÀáÔÀáèÀâ6Àâ€ÀâÄÀâÈÀãÀã$Àã7ÀãeÀãkÀã·ÀäÀäMÀä›Àä·ÀäùÀåJÀåKÀå–Àå£ÀåÅÀåÆÀæ	Àæ
Àæ7Àæ8ÀæfÀælÀæºÀæñÀæ÷Àç"Àç(ÀçrÀçÁÀèÀèaÀètÀè‘Àè’ÀèŞÀéÀéCÀéfÀé•Àé¥ÀéÓÀéìÀéıÀê‡Àê’ÀêšÀê¶ÀêîÀëMÀë£Àë¿Àì"ÀìMÀìZÀìoÀìÍÀíÀílÀíyÀí…ÀíÀí ÀíªÀíàÀíğÀî6ÀîOÀî`Àî—Àï Àï]ÀïhÀïpÀï¥ÀïİÀğ.ÀğCÀğÀğÂÀğÏÀñÀñÀñÀñ2Àñ<ÀñÀñ¬ÀñÇÀñÍÀñøÀòÀò6ÀòÀò˜Àò«ÀòµÀò¹ÀòºÀòÚÀóÀóÀóKÀóQÀó|Àó¨ÀóÇÀóìÀóíÀô=Àô_ÀôeÀôµÀôÖÀõ Àõ'Àõ7ÀõXÀõkÀõuÀõÀõ‘Àõ¡Àõ³ÀõÖÀõëÀõ÷ÀõıÀö$Àö(Àö)ÀöuÀöÁÀö÷ÀöıÀ÷KÀ÷‹À÷‘À÷ŞÀø*ÀøzÀø¼ÀøæÀøìÀù:Àù‰ÀùºÀùÀÀùõÀùûÀú5Àú;Àú‚ÀúÏÀûÀû*ÀûWÀû–ÀûÌÀüÀüÀü!ÀüHÀüeÀüuÀü—Àü«ÀüáÀı,Àı7Àı?Àı`Àı}ÀıÀıšÀı³ÀıæÀıøÀş*Àş_Àş­ÀşóÀÿ&ÀÿOÀÿ\ÀÿfÀÿ{Àÿ‡ÀÿÔÀÿÚÀÿäÀ À 2À PÀ sÀ À ²À ñÀÀ6ÀDÀRÀhÀ|À’ÀËÀÀ:ÀSÀcÀmÀuÀ´ÀÄÀèÀÀ/ÀUÀ]À{ÀÀ­ÀĞÀôÀ!À+À@ÀLÀRÀyÀ}À~ÀŞÀßÀ*À<ÀOÀUÀ‚ÀÍÀıÀPÀcÀgÀhÀ—ÀéÀíÀîÀ;À<À”ÀÎÀÜÀ3À4ÀƒÀ¥ÀõÀ	À	À	oÀ	©À	·À
À
<À
JÀ
KÀ
˜À
ÓÀ
ÀÀWÀgÀ¢ÀµÀ¿ÀÃÀÄÀ ÀÀAÀ~ÀËÀüÀÀÀ!ÀHÀLÀMÀ‹À›ÀòÀ/À|À„À—À¡ÀÏÀõÀûÀÿÀ ÀQÀaÀ¨ÀâÀõÀÿÀÀÀ0À@ÀŠÀìÀ(ÀkÀ¡À³À½ÀùÀEÀ“À¦ÀÍÀáÀíÀ9À…ÀÆÀõÀBÀÀ×ÀÀ6À\À”ÀÔÀÀAÀ¥ÀÄÀãÀFÀYÀkÀ€ÀÀÀÀ-ÀÀàÀ ÀcÀvÀˆÀ–ÀãÀ1ÀÀ¥ÀÏÀ
À7ÀcÀuÀ‡À•À¿ÀúÀ'ÀSÀeÀwÀ…ÀÀ±ÀØÀäÀğÀúÀ&À9ÀCÀGÀHÀrÀ‚À²ÀÀIÀwÀ¹ÀğÀ&ÀiÀÁÀâÀ À À &À MÀ mÀ ´À!À!?À!yÀ!ÈÀ"À"gÀ"¸À"ñÀ#À#2À#wÀ#À#À#«À#µÀ#ÎÀ#êÀ$GÀ$TÀ$_À$’À$šÀ$­À$·À$»À$¼À%	À%À%$À%XÀ%^À%¯À%ÌÀ%ùÀ&À&*À&\À&bÀ&lÀ&¿À&ÑÀ&ßÀ'À'9À'À'ÜÀ(À(^À(¨À(ÅÀ)"À)5À)EÀ)SÀ)vÀ)ÄÀ*"À*YÀ*¡À*ºÀ*åÀ*÷À+À+>À+À+½À+ßÀ+÷À,À,lÀ,}À,®À-À-XÀ-™À-ÒÀ-åÀ.$À.tÀ.À.ÀÀ.ÒÀ.âÀ/À/uÀ/¨À/ÊÀ/æÀ/ıÀ0cÀ0tÀ0 À0áÀ1À1bÀ1©À2À2IÀ2À2áÀ3.À3À3ÌÀ48À4vÀ4ÆÀ5À5?À5aÀ5ÕÀ6HÀ6£À6ÕÀ7JÀ7ĞÀ8HÀ8¸À9+À9dÀ9˜À9ıÀ:À:"À:0À:<À:PÀ:£À:­À:ÂÀ:ÎÀ:çÀ;5À;€À; À;ôÀ<À<À<EÀ<MÀ<SÀ<WÀ<XÀ<¤À<óÀ=DÀ=cÀ=iÀ=µÀ=×À=ğÀ>3À>9À>CÀ>gÀ>‰À>¢À>²À>ÍÀ>óÀ>ûÀ?À?À?À?À?UÀ?iÀ?mÀ?{À?ÍÀ?÷À@@À@\À@bÀ@©À@ùÀA+ÀA,ÀA8ÀAZÀA§ÀA«ÀA­ÀA®ÀAÈÀAøÀAùÀBÀB9ÀB:ÀBsÀB¬ÀBºÀBÀÀBğÀBôÀBöÀB÷ÀC(ÀCNÀC¢ÀC¤ÀC¥ÀCîÀCòÀDBÀD“ÀDäÀE/ÀEÀE–ÀEšÀEèÀF4ÀF8ÀFcÀFgÀF¸ÀG ÀGPÀG ÀGçÀH4ÀHÀHÀHÛÀI*ÀIyÀIÊÀJÀJhÀJ¦ÀJóÀKCÀK“ÀKàÀL1ÀL^ÀL­ÀLöÀMAÀM‡ÀMØÀN%ÀNrÀNÀÀOÀO5ÀOƒÀOĞÀOàÀP*ÀP[ÀP§ÀPñÀP÷ÀQ8ÀQfÀQ©ÀQ­ÀQ®ÀQÂÀQêÀQëÀRÀRÀRcÀR®ÀRçÀRíÀS<ÀSŠÀSØÀT'ÀT-ÀTzÀTÉÀUÀU_ÀUeÀU¯ÀUñÀUÿÀVÀVWÀV“ÀV”ÀVäÀVöÀVüÀWMÀWÀWµÀWÒÀWãÀWäÀX1ÀX}ÀXÀXŸÀXÙÀY/ÀY7ÀYJÀYTÀYgÀYkÀYlÀYÀY€ÀYÑÀYçÀZÀZ:ÀZqÀZ†ÀZ™ÀZŸÀZîÀ[À[2À[QÀ[qÀ[wÀ[ªÀ[¸À[¼À[½À\À\]À\²À]	À]?À]eÀ]qÀ]—À]£À]°À]´À]µÀ]ßÀ]åÀ^/À^{À^ËÀ_À_gÀ_À_©À_ÊÀ_İÀ_ŞÀ_êÀ`À`À`@À`FÀ`ŒÀ`ÜÀ`øÀaÀa$ÀadÀawÀaÀa—Àa›ÀaœÀaÉÀaÏÀbÀbeÀb€Àb›Àb«ÀbéÀbüÀcÀcÀcÀc Àc]ÀciÀcŒÀc¢Àc£ÀcæÀd3ÀdSÀdYÀd­Àd³ÀeÀeRÀe˜ÀeèÀf9ÀfˆÀfÀfŞÀg0Àg€ÀgÏÀgëÀgñÀhAÀh„Àh•Àh›ÀhèÀi:ÀiOÀiUÀieÀikÀi¶ÀiéÀj9ÀjeÀj†Àj‡Àj¼ÀkÀk(Àk.Àk}ÀkÉÀkéÀkïÀl>ÀlÀl£Àl©ÀlúÀmKÀm–ÀmæÀn/Àn|ÀnÍÀoÀoÀo#Ào3Ào9ÀoUÀo‚Ào¶ÀoÇÀoÔÀoêÀp Àp$Àp>ÀpFÀpJÀpKÀpyÀp–ÀpÔÀpõÀpûÀqÀqÀqÀq_ÀqeÀq¶ÀrÀr4Àr:Àr‡ÀrÑÀsÀsOÀsrÀsÀs­ÀsïÀsşÀt1ÀtVÀteÀt›Àt£Àt©ÀtºÀt¾Àt¿ÀuÀuPÀuVÀu¦Àu÷Àv:Àv†Àv³Àv¹ÀwÀwOÀw\ÀwˆÀw›Àw¿Àx	ÀxÀx%Àx6Àx:Àx;ÀxGÀxŸÀxâÀyÀyAÀy_ÀyrÀyzÀy{ÀyÀy´ÀzÀzÀzMÀzVÀz]Àz^Àz~Àz×ÀzäÀzûÀ{À{TÀ{šÀ{¥À{®À{´À{ÌÀ{ĞÀ{ÑÀ|(À|}À|šÀ|¬À|ÅÀ}%À}:À}UÀ}\À}`À}aÀ}mÀ}À}£À}èÀ}ïÀ~2À~6À~7À~CÀ~eÀ~xÀ~½À~ÄÀÀÀÀÀPÀ›ÀæÀùÀ€4À€8À€9À€‚À€˜À€ÙÀ€ÚÀ)ÀHÀNÀŸÀÈÀÎÀ‚À‚kÀ‚¼ÀƒÀƒ4Àƒ5ÀƒqÀƒwÀƒÆÀƒÖÀƒÜÀ„*À„wÀ„ÄÀ„ùÀ„ÿÀ…OÀ…mÀ…sÀ…ƒÀ…‰À…½À…÷À†FÀ†–À†¥À†ùÀ†úÀ‡3À‡?À‡sÀ‡ƒÀ‡»À‡ĞÀ‡ØÀˆÀˆQÀˆkÀˆ¼À‰À‰`À‰ŒÀ‰—À‰¡À‰«À‰ÇÀ‰ËÀ‰ÌÀŠÀŠÀŠ`ÀŠ¯ÀŠµÀ‹À‹À‹]À‹°À‹¶ÀŒÀŒ?ÀŒEÀŒ–ÀŒçÀ8ÀƒÀ¬À²ÀÀÀÀjÀ¸ÀôÀúÀ*À0ÀÀÒÀ#À©À¯À‘ À‘MÀ‘‘À‘ÛÀ’)À’nÀ’tÀ’ÅÀ’ÒÀ’ñÀ“À“/À“|À“™À“´À“ÔÀ“ÜÀ“ïÀ“õÀ“öÀ”À”+À”PÀ”¡À”ñÀ•DÀ•œÀ•éÀ•òÀ–EÀ–¢À–öÀ—À—À—dÀ—°À˜À˜JÀ˜\À˜¦À˜òÀ™1À™FÀ™RÀ™À™×Àš"ÀšTÀšyÀš§Àš±ÀšËÀ›À›CÀ›qÀ›{À›ÚÀ›ûÀœ2ÀœHÀœŒÀœèÀœöÀÀÀƒÀÀ®ÀÏÀ÷ÀÀ,À@ÀwÀÀœÀ¶ÀÅÀåÀŸÀŸVÀŸ¦ÀŸÙÀ À À $À lÀ ºÀ ëÀ¡À¡%À¡&À¡6À¡QÀ¡‚À¡ŠÀ¡°À¡ÎÀ¡íÀ¢,À¢4À¢GÀ¢QÀ¢RÀ¢gÀ¢kÀ¢lÀ¢«À¢±À¢úÀ£KÀ£vÀ£|À£ËÀ¤À¤hÀ¤³À¤şÀ¥OÀ¥„À¥ŠÀ¥ÛÀ¦,À¦}À¦ËÀ§À§lÀ§»À§ÿÀ¨PÀ¨À¨…À¨¾À©À©YÀ©¥À©ìÀª:ÀªjÀªpÀª¼À«À«SÀ«¢À«äÀ¬-À¬€À¬ËÀ­À­YÀ­¥À­óÀ®DÀ®\À®iÀ®‰À®¨À®ÇÀ®ìÀ¯À¯À¯MÀ¯NÀ¯‡À¯ÒÀ¯ØÀ¯ÙÀ°À°5À°VÀ°—À°À°À°àÀ±/À±|À±ÀÀ±ÁÀ±ğÀ²À²2À²wÀ²œÀ²ßÀ³&À³'À³yÀ³ÈÀ³âÀ´0À´|À´ÉÀ´êÀµ.ÀµVÀµšÀµÍÀ¶À¶4À¶€À¶ÀÀ·À·À·À·6À·RÀ·…À·¹À·ºÀ·öÀ¸À¸,À¸3À¸4À¸PÀ¸QÀ¸tÀ¸ÑÀ¹*À¹eÀ¹½ÀºÀºÀº#ÀºOÀºaÀºtÀº¤Àº®ÀºòÀ» À»@À»[À»vÀ»|À»}À»¡À»şÀ¼ZÀ¼˜À¼ğÀ½?À½NÀ½VÀ½tÀ½’À½˜À½™À½ÑÀ¾À¾@À¾[À¾†À¾ºÀ¿À¿oÀ¿À¿¼À¿ûÀÀÀÀ5ÀÀAÀÀKÀÀhÀÀpÀÀvÀÀwÀÀÀÀÏÀÀèÀÁ#ÀÁ@ÀÁhÀÁƒÀÁ°ÀÁÒÀÂÀÂ5ÀÂ‚ÀÂ®ÀÂÃÀÃ	ÀÃ(ÀÃ6ÀÃBÀÃLÀÃTÀÃ¤ÀÃĞÀÃâÀÃõÀÄ%ÀÄ/ÀÄsÀÄÀÄ¡ÀÄÁÀÅÀÅÀÅ:ÀÅZÀÅuÀÅ{ÀÅ|ÀÅ¡ÀÅÖÀÆÀÆbÀÆ‘ÀÆÁÀÆÂÀÆèÀÇEÀÇÀÇ½ÀÈÀÈ<ÀÈxÀÈ¤ÀÈ¶ÀÈÉÀÈùÀÉÀÉGÀÉ£ÀÉÑÀÉñÀÊÀÊ'ÀÊ-ÀÊ.ÀÊsÀÊ®ÀÊîÀË@ÀËeÀËoÀËwÀË}ÀËËÀËãÀËçÀËèÀÌ2ÀÌ8ÀÌ‰ÀÌÕÀÍ#ÀÍXÀÍ^ÀÍ®ÀÍÒÀÍØÀÎ'ÀÎwÀÎ®ÀÎãÀÎéÀÏ8ÀÏlÀÏ}ÀÏ®ÀÏºÀÏîÀĞ@ÀĞGÀĞSÀĞjÀĞ¿ÀĞÆÀĞÒÀÑÀÑÀÑ†ÀÑÜÀÑòÀÒÀÒ7ÀÒ_ÀÒyÀÒÅÀÓÀÓ@ÀÓ]ÀÓŠÀÓÀÓ«ÀÓÌÀÓèÀÔÀÔÀÔ4ÀÔRÀÔVÀÔWÀÔÀÔ«ÀÔèÀÔìÀÔíÀÕ%ÀÕ+ÀÕsÀÕÂÀÕúÀÖ ÀÖHÀÖYÀÖ…ÀÖ¾ÀÖøÀ×À×9À×ZÀ×‰À×À×áÀØ2ÀØƒÀØÎÀØ÷ÀÙÀÙ^ÀÙ“ÀÙ¦ÀÙ°ÀÙÉÀÙÍÀÙÎÀÚÀÚÀÚhÀÚ¹ÀÚèÀÚõÀÛ1ÀÛjÀÛÀÛ¯ÀÛÒÀÜÀÜ8ÀÜSÀÜ[ÀÜaÀÜbÀÜtÀÜxÀÜyÀÜÊÀÜşÀİÀİÀİAÀİzÀİ—ÀİÙÀİîÀİòÀİóÀŞÀŞIÀŞkÀŞ‰ÀŞ¯ÀŞÚÀŞäÀŞêÀŞîÀŞïÀßÀßMÀß[ÀßaÀß³ÀßàÀßúÀà'ÀàKÀàwÀàÀàƒÀà„Àà¶Àà¼ÀàôÀá.Àá~Àá²Àá¸ÀáãÀâÀâ%ÀâGÀâOÀâaÀâeÀâfÀâºÀâÀÀâøÀã2Àã‚Àã²Àã¸ÀäÀä5ÀäOÀäsÀäœÀä¤Àä¹Àä½Àä¾ÀåÀåXÀå¬ÀåúÀæKÀæ˜ÀæîÀç Àç;ÀçNÀçTÀçŒÀçŸÀç¥ÀçµÀççÀçûÀèiÀètÀè|ÀèÀè™ÀèÆÀèàÀèòÀéÀéJÀé«ÀéûÀêNÀê¯ÀêØÀë(Àë>ÀëwÀë†Àë¤ÀìÀìÀì Àì*Àì„Àì–Àì¥Àì°ÀìÅÀìÑÀìôÀíÀí!ÀíFÀítÀíˆÀíŒÀíÀíØÀíùÀíÿÀîHÀî“Àî£Àî©Àî÷ÀïFÀï—ÀïèÀïîÀğ>ÀğDÀğ“ÀğÂÀğÏÀğîÀñÀñ,ÀñiÀñÄÀñáÀòÀò&ÀòfÀò¾ÀòÈÀòİÀòéÀóIÀóOÀóPÀóZÀó€ÀóÀóèÀôÀô4ÀôJÀôvÀôÀôŸÀô¯ÀôèÀõ ÀõdÀõvÀõŸÀõ¹ÀõüÀö
ÀöÀö+Àö~ÀöªÀöÊÀöÔÀöÜÀ÷À÷(À÷PÀ÷eÀ÷qÀ÷–À÷ÚÀ÷ÛÀ÷òÀøÀø!ÀøGÀøOÀøUÀøYÀøZÀøŠÀø°ÀøÀÀøÛÀù ÀùÀù&ÀùrÀù…ÀùÀù“Àù”ÀùáÀúÀúÀúaÀú²Àú×ÀúİÀûÀû#ÀûpÀû¾ÀüÀü^Àü¥Àü²ÀüÚÀüıÀıÀı7ÀıŒÀıœÀıÎÀıûÀş>ÀşHÀşPÀşcÀşmÀşqÀşrÀşÂÀÿÀÿÀÿjÀÿ¤Àÿ²À À À gÀ £À ©À öÀÀÀiÀ¹ÀÀÀÀmÀÀ›À¬ÀĞÀÀfÀ´ÀÿÀNÀ|ÀŒÀ·ÀñÀùÀÀÀÀÀYÀ”ÀªÀÅÀÕÀÀJÀRÀeÀoÀ‘ÀµÀÕÀöÀ/À3À4ÀjÀ­ÀÅÀÀ7À;À<À‚ÀˆÀØÀ	)À	rÀ	ÂÀ	ÈÀ
À
À
mÀ
•À
¦À
ºÀ
õÀÀ1À~À®ÀÀBÀ^À‡À¡À¿ÀÑÀöÀüÀÀ6À<À@ÀAÀ‡ÀÀİÀ.À|ÀÇÀÀ3À9ÀqÀwÀÇÀÍÀÀDÀUÀkÀ¤ÀÀ3ÀuÀŸÀ§ÀøÀFÀ–ÀæÀ3ÀOÀUÀtÀ¦ÀªÀ«ÀÀÀ:ÀKÀgÀ¢À¦À§ÀîÀôÀCÀ‘ÀâÀ*À0ÀÀ•À›ÀèÀ6ÀjÀpÀÀÀÆÀÀ:ÀKÀ^À™ÀúÀÀCÀ‹À®ÀÊÀøÀşÀHÀ|ÀÀªÀÛÀßÀàÀ0ÀÀ¼ÀÂÀÀdÀjÀ¸ÀÀSÀ¤ÀòÀ=ÀŒÀØÀèÀîÀ;À‹ÀÕÀ &À gÀ mÀ ¹À ÙÀ!À!À!$À!IÀ!YÀ!’À!ÊÀ"À".À"~À"ºÀ#À#RÀ#xÀ#…À#æÀ#òÀ#úÀ$À$À$0À$4À$5À$AÀ$TÀ$dÀ$À$íÀ%À%TÀ%”À%°À&À&=À&„À&‘À&äÀ&ğÀ&øÀ'À'SÀ'ŒÀ'¨À'úÀ(JÀ(›À(èÀ),À)9À)RÀ)gÀ)·À*	À*]À*¯À*ĞÀ*İÀ*öÀ+IÀ+UÀ+]À+pÀ+zÀ+µÀ+ÅÀ+çÀ,À,cÀ,xÀ,ËÀ- À-tÀ-ÇÀ-ıÀ.
À.]À.iÀ.qÀ.›À.ÓÀ/À/(À/kÀ/»À0À0NÀ0šÀ0»À0ÈÀ1À1hÀ1tÀ1|À1¤À1ÜÀ25À2JÀ2ŸÀ2òÀ3CÀ3tÀ3À3ÔÀ4!À4-À45À4_À4yÀ4±À5À5(À5zÀ5ÍÀ6À6nÀ6¸À6ÅÀ7À7xÀ7„À7ŒÀ7®À7æÀ7şÀ8YÀ8fÀ8{À8ÕÀ92À9ŒÀ9ãÀ:	À:À:iÀ:ÉÀ:ŞÀ;8À;€À;À;™À;¡À;´À;¾À;ãÀ<À<	À<À<À<À<`À<ˆÀ<´À<µÀ<êÀ<úÀ=3À=kÀ=¼À=ØÀ>)À>@À>MÀ>bÀ>±À?À?PÀ?]À?iÀ?qÀ?„À?À?ŸÀ?£À?¤À?şÀ@À@LÀ@ƒÀ@‡À@ˆÀ@”À@îÀA!ÀACÀArÀA¡ÀA¥ÀA¦ÀA²ÀB	ÀBBÀBÀBÀBãÀBéÀCÀC"ÀC&ÀC'ÀC3ÀCuÀC¼ÀCÀÀCÁÀCÍÀD(ÀDaÀD„ÀDˆÀD‰ÀDÜÀDùÀDÿÀEVÀEªÀE¼ÀEÂÀEÒÀF%ÀF2ÀFTÀFˆÀFŒÀFÀF«ÀFäÀGÀGÀGÀG+ÀGdÀGÀG¾ÀHÀH$ÀH*ÀHMÀHQÀHRÀH^ÀH ÀHÙÀHúÀIÀIYÀIhÀIpÀI“ÀI™ÀIåÀJÀJÀJÀJ ÀJfÀJŸÀJÀÀJçÀKÀKFÀKkÀKsÀK–ÀKœÀKÆÀKÊÀKËÀK×ÀLÀLPÀLqÀLÀLÛÀMÀMÀM1ÀM7ÀMHÀMLÀMMÀMYÀM›ÀMÔÀMõÀN)ÀNLÀNRÀNVÀNWÀNÀN•ÀNëÀO<ÀOÀOºÀP	ÀPCÀPTÀPuÀPÕÀQÀQ3ÀQ7ÀQ8ÀQvÀQ†ÀQ»ÀQóÀRÀRQÀRtÀRÀRÙÀRîÀSAÀSYÀS~ÀS ÀS¹ÀTÀTÀT&ÀT.ÀTAÀTKÀT\ÀT`ÀTaÀT¨ÀT®ÀTãÀUÀU9ÀUSÀU†ÀU­ÀUÈÀUÎÀUæÀVÀVÀV*ÀV.ÀV/ÀV~ÀV„ÀVÕÀWÀW/ÀW`ÀW}ÀW˜ÀW¯ÀWÊÀWĞÀWâÀWæÀWçÀWóÀX,ÀXgÀXkÀXlÀX ÀX¬ÀY
ÀYÀYÀYjÀY¼ÀYÀÀYÁÀYÍÀZÀZ=ÀZ†ÀZ¾À[À[À[oÀ[ƒÀ[£À[²À[ÈÀ[áÀ[ıÀ\$À\-À\4À\bÀ\¬À\ãÀ]À]TÀ]dÀ]šÀ]ØÀ]ãÀ^2À^BÀ^lÀ^ÂÀ^ÎÀ^ãÀ^ùÀ_-À_GÀ_WÀ_’À_À_¦À_¬À_°À_±À_½À_ïÀ`/À`SÀ`‚À`ŠÀ`ŸÀ`£À`¤À`íÀ`óÀa6Àa†ÀaÓÀb&ÀbnÀbŠÀb Àb¡ÀbòÀcAÀc^Àc_ÀcšÀcºÀc»Àd	Àd*Àd0ÀdvÀd½ÀeÀe#Àe=ÀewÀe®Àe¼ÀeÂÀeİÀfÀf&ÀfIÀf‚Àf¬ÀfòÀg	ÀgÀgXÀg§ÀgÃÀh/Àh‡ÀhŞÀi4Ài‰ÀiÜÀjÀjÀjxÀjƒÀjºÀjÕÀkÀksÀk‚ÀkÀk™ÀkÌÀkùÀl1ÀlÀl«ÀmÀm1Àm>ÀmÀmªÀm²ÀmÅÀmÏÀmàÀmîÀmôÀnÀn*Àn.Àn/Àn}ÀnÀn•ÀnâÀo0ÀojÀopÀo½ÀpÀpAÀpGÀpeÀpkÀpÀp‡Àp×Àq$ÀqbÀqhÀq·ÀrÀrUÀr˜ÀrÀrîÀs?ÀsÀs·Às½ÀsàÀsæÀt9ÀtaÀtgÀt¶ÀtìÀtòÀu>ÀumÀusÀuÌÀuÒÀuçÀuíÀv;Àv‡ÀvÔÀwÀw^ÀwdÀw¯ÀwûÀxÀxKÀx›ÀxêÀy:ÀyrÀyŸÀy¥ÀyïÀz=ÀzcÀziÀz¯ÀzÿÀ{NÀ{[À{aÀ{±À{ıÀ|IÀ|yÀ|À|˜À|À|îÀ}&À},À}|À}ËÀ~À~hÀ~­À~³À~şÀHÀ”ÀäÀ€/À€À€ÉÀÀ`À¯ÀûÀ‚À‚KÀ‚›À‚ëÀƒ:ÀƒˆÀƒÙÀƒßÀ„/À„sÀ„¼À„ÛÀ„ùÀ…À…@À…zÀ…ÈÀ…ÖÀ…ÜÀ…ìÀ†*À†UÀ†uÀ†À†¿À†ĞÀ†úÀ‡À‡À‡À‡)À‡bÀ‡ˆÀ‡¯À‡¿ÀˆÀˆ/ÀˆBÀˆLÀˆVÀˆnÀˆ~ÀˆÀˆ¾Àˆ÷À‰;À‰PÀ‰\À‰bÀ‰wÀ‰{À‰|À‰¥À‰«À‰òÀ‰øÀŠ4ÀŠAÀŠRÀŠlÀŠ€ÀŠ„ÀŠ†ÀŠ‡ÀŠÍÀŠğÀ‹ À‹"À‹<À‹WÀ‹]À‹^À‹uÀ‹vÀ‹‚À‹ĞÀŒÀŒ?ÀŒbÀŒ«ÀŒ±ÀŒÒÀŒãÀŒçÀŒéÀŒêÀ6ÀMÀQÀ™ÀÀ«À¯ÀöÀÀ_À®ÀÃÀÀÀAÀEÀ‘ÀâÀ.ÀiÀmÀ™ÀÀ±À‘À‘7À‘;À‘yÀ‘}À‘ÊÀ‘ÚÀ‘ŞÀ‘ìÀ‘ğÀ’;À’À’ĞÀ’ìÀ“À“YÀ“_À“¬À“ùÀ”À”À”lÀ”»À”äÀ•À•+À•oÀ•À•À•ÍÀ•ÓÀ–!À–MÀ–‘À–®À–ÍÀ–ÎÀ— À—À—OÀ—–À—·À—½À˜À˜[À˜§À˜øÀ™DÀ™JÀ™˜À™ÙÀš ÀšoÀš¶Àš¼À›	À›LÀ›RÀ›bÀ›hÀ›±Àœ ÀœMÀœ`Àœ±ÀœÏÀÀÀ\ÀuÀ…À•ÀöÀ	ÀÀCÀgÀÀºÀÁÀÅÀÆÀöÀŸ ÀŸ#ÀŸ9ÀŸ“ÀŸëÀ 9À ?À SÀ WÀ XÀ vÀ À ³À ´À ÀÀ¡À¡À¡À¡cÀ¡À¡¯À¡øÀ¢À¢dÀ¢jÀ¢nÀ¢pÀ¢qÀ¢ÂÀ¢ØÀ¢ÜÀ£À£À£*À£.À£wÀ£¼À¤	À¤HÀ¤IÀ¤šÀ¤¤À¤¨À¤ùÀ¤ıÀ¥À¥À¥YÀ¥À¥ëÀ¦<À¦=À¦À¦­À¦±À¦öÀ§:À§MÀ§QÀ§ŸÀ§ìÀ¨:À¨…À¨ÎÀ©À©À©,À©0À©zÀ©¿ÀªÀª[Àª\ÀªÀª’ÀªÖÀªÚÀ«À«SÀ«WÀ«eÀ«iÀ«²À«úÀ¬FÀ¬˜À¬™À¬ÊÀ¬ÎÀ­À­\À­`À­‰À­»À®À®'À®(À®;À®<À®]À®iÀ®™À®šÀ®¦À®ÛÀ®ÜÀ®èÀ¯À¯;À¯WÀ¯À¯£À¯¿À¯ÃÀ¯ÄÀ¯ÛÀ°+À°cÀ°gÀ°hÀ°·À±À±FÀ±LÀ±šÀ±ËÀ±×À²À²À²1À²;À²MÀ²nÀ²ƒÀ²À²¦À²¸À²ÚÀ²ïÀ²ûÀ³)À³BÀ³bÀ³…À³ŸÀ³ÍÀ³ÚÀ³ëÀ´$À´mÀ´zÀ´…À´À´À´ìÀµ7ÀµpÀµvÀµ€Àµ±ÀµÏÀµèÀ¶À¶%À¶SÀ¶`À¶qÀ¶ªÀ¶óÀ· À·À·À·CÀ·IÀ·MÀ·NÀ·À·êÀ·şÀ¸À¸À¸À¸*À¸YÀ¸sÀ¸‹À¸‘À¸•À¸–À¸¢À¸ÆÀ¸ãÀ¸öÀ¹À¹À¹À¹À¹`À¹’À¹ÜÀºÀºÀºÀºXÀºYÀºeÀºÀº­ÀºÎÀºèÀºìÀºîÀºïÀ»3À»dÀ»®À¼À¼À¼HÀ¼€À¼˜À¼øÀ½À½!À½tÀ½»À¾À¾À¾)À¾1À¾DÀ¾NÀ¾rÀ¾À¾™À¾¶À¿À¿TÀ¿nÀ¿uÀ¿‘À¿ÔÀ¿ØÀ¿ÙÀ¿åÀÀÀÀÀÀSÀÀYÀÀ¢ÀÀòÀÁÀÁGÀÁhÀÁiÀÁuÀÁ‹ÀÁ£ÀÁ»ÀÁ¿ÀÁÀÀÁÌÀÁãÀÂ&ÀÂtÀÂ„ÀÂ·ÀÂïÀÃ>ÀÃ¡ÀÃ¶ÀÄÀÄXÀÄeÀÄqÀÄyÀÄŒÀÄ–ÀÄ¦ÀÄæÀÄùÀÅÀÅ&ÀÅ6ÀÅpÀÅƒÀÅÀÅ¦ÀÅªÀÅ«ÀÅ·ÀÅÑÀÅóÀÆÀÆ>ÀÆDÀÆ`ÀÆdÀÆeÀÆqÀÆ›ÀÆ¸ÀÆÙÀÇÀÇ<ÀÇ™ÀÇ©ÀÇÜÀÈÀÈiÀÈ…ÀÈŞÀÈëÀÉ ÀÉ]ÀÉ¨ÀÉµÀÉÁÀÉÉÀÉÜÀÉæÀÊ ÀÊÀÊÀÊÀÊ%ÀÊ;ÀÊQÀÊ¢ÀÊğÀË'ÀË‡ÀËÀË¡ÀË¢ÀË®ÀËÄÀËÜÀËôÀËøÀËùÀÌÀÌÀÌ-ÀÌBÀÌRÀÌ•ÀÌªÀÌ²ÀÌèÀÍ<ÀÍVÀÍ»ÀÎÀÎÀÎÀÎ%ÀÎ@ÀÎŠÀÎ¾ÀÎÑÀÎÕÀÎÖÀÎâÀÏ3ÀÏCÀÏ~ÀÏÁÀÏùÀĞÀĞ®ÀĞ»ÀĞ×ÀÑ8ÀÑ‘ÀÑãÀÒ8ÀÒYÀÒfÀÒ{ÀÒëÀÓ]ÀÓ·ÀÓÄÀÓĞÀÓØÀÔÀÔSÀÔkÀÔìÀÔùÀÕÀÕoÀÕÂÀÖÀÖMÀÖ¨ÀÖµÀÖÊÀ× À×uÀ×µÀØÀØ#ÀØ0ÀØEÀØÀØÚÀÙ)ÀÙ|ÀÙ¶ÀÙÃÀÙÏÀÙ×ÀÙêÀÙôÀÚMÀÚQÀÚRÀÚ ÀÚğÀÛ?ÀÛxÀÛ~ÀÛÍÀÜÀÜVÀÜ‡ÀÜ®ÀÜ¯ÀÜ»ÀÜÜÀÜÿÀİ"Àİ&Àİ'Àİ3Àİ†ÀİèÀİìÀİíÀİùÀŞ>ÀŞiÀŞÎÀŞÒÀŞÔÀŞÕÀßÀßMÀßvÀß Àß¡Àß­ÀßàÀßáÀßíÀàÀàMÀànÀà‹Àà¬ÀàÄÀàŞÀàâÀàãÀáÀá"ÀárÀá½ÀáÜÀáéÀâÀâ9Àâ=Àâ>ÀâŠÀâ™ÀâŸÀâæÀã-Àã:ÀãqÀãsÀãtÀãºÀãÿÀäIÀä€ÀäÀäĞÀäÛÀäáÀå*Àå?Àå`ÀåpÀå€ÀåÀå£Àå­ÀåÅÀåÙÀåßÀæ4Àæ8Àæ9ÀæoÀæ ÀæÊÀæóÀç0ÀçsÀç{ÀçÀç‚Àç°ÀçëÀçñÀçõÀçöÀèEÀè‹Àè¢Àè¨ÀèõÀéFÀéqÀéwÀéËÀêÀêeÀê{ÀêÀêÒÀëÀëiÀëoÀë¼ÀìÀìÀìEÀìÀì”ÀìÙÀìßÀí/ÀíÀíÏÀîÀînÀîºÀîìÀï)ÀïYÀïŸÀïÀÀïÄÀïÅÀïÑÀğÀğ<Àğ@ÀğBÀğCÀğ‰Àğ·ÀñÀñ3Àñ4Àñ}Àñ~ÀñŠÀñ¨ÀñáÀò'Àò‡ÀòÏÀòÓÀòÔÀòàÀòüÀóÀó/ÀóBÀóLÀójÀónÀóoÀó­ÀóËÀóÑÀôÀôHÀôÀôÅÀôËÀõÀõGÀõ`ÀõfÀõ·Àõ½ÀõÍÀõÓÀöÀöXÀö¢Àö´ÀöıÀ÷IÀ÷™À÷¿À÷ÌÀ÷ûÀøÀø"Àø#ÀømÀøsÀø³ÀøêÀù7Àù…Àù‹ÀùÎÀúÀú ÀúqÀúwÀú‡ÀúÀúÖÀûÀû^ÀûpÀû¹Àü
ÀüZÀü€ÀüÀüÈÀüìÀüğÀüñÀıGÀıMÀı–ÀıåÀışÀşÀşQÀşšÀş­Àş³ÀşúÀÿ9Àÿ?ÀÿOÀÿUÀÿ¡Àÿ³ÀÿıÀ FÀ ’À âÀÀÀTÀzÀ~ÀÀ³À¹ÀõÀûÀ9À€À†À–ÀœÀåÀ!ÀmÀÀÉÀÀ?ÀLÀÀÄÀÈÀÉÀ9À?ÀÀàÀæÀ6ÀQÀ^ÀoÀ›À¾ÀÂÀÃÀÀFÀLÀ„ÀŠÀÍÀÙÀÀJÀjÀpÀtÀuÀÆÀõÀûÀ	FÀ	•À	ßÀ	åÀ	õÀ	ûÀ
IÀ
ŠÀ
–À
ÈÀÀ@ÀRÀ„À³ÀêÀÀÀ<ÀHÀtÀ«ÀØÀŞÀâÀäÀåÀ-À1ÀÀÇÀæÀêÀÀÀeÀiÀ—À›ÀáÀåÀ6ÀOÀSÀ¡À­À±ÀüÀÀÀjÀºÀ ÀQÀ†ÀŠÀÕÀ#ÀEÀIÀjÀnÀ³ÀıÀDÀ‹ÀºÀ¾ÀÊÀıÀÀ!À_À‰À™ÀŞÀâÀöÀ:À€À¡ÀÈÀ×ÀßÀãÀğÀöÀşÀÀÀÀ]À–ÀšÀæÀ4À{ÀÉÀÀÀXÀ§ÀòÀBÀÀÈÀÌÀÀaÀ{ÀÀ™ÀÀçÀ4ÀÀŸÀ£ÀòÀBÀ’ÀâÀ%À)ÀyÀÆÀÀgÀ¯ÀÿÀ(À,ÀxÀÆÀ À bÀ fÀ «À ¯À úÀ!JÀ!kÀ!oÀ!«À!¯À!şÀ"OÀ"À"ÏÀ#À#aÀ#À#¢À#èÀ$6À$À$ƒÀ$ĞÀ%À%]À%aÀ%ˆÀ%ŒÀ%ÛÀ&)À&xÀ&ÆÀ&ØÀ&ÜÀ&÷À&ûÀ'FÀ'‹À'ÖÀ( À(mÀ(¼À(ÉÀ(ÍÀ)À)hÀ)›À)ŸÀ)íÀ*=À*ŒÀ*ÉÀ*îÀ*òÀ+À+!À+^À+«À+úÀ,À,À,kÀ,»À,ÛÀ,ßÀ,üÀ- À-KÀ-œÀ-éÀ.-À.bÀ.¬À.äÀ.åÀ/À/!À/eÀ/qÀ/“À/ĞÀ/ëÀ/ïÀ/ğÀ0À0À0À0OÀ0PÀ0qÀ0}À0­À0®À0ãÀ0äÀ1 À1AÀ1„À1ÒÀ2"À2XÀ2¦À2»À2ÍÀ3À3(À32À3GÀ3SÀ3wÀ3}À3À3ÓÀ3ìÀ3ôÀ4À4À4>À4BÀ4CÀ4iÀ4™À4»À4ßÀ5À5À5À5VÀ5À5¹À5óÀ6EÀ6tÀ6„À6èÀ6óÀ7À7PÀ7À7ÍÀ8À8GÀ8eÀ8³À8×À8æÀ96À9lÀ9|À9ÇÀ9×À9÷À:@À:À:«À;À;.À;?À;]À;£À;ôÀ<&À<5À<LÀ<—À<çÀ=6À=jÀ=yÀ=À=ØÀ>'À>lÀ>—À>¦À>ÄÀ?À?QÀ?`À?nÀ?˜À?ıÀ@À@À@"À@,À@0À@1À@{À@œÀ@öÀA)ÀA^ÀA•ÀA–ÀAåÀAşÀBIÀB—ÀB¼ÀCÀC@ÀCÀCÛÀD#ÀDqÀDŠÀDËÀEÀEZÀEœÀEêÀFÀFÀFOÀF†ÀFÀÀFÿÀGHÀG…ÀG‘ÀG¨ÀG¾ÀGÜÀGäÀHÀHÀHÀHMÀHbÀHjÀH—ÀH¼ÀHÌÀHèÀIÀI%ÀI.ÀIAÀIKÀI^ÀIbÀIcÀIoÀI ÀIÂÀIÒÀIñÀJÀJÀJ[ÀJ‡ÀJ—ÀJ·ÀJÊÀJÔÀJäÀKÀKÀK(ÀKEÀKfÀKÀK¡ÀK¢ÀK®ÀKæÀLÀL$ÀL4ÀL[ÀLnÀLxÀL´ÀL¸ÀL¹ÀLâÀLòÀM(ÀM;ÀMEÀMIÀMJÀMVÀM‘ÀM«ÀMçÀMëÀMìÀNÀN)ÀNIÀNdÀNtÀN“ÀN¦ÀN°ÀNûÀOÀO+ÀO>ÀOHÀOÀOƒÀO„ÀOÀO¦ÀO¾ÀOÊÀOèÀP5ÀPaÀPhÀPlÀPmÀPyÀPŒÀP˜ÀP¼ÀQÀQ%ÀQ,ÀQsÀQˆÀQ”ÀQ²ÀQüÀR(ÀR/ÀRcÀRÀR›ÀRŸÀR ÀRêÀSÀSÀS'ÀSoÀS’ÀSÌÀTÀTSÀT†ÀTäÀU.ÀU=ÀUKÀUUÀUyÀUÉÀVÀViÀV°ÀWÀWÀW#ÀW-ÀWHÀW~ÀW„ÀWˆÀW‰ÀW•ÀWºÀWÜÀWüÀXÀX8ÀXˆÀXŞÀXâÀXãÀXïÀYÀYNÀYcÀYªÀYºÀYìÀZÀZ-ÀZnÀZŠÀZ÷À[À[(À[”À[¥À[¾À\!À\vÀ\‡À\—À\¤À\¯À\·À\ÊÀ\ÔÀ]&À]iÀ]”À]ìÀ^?À^EÀ^IÀ^JÀ^VÀ^tÀ^¤À^õÀ_ À_&À_8À_<À_=À_À_‡À_ÕÀ`#À`rÀ`ÃÀ`ûÀaÀaÀasÀatÀa¾ÀaÄÀbÀbÀb_ÀbeÀb´ÀcÀcWÀc©ÀcûÀdNÀdŸÀd×ÀdäÀeÀe$ÀeCÀebÀegÀehÀešÀe ÀeîÀfÀf(Àf~ÀfÀf‹ÀfĞÀfûÀgÀgkÀgrÀgvÀgxÀgyÀgÉÀgÙÀgİÀh+ÀhKÀhXÀh{Àh³ÀhµÀiÀi9ÀiHÀimÀi§Ài«ÀiÔÀiÖÀi×Àj
ÀjÀjTÀjˆÀj¬ÀjøÀkÀk!ÀkRÀkXÀk‘ÀkâÀl2ÀlvÀl˜Àl¿ÀlÓÀlùÀlıÀlşÀm
Àm;ÀmkÀm‡Àm¤ÀmÆÀmÊÀmÌÀmÍÀnÀnUÀnŸÀnßÀnàÀnìÀoÀo#ÀoAÀoEÀoFÀoRÀo•Ào¨Ào¬Ào­Ào¹ÀpÀp!Àp%Àp&Àp2ÀpuÀpˆÀpŒÀpÀp™ÀpËÀpöÀpúÀpüÀpıÀqPÀqTÀqoÀqsÀq¹Àr
ÀrHÀr‹ÀrÕÀs#Às$Às7Às8ÀsDÀssÀsÀs¥Às«Às¯Às°Às¼ÀsàÀsıÀtÀt.Àt2Àt3Àt?ÀtpÀt’ÀtëÀtïÀtğÀtüÀu5ÀuRÀusÀuÌÀuĞÀuÑÀuİÀv ÀvbÀv©ÀvÃÀv÷ÀwÀwFÀwJÀwKÀwWÀw¬Àw¿ÀwÃÀwÄÀwĞÀxÀxUÀxœÀx¶ÀxßÀxşÀy-Ày1Ày3Ày4Ày†ÀyŠÀyĞÀz"ÀzrÀz³Àz·ÀzÅÀzÉÀ{À{<À{ŠÀ{·À{ùÀ|CÀ|À|ÖÀ|×À|ãÀ}6À}KÀ}iÀ}ÆÀ}ÊÀ}ËÀ}ÿÀ~À~RÀ~hÀ~uÀ~ŠÀ~®À~ıÀ~şÀÀnÀ’ÀĞÀÑÀİÀ€.À€‰À€¯À€ãÀ$ÀSÀWÀXÀdÀ‚ÀšÀ½ÀàÀæÀ‚AÀ‚gÀ‚‘À‚ÓÀƒÀƒÀƒÀƒÀƒVÀƒ±Àƒ×À„À„!À„PÀ„TÀ„UÀ„aÀ„À„½À„îÀ…À…À…À…À…À…%À…IÀ…pÀ…¡À…ÄÀ…âÀ…æÀ…çÀ†'À†7À†bÀ†„À†£À†äÀ‡ À‡nÀ‡À‡˜À‡ïÀˆ-Àˆ>ÀˆfÀˆ¹ÀˆÊÀ‰	À‰À‰&À‰1À‰9À‰LÀ‰VÀ‰gÀ‰kÀ‰lÀ‰xÀ‰µÀ‰ûÀŠ7ÀŠLÀŠPÀŠQÀŠ]ÀŠÀŠ°ÀŠöÀ‹&À‹_À‹“À‹°À‹·À‹ÓÀŒÀŒ4ÀŒfÀŒ—ÀŒ ÀŒ¾ÀŒŞÀŒäÀŒşÀÀÀÀGÀdÀªÀÚÀûÀWÀwÀˆÀµÀâÀéÀ	ÀÀÀÀVÀZÀ¦ÀóÀ2À{À¹ÀØÀ‘À‘eÀ‘ŒÀ‘À‘™À‘ªÀ‘×À‘ìÀ’*À’.À’/À’;À’LÀ’jÀ’|À’€À’À’À’²À’ÑÀ“À“À“À“NÀ“eÀ“xÀ“~À“´À“êÀ” À”yÀ”„À”À•À•À•)À•€À•ÚÀ–À–"À–5À–…À–ÔÀ—À—qÀ—ÀÀ—ËÀ—ŞÀ˜-À˜€À˜ÔÀ˜ßÀ˜éÀ˜ïÀ™ À™À™À™À™VÀ™ZÀ™ªÀ™¾À™ÓÀšÀš.Àš/ÀšXÀšqÀšrÀš~Àš·Àš¹ÀšºÀšàÀšûÀ›À›&À›TÀ›YÀ›”À›®À›ÀÀ›àÀ›öÀœ&Àœ+ÀœPÀœbÀœdÀœeÀœ™Àœ¿ÀœÃÀÀQÀ ÀçÀ ÀÀÀÀeÀ·ÀÂÀêÀŸ5ÀŸbÀŸcÀŸ¯ÀŸÊÀŸÛÀŸÜÀ À (À )À 5À XÀ „À ˜À À ïÀ óÀ ôÀ¡ À¡1À¡3À¡4À¡yÀ¡À¡ÃÀ¡òÀ¡óÀ¢$À¢%À¢1À¢kÀ¢mÀ¢nÀ¢‘À¢¨À¢©À¢µÀ¢îÀ¢ğ   /
_DebugOnly
_debugOnly	ObjectKey	GlobalKeyLabeledGlobalKeyGlobalObjectKeyWidgetStatelessWidgetStatefulWidget_StateLifecycleStateProxyWidgetParentDataWidgetInheritedWidgetRenderObjectWidgetLeafRenderObjectWidgetSingleChildRenderObjectWidgetMultiChildRenderObjectWidget_ElementLifecycle_InactiveElementsBuildContext
BuildScope
BuildOwnerNotifiableElementMixin_NotificationNode_isProfileBuildsEnabledForElement_ElementDiagnosticableTreeNodeErrorWidgetComponentElementStatelessElementStatefulElementProxyElementParentDataElementInheritedElementRenderObjectElementRootRenderObjectElementRootElementMixinLeafRenderObjectElementSingleChildRenderObjectElementMultiChildRenderObjectElementRenderTreeRootElementDebugCreator_reportExceptionIndexedSlot_NullElement_NullWidget:flutter.flutter.widgets.framework.prefer_const_over_helper÷ * When trying to create a reusable piece of UI, prefer using a widget
   rather than a helper method. For example, if there was a function used to
   build a widget, a [State.setState] call would require Flutter to entirely
   rebuild the returned wrapping widget. If a [Widget] was used instead,
   Flutter would be able to efficiently re-render only those parts that
   really need to be updated. Even better, if the created widget is `const`,
   Flutter would short-circuit most of the rebuild work.flutter.widgets.State.initState‚$If a [State]'s [build] method depends on an object that can itself
change state, for example a [ChangeNotifier] or [Stream], or some
other object to which one can subscribe to receive notifications, then
be sure to subscribe and unsubscribe properly in [initState],
[didUpdateWidget], and [dispose]:

 * In [initState], subscribe to the object.
 * In [didUpdateWidget] unsubscribe from the old object and subscribe
   to the new one if the updated widget configuration requires
   replacing the object.
 * In [dispose], unsubscribe from the object.!flutter.widgets.ProxyWidget.child€ÛThis widget can only have one child. To lay out multiple children, let this
widget's child be a widget such as [Row], [Column], or [Stack], which have a
`children` property, and then provide the children to that widget.-flutter.widgets.BuildContext.asynchronous_gap‚If a [BuildContext] is used across an asynchronous gap (i.e. after performing
an asynchronous operation), consider checking [mounted] to determine whether
the context is still valid before interacting with it:

```dart
  @override
  Widget build(BuildContext context) {
    return OutlinedButton(
      onPressed: () async {
        await Future<void>.delayed(const Duration(seconds: 1));
        if (context.mounted) {
          Navigator.of(context).pop();
        }
      },
      child: const Text('Delayed pop'),
    );
  }
```?flutter.widgets.BuildContext.dependOnInheritedWidgetOfExactType†¦This is typically called implicitly from `of()` static methods, e.g.
[Theme.of].

This method should not be called from widget constructors or from
[State.initState] methods, because those methods would not get called
again if the inherited value were to change. To ensure that the widget
correctly updates itself when the inherited value changes, only call this
(directly or indirectly) from build methods, layout and paint callbacks,
or from [State.didChangeDependencies] (which is called immediately after
[State.initState]).

This method should not be called from [State.dispose] because the element
tree is no longer stable at that time. To refer to an ancestor from that
method, save a reference to the ancestor in [State.didChangeDependencies].
It is safe to use this method from [State.deactivate], which is called
whenever the widget is removed from the tree.

It is also possible to call this method from interaction event handlers
(e.g. gesture callbacks) or timers, to obtain a value once, as long as
that value is not cached and/or reused later.

Calling this method is O(1) with a small constant factor, but will lead to
the widget being rebuilt more often.

Once a widget registers a dependency on a particular type by calling this
method, it will be rebuilt, and [State.didChangeDependencies] will be
called, whenever changes occur relating to that widget until the next time
the widget or one of its ancestors is moved (for example, because an
ancestor is added or removed).

The [aspect] parameter is only used when `T` is an
[InheritedWidget] subclasses that supports partial updates, like
[InheritedModel]. It specifies what "aspect" of the inherited
widget this context depends on.Dflutter.widgets.BuildContext.getElementForInheritedWidgetOfExactType‚7Calling this method is O(1) with a small constant factor.

This method does not establish a relationship with the target in the way
that [dependOnInheritedWidgetOfExactType] does.

This method should not be called from [State.dispose] because the element
tree is no longer stable at that time. To refer to an ancestor from that
method, save a reference to the ancestor by calling
[dependOnInheritedWidgetOfExactType] in [State.didChangeDependencies]. It is
safe to use this method from [State.deactivate], which is called whenever
the widget is removed from the tree.:flutter.widgets.BuildContext.findAncestorWidgetOfExactType„ÑIn general, [dependOnInheritedWidgetOfExactType] is more useful, since
inherited widgets will trigger consumers to rebuild when they change. This
method is appropriate when used in interaction event handlers (e.g.
gesture callbacks) or for performing one-off tasks such as asserting that
you have or don't have a widget of a specific type as an ancestor. The
return value of a Widget's build method should not depend on the value
returned by this method, because the build context will not rebuild if the
return value of this method changes. This could lead to a situation where
data used in the build method changes, but the widget is not rebuilt.

Calling this method is relatively expensive (O(N) in the depth of the
tree). Only call this method if the distance from this widget to the
desired ancestor is known to be small and bounded.

This method should not be called from [State.deactivate] or [State.dispose]
because the widget tree is no longer stable at that time. To refer to
an ancestor from one of those methods, save a reference to the ancestor
by calling [findAncestorWidgetOfExactType] in [State.didChangeDependencies].

Returns null if a widget of the requested type does not appear in the
ancestors of this context.4flutter.widgets.BuildContext.findAncestorStateOfType„ÃThis should not be used from build methods, because the build context will
not be rebuilt if the value that would be returned by this method changes.
In general, [dependOnInheritedWidgetOfExactType] is more appropriate for such
cases. This method is useful for changing the state of an ancestor widget in
a one-off manner, for example, to cause an ancestor scrolling list to
scroll this build context's widget into view, or to move the focus in
response to user interaction.

In general, though, consider using a callback that triggers a stateful
change in the ancestor rather than using the imperative style implied by
this method. This will usually lead to more maintainable and reusable code
since it decouples widgets from each other.

Calling this method is relatively expensive (O(N) in the depth of the
tree). Only call this method if the distance from this widget to the
desired ancestor is known to be small and bounded.

This method should not be called from [State.deactivate] or [State.dispose]
because the widget tree is no longer stable at that time. To refer to
an ancestor from one of those methods, save a reference to the ancestor
by calling [findAncestorStateOfType] in [State.didChangeDependencies].8flutter.widgets.BuildContext.findRootAncestorStateOfTypeFunctions the same way as [findAncestorStateOfType] but keeps visiting subsequent
ancestors until there are none of the type instance of `T` remaining.
Then returns the last one found.

This operation is O(N) as well though N is the entire widget tree rather than
a subtree.;flutter.widgets.BuildContext.findAncestorRenderObjectOfTypeƒÖThis should not be used from build methods, because the build context will
not be rebuilt if the value that would be returned by this method changes.
In general, [dependOnInheritedWidgetOfExactType] is more appropriate for such
cases. This method is useful only in esoteric cases where a widget needs
to cause an ancestor to change its layout or paint behavior. For example,
it is used by [Material] so that [InkWell] widgets can trigger the ink
splash on the [Material]'s actual render object.

Calling this method is relatively expensive (O(N) in the depth of the
tree). Only call this method if the distance from this widget to the
desired ancestor is known to be small and bounded.

This method should not be called from [State.deactivate] or [State.dispose]
because the widget tree is no longer stable at that time. To refer to
an ancestor from one of those methods, save a reference to the ancestor
by calling [findAncestorRenderObjectOfType] in [State.didChangeDependencies].2flutter.widgets.BuildContext.visitAncestorElements‚oThe callback is given a reference to the ancestor widget's corresponding
[Element] object. The walk stops when it reaches the root widget or when
the callback returns false. The callback must not return null.

This is useful for inspecting the widget tree.

Calling this method is relatively expensive (O(N) in the depth of the tree).

This method should not be called from [State.deactivate] or [State.dispose]
because the element tree is no longer stable at that time. To refer to
an ancestor from one of those methods, save a reference to the ancestor
by calling [visitAncestorElements] in [State.didChangeDependencies]./flutter.widgets.BuildContext.visitChildElementsƒ\This is useful for applying changes to children after they are built
without waiting for the next frame, especially if the children are known,
and especially if there is exactly one child (as is always the case for
[StatefulWidget]s or [StatelessWidget]s).

Calling this method is very cheap for build contexts that correspond to
[StatefulWidget]s or [StatelessWidget]s (O(1), since there's only one
child).

Calling this method is potentially expensive for build contexts that
correspond to [RenderObjectWidget]s (O(N) in the number of children).

Calling this method recursively is extremely expensive (O(N) in the number
of descendants), and should be avoided if possible. Generally it is
significantly cheaper to use an [InheritedWidget] and have the descendants
pull data down, than it is to use [visitChildElements] recursively to push
data down to them."flutter.widgets.Element.reassembleƒÜCalled whenever the application is reassembled during debugging, for
example during hot reload.

This method should rerun any initialization logic that depends on global
state, for example, image loading from asset bundles (since the asset
bundle may have changed).

This function will only be called during development. In release builds,
the `ext.flutter.reassemble` hook is not available, and so this code will
never execute.

Implementers should not rely on any ordering for hot reload source update,
reassemble, and build methods after a hot reload has been initiated. It is
possible that a [Timer] (e.g. an [Animation]) or a debugging session
attached to the isolate could trigger a build with reloaded code _before_
reassemble is called. Code that expects preconditions to be set by
reassemble after a hot reload must be resilient to being called out of
order, e.g. by fizzling instead of throwing. That said, once reassemble is
called, build will be called after it at least once.;flutter.widgets.RenderObjectElement.insertRenderObjectChildThe semantics of `slot` are determined by this element. For example, if
this element has a single child, the slot should always be null. If this
element has a list of children, the previous sibling element wrapped in an
[IndexedSlot] is a convenient value for the slot. ù	