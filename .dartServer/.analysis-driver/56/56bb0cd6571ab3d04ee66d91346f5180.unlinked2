Äìpattern	variablesguardnone	logicalOrsharedCaseAbsentsharedCaseHasLabeldifferentFinalityOrType	_severitymaxWith
maxWithAllsinglePatternsharedCaseScopekeyvaluenodenameequals	notEqualsotherkindparameterType
returnTypehead
expressionheads	hasLabelsbody_dotShorthandserrorsflowisDotShorthandContextEmpty
operationstypeAnalyzerOptionsanalyzeAssignedVariablePattern$analyzeAssignedVariablePatternSchemaanalyzeCastPatternanalyzeCastPatternSchemaanalyzeConstantPatternanalyzeConstantPatternSchemaanalyzeDeclaredVariablePattern$analyzeDeclaredVariablePatternSchemaanalyzeDotShorthandanalyzeExpressionanalyzeIfCaseElementanalyzeIfCaseStatementanalyzeIfElementanalyzeIfStatementanalyzeIntLiteralanalyzeListPatternanalyzeListPatternSchemaanalyzeLogicalAndPatternanalyzeLogicalAndPatternSchemaanalyzeLogicalOrPatternanalyzeLogicalOrPatternSchemaanalyzeMapPatternanalyzeMapPatternSchemaanalyzeNullCheckOrAssertPattern%analyzeNullCheckOrAssertPatternSchemaanalyzeObjectPatternanalyzeObjectPatternSchemaanalyzePatternAssignmentanalyzePatternForIn!analyzePatternVariableDeclarationanalyzeRecordPatternanalyzeRecordPatternSchemaanalyzeRelationalPatternanalyzeRelationalPatternSchemaanalyzeSwitchExpressionanalyzeSwitchStatement'analyzeUninitializedVariableDeclarationanalyzeWildcardPatternanalyzeWildcardPatternSchemadispatchCollectionElementdispatchExpressiondispatchPatterndispatchPatternSchemadispatchStatement&downwardInferObjectPatternRequiredTypefinishExpressionCasefinishJoinedPatternVariablegetDotShorthandContextgetMapPatternEntrygetRestPatternElementPatterngetSwitchExpressionMemberInfogetSwitchStatementMemberInfo#handle_ifCaseStatement_afterPatternhandle_ifElement_conditionEndhandle_ifElement_elseEndhandle_ifElement_thenEndhandle_ifStatement_conditionEndhandle_ifStatement_elseEndhandle_ifStatement_thenEnd handle_logicalOrPattern_afterLhshandleCase_afterCaseHeadshandleCaseHeadhandleDefaulthandleListPatternRestElementhandleMapPatternEntryhandleMapPatternRestElementhandleMergedStatementCasehandleNoCollectionElementhandleNoGuardhandleNoStatementhandleSwitchBeforeAlternativehandleSwitchScrutineeisDotShorthandisLegacySwitchExhaustiveisRestPatternElementisVariablePatternpopDotShorthandContextpushDotShorthandContextresolveObjectPatternPropertyGet resolveRelationalPatternOperatorsetVariableTypevariableTypeFromInitializerType_analyzeIfCommon_analyzeIfElementCommon_checkGuardType_finishJoinedPatternVariables_matchRecordTypeShape#_reportDuplicateRecordPatternFields _structurallyEqualAfterNormTypescaseExpressionTypeMismatch"duplicateAssignmentPatternVariableduplicateRecordPatternFieldduplicateRestPatternemptyMapPattern!inconsistentJoinedPatternVariable matchedTypeIsStrictlyNonNullablematchedTypeIsSubtypeOfRequirednonBooleanCondition#patternForInExpressionIsNotIterable'patternTypeMismatchInIrrefutableContext$refutablePatternInIrrefutableContext)relationalPatternOperandTypeNotAssignable6relationalPatternOperatorReturnTypeNotAssignableToBoolrestPatternInMapswitchCaseCompletesNormallyunnecessaryWildcardPatternassertInErrorRecoverypatternsEnabledinferenceUpdate3Enabled%respectImplicitlyTypedVarInitializersfieldPromotionEnabledinferenceUpdate4EnabledsoundFlowAnalysisEnabledCaseHeadOrDefaultInfo"JoinedPatternVariableInconsistencyJoinedPatternVariableLocationMapPatternEntryRecordPatternFieldRelationalOperatorKindRelationalOperatorResolutionSwitchExpressionMemberInfoSwitchStatementMemberInfoTypeAnalyzerTypeAnalyzerErrorsTypeAnalyzerErrorsBaseTypeAnalyzerOptionsÅjanalyzeSwitchExpressionanalyzeSwitchStatementObjectMapStringint	_severityIterablemaxWithotheranalyzeObjectPatternanalyzeRecordPatternanalyzeRecordPatternSchemaSharedTypeViewListboolNode!TypeAnalysisNullShortingInterface
ExpressionVariableSharedTypeSchemaView	StatementPatternErroroverrideFlowAnalysis_dotShorthandsisEmptyTypeAnalyzerOperationsTypeDeclarationTypeTypeDeclarationAssignedVariablePatternResultdispatchPatternanalyzeDeclaredVariablePatternMatchContextflowgetMatchedValueTypeassignedVariableserrors"duplicateAssignmentPatternVariablevariableoriginal	duplicate
operationsvariableTypeirrefutableContextSharedDynamicTypeSharedInvalidTypeisSubtypeOf'patternTypeMismatchInIrrefutableContextpatterncontextmatchedTyperequiredTypepromoteForPattern	knownTypeassignedVariablePattern'duplicateAssignmentPatternVariableError,patternTypeMismatchInIrrefutableContextErrormatchedValueTypetypeToSchemapromotedTypeinnerPatternPatternResultmatchFailsIfWrongTypematchedTypeIsSubtypeOfRequiredpushSubpatternwithUnnecessaryWildcardKindpopSubpatternunknownTypeConstantPatternResult$refutablePatternInIrrefutableContextanalyzeExpressionconstantPattern_endpatternsEnabledtypeAnalyzerOptionsswitchScrutineecaseExpressionTypeMismatchcaseExpression	scrutineecaseExpressionTypescrutineeTypeexpressionType)refutablePatternInIrrefutableContextErrorcaseExpressionTypeMismatchErrorassertInErrorRecoveryDeclaredVariablePatternResultvariableTypeFromInitializerTypepatternVariablePromotionKeysdeclaredVariablePattern
staticTypeisFinalisVariableFinalisLateisImplicitlyTypedsetVariableTypecomponentVariablesaddassignMatchedPatternVariablepushDotShorthandContextExpressionTypeAnalysisResultdispatchExpressionpopDotShorthandContexttypecontinueNullShortingnullShortingDepthSharedDynamicTypeSchemaViewisBottomType
handleExitfinishNullShortingnode
expressionifTrueifFalse	variablesIfCaseStatementResulthandleNoCollectionElementhandleNoGuardifCaseStatement_beginifCaseStatement_afterExpression_finishJoinedPatternVariableslocationsinglePatternguardboolType_checkGuardTypeifCaseStatement_thenBegin_analyzeIfElementCommonmatchedExpressionTypenonBooleanGuardError	guardTypehandleNoStatement#handle_ifCaseStatement_afterPattern_analyzeIfCommon	conditionvoidifStatement_conditionBeginhandle_ifElement_conditionEndifStatement_thenBeginhandle_ifStatement_conditionEndIntTypeAnalysisResultisTypeSchemaSatisfiedintType
typeSchema
doubleTypeconvertedToDoubleelementTypeelementsListPatternResultmatchListTypedynamicType	errorTypeobjectQuestionTypelistTypematchMayFailEvenIfCorrectTypelengthisRestPatternElementiduplicateRestPatternmapOrListPatterngetRestPatternElementPatternhandleListPatternRestElementisAssignableToduplicateRestPatternErrorslistTypeSchemaelementdispatchPatternSchemamatchIterableTypeSchematypeSchemaGlbUnnecessaryWildcardKindlogicalAndPatternOperandLogicalOrPatternResultmakeRefutablelogicalOrPattern_beginwithPromotionKeysMapEntryentriesentrykeyvaluecontainsKeylogicalOrPattern_afterLhs handle_logicalOrPattern_afterLhscopyPromotionData	sourceKeydestinationKeylogicalOrPattern_endtypeArgumentsMapPatternResultkeyType	valueTypematchMapTypemapTypesoundFlowAnalysisEnabledrestPatternInMapgetMapPatternEntryhandleMapPatternEntryhandleMapPatternRestElementemptyMapPatternemptyMapPatternErrorrestPatternErrorsmapTypeSchemakeyTypeSchemavalueTypeSchemaisAssertNullCheckOrAssertPatternResultnullCheckOrAssertPattern_begin matchedTypeIsStrictlyNonNullablenullCheckOrAssertPattern_end%matchedTypeIsStrictlyNonNullableErrormakeTypeSchemaNullablefieldsObjectPatternResult#_reportDuplicateRecordPatternFields&downwardInferObjectPatternRequiredTyperesolveObjectPatternPropertyGetobjectPatternreceiverTypefieldnamepushPropertySubpatternpropertyMemberunpromotedPropertyTypepopPropertySubpattern!duplicateRecordPatternFieldErrorsPatternAssignmentAnalysisResultpatternAssignment_afterRhs
isNotEmptypatternAssignment_endpatternSchemaPatternForInResulthasAwaitstreamTypeSchemaiterableTypeSchemamatchStreamTypematchIterableType#patternForInExpressionIsNotIterablepatternForIn_afterExpressionforEach_bodyBegindispatchBodyforEach_endpatternForIn_end(patternForInExpressionIsNotIterableError(PatternVariableDeclarationAnalysisResult+patternVariableDeclaration_afterInitializerpatternVariableDeclaration_endinitializerTypeRecordPatternResult
recordType
positionalfillednamedSharedRecordTypeView_matchRecordTypeShaperecordTypeSchema resolveRelationalPatternOperatorRelationalPatternResultparameterTypekindequals	notEqualsmakeNullableisDotShorthandequalityRelationalPattern_endnotEqual nonEqualityRelationalPattern_end)relationalPatternOperandTypeNotAssignableoperandType
returnType6relationalPatternOperatorReturnTypeNotAssignableToBool*operatorReturnTypeNotAssignableToBoolErrorargumentTypeNotAssignableErrorSwitchExpressionResulthandleSwitchScrutineeswitchStatement_expressionEnd	neverTypegreatestClosureOfSchematopTypegetSwitchExpressionMemberInfo!switchStatement_beginAlternatives switchStatement_beginAlternativehandleSwitchBeforeAlternative	caseIndexsubIndexheadhandleCaseHeadhandleDefaultswitchStatement_endAlternativeswitchStatement_endAlternatives	hasLabelsswitchStatement_afterCaselubfinishExpressionCaseinferenceUpdate3EnabledswitchStatement_endnonBooleanGuardErrors
guardTypes!SwitchStatementTypeAnalysisResultgetSwitchStatementMemberInfoheads	headIndexPatternVariableInfosharedCaseScopehandleCase_afterCaseHeadsvaluesbodydispatchStatement	statementswitchCaseCompletesNormallyhandleMergedStatementCaseisTerminatingisAlwaysExhaustiveTypeisLegacySwitchExhaustive
hasDefaultisExhaustivelastCaseTerminates requiresExhaustivenessValidation!switchCaseCompletesNormallyErrorsdeclareinitializedWildcardPatternResultdeclaredTypeunnecessaryWildcardKindunnecessaryWildcardPatternanalyzeIfElementlast$2
removeLast$1analyzeIfStatementanalyzeIfCaseStatementhandle_ifStatement_thenEndifStatement_endifStatement_elseBeginhandle_ifStatement_elseEndanalyzeIfCaseElementdispatchCollectionElementhandle_ifElement_thenEndhandle_ifElement_elseEndnonBooleanConditionkeysvariableName	identical	component _structurallyEqualAfterNormTypes!inconsistentJoinedPatternVariablefinishJoinedPatternVariableinconsistencynonedifferentFinalityOrTypeSharedNamedTypeView
namedTypesIteratorpositionalTypesiteratormoveNextcurrentduplicateRecordPatternFieldobjectOrRecordPattern	normalizeunwrapTypeViewisStructurallyEqualTo!TypeAnalysisNullShortingInterfaceTypeAnalyzerErrorsBase∑3¡¯Ùø<ØQ{ß'∞û    ÄŸ   #../flow_analysis/flow_analysis.dart  Å   ../types/shared_type.dart  Å+   null_shorting.dart  ÅH   type_analysis_result.dart  Ål   type_analyzer_operations.dart¿  € ¿∑†ã¬ MÄõÄ◊ÄÿÅÅ*ÅGÅkÅìÅîÅÂÇ.ÇDÇHÇÜÇ£Ç∫Ç’ÇÔÇÛÉAÉXÉYÉ¶ÉÑ:ÑPÑyÑzÑ∆ÑÁÖÖÖÖ8ÖUÖeÖkÖmÖnÖßÖ—ÖÈÖÙÖıÜ5ÜEÜFÜÑÜõÜúÜ◊ÜÜÒá8áuáìáîá´á¨áËáÈà-à[àâàèà∆à àÀââAâzâÄâ∂âıää!ä4ä8ä:ä;äzäüä”ä‰äÂã-ã@ãBãCãéã¶ãΩãæã˚ã˝ã˛åMåyå»åﬂå„ç!çiç∑ç◊çÍçÎé4éJécédé{éìé´é∆éÃéŒéœèè(èFè^èhèièÅèéèèèÕè÷èÿèŸêê+êPêvêôêöêªê”êÙëëëëëlë†ë§ë‚ííí6íPíTíìí”í‘ìì%ì&ìtìvìwì«ì˚ìˇî=î^îuîèî™îƒî»îÙî˙ïIïäï—ï“ññ4ñ5ñÜñ‘ó!ó5óSóTó¢óò:òÜòœòÚôôô:ôSôkôàô•ô´ô≠ôÆô¸öMöáöãöÿõ(õyõ úúfúóúõúÏù:ùÅùœùﬁù‚û1û}û üücü®ü¨ü˝†N†õ†È°4°Ñ°ê°î°‰¢2¢Ç¢”¢Ê¢Í£6£}£¿£ƒ§§9§=§á§‘•%•s•¿¶¶a¶u¶y¶ªß
ß$ßsß√®®)®-®x®»©©*©>©U©o©ä©•©Ω©∆©Ï™™™™I™_™s™å™ò™›™„´/´Ä´´´Ê´Á´˝¨¨¨&¨4¨H¨U¨_¨c¨q¨r¨~¨Œ¨œ≠≠>≠≠Ä≠å≠€≠Ì≠ÓÆ&ÆUÆVÆ†ÆÌØØØ\ØjØpØ™Ø∞ØÊ∞%∞+∞E∞å∞€∞Ì±±
±L±Ä±À±≤'≤E≤q≤Ä≤π≤Í≥≥.≥M≥\≥d≥j≥k≥∏≥Û≥ˇ¥!¥n¥u¥Æ¥‘µµ8µÉµøµÛ∂∂7∂b∂í∂ü∂•∂¡∂Ê∑∑∑X∑Ü∑µ∑Ë∏∏T∏~∏Ö∏â∏ä∏€ππUπlπåπ“π◊πÿ∫∫L∫R∫å∫í∫≈∫Íª9ªFªdªáª±ª∏ª˙ºº;ºZº~ºÖº«ºıΩ"Ω<ΩcΩáΩêΩñΩ‚æ/æ}æÕøø&øMøõø≥øÕ¿ @¿ @¿ @¿ @G¿ @M¿ @g¿ @¥¿ @µ¿ @˚¿ AE¿ Aî¿ Aö¿ A‘¿ A⁄¿ B'¿ BT¿ BZ¿ BÉ¿ B∫¿ C	¿ C¿ C3¿ C9¿ C{¿ Cå¿ C«¿ C˝¿ D#¿ D\¿ Dç¿ D®¿ D—¿ Dﬁ¿ D‰¿ E¿ E-¿ E^¿ Ee¿ EÉ¿ Eï¿ E´¿ EÁ¿ F¿ F¿ F3¿ F_¿ Fè¿ FÃ¿ FÒ¿ GB¿ GZ¿ G©¿ G—¿ G˘¿ H)¿ HV¿ Hc¿ Hm¿ Hu¿ H{¿ H°¿ H«¿ H¯¿ I-¿ Iu¿ Iü¿ I¶¿ I™¿ I´¿ I‚¿ IË¿ J¿ J:¿ Jâ¿ J‘¿ K¿ K?¿ Kb¿ Kf¿ Kg¿ Kµ¿ K˝¿ LM¿ Lï¿ L‚¿ M¿ M¿ MA¿ MG¿ Mì¿ M›¿ M„¿ M˝¿ ND¿ Nì¿ N•¿ Nº¿ N’¿ N˜¿ N˝¿ O?¿ O_¿ O™¿ OÂ¿ P¿ PD¿ Pv¿ P®¿ PÈ¿ Q%¿ QY¿ Qt¿ Qù¿ Q»¿ QÓ¿ Q˚¿ R¿ R¿ RB¿ R_¿ Rf¿ R≤¿ R˛¿ S5¿ Sx¿ S´¿ SÁ¿ T8¿ TZ¿ TÑ¿ T¶¿ TÚ¿ U¿ U;¿ UF¿ Uq¿ U∂¿ Uı¿ V#¿ VA¿ Vu¿ V≠¿ V◊¿ Vﬁ¿ V‚¿ V„¿ W-¿ Wv¿ Wò¿ Wû¿ W∏¿ Wı¿ X¿ X¿ X=¿ X^¿ Xè¿ Xì¿ Xî¿ X¥¿ X˙¿ Y ¿ Y5¿ YW¿ Y]¿ Yâ¿ Yœ¿ Y€¿ YÍ¿ YÒ¿ Z¿ Z/¿ Z3¿ Z4¿ Z|¿ Z«¿ ZÕ¿ [¿ [m¿ [∂¿ [–¿ [÷¿ \'¿ \p¿ \v¿ \ü¿ \√¿ \ÿ¿ \˚¿ ]"¿ ])¿ ]K¿ ]ó¿ ]®¿ ]Ÿ¿ ^ ¿ ^¿ ^R¿ ^m¿ ^ù¿ ^∂¿ ^º¿ ^„¿ _¿ _E¿ _Ö¿ _ã¿ _ú¿ _†¿ _°¿ _—¿ ` ¿ `:¿ `@¿ `ç¿ `ÿ¿ a¿ a%¿ au¿ aƒ¿ b¿ b¿ be¿ bé¿ bî¿ b·¿ c-¿ cu¿ c¬¿ c˜¿ d-¿ dE¿ di¿ dá¿ dµ¿ d’¿ dÔ¿ e¿ e)¿ e0¿ eA¿ ec¿ eõ¿ e≠¿ eÀ¿ e“¿ f¿ f4¿ fm¿ f•¿ fÿ¿ fÌ¿ g:¿ gR¿ gÇ¿ g∆¿ gœ¿ gﬁ¿ gÂ¿ h	¿ h,¿ h=¿ hW¿ h{¿ h∏¿ hø¿ h‡¿ hˇ¿ i¿ i=¿ iL¿ iÇ¿ iã¿ iÀ¿ iÿ¿ iˆ¿ i¸¿ j'¿ jR¿ jè¿ jµ¿ j„¿ k¿ k1¿ k8¿ k<¿ k=¿ kç¿ k«¿ kÕ¿ l¿ lg¿ lÆ¿ l¥¿ m¿ m.¿ m4¿ mÅ¿ m–¿ n¿ nh¿ n¿ n∂¿ n ¿ nÂ¿ n˙¿ o¿ o'¿ o?¿ od¿ oj¿ o{¿ où¿ o’¿ oÁ¿ p¿ p¿ pS¿ pn¿ pß¿ pﬂ¿ q¿ q'¿ qt¿ qå¿ qº¿ r ¿ r	¿ r¿ r¿ r ¿ rC¿ rT¿ rn¿ rí¿ rœ¿ r÷¿ r◊¿ s¿ s0¿ sQ¿ sp¿ sâ¿ sÆ¿ sΩ¿ sÛ¿ s¸¿ t<¿ tI¿ tg¿ tm¿ tò¿ t√¿ t¿ u¿ uD¿ uv¿ uí¿ uô¿ uù¿ uû¿ uÈ¿ v¿ v¿ vg¿ vµ¿ vﬂ¿ vÂ¿ w1¿ wÄ¿ wµ¿ wÿ¿ wÚ¿ x
¿ x-¿ xG¿ xc¿ xÅ¿ xà¿ xô¿ x¿¿ y¿ y9¿ y^¿ yè¿ yÃ¿ y–¿ y—¿ z¿ z?¿ zE¿ zì¿ z·¿ {¿ {¿ {_¿ {Ø¿ {Ê¿ |¿ |¿ |/¿ |E¿ |]¿ |c¿ |t¿ |õ¿ |Î¿ }¿ };¿ }l¿ }ô¿ }ù¿ }û¿ }·¿ }Á¿ ~¿ ~J¿ ~e¿ ~ê¿ ~¥¿ ~“¿ ~ﬂ¿ 	¿ 0¿ N¿ Y¿ É¿ £¿ ¡¿ Á¿ ˘¿ Ä#¿ Ä*¿ Ä.¿ Ä/¿ Ä~¿ Ä ¿ ÄÂ¿ ÄÎ¿ Å<¿ ÅS¿ ÅY¿ Åì¿ Åô¿ Å›¿ Ç¿ Ç[¿ Ço¿ Çê¿ Ç≤¿ Çπ¿ Ç˚¿ É¿ É8¿ ÉW¿ Éd¿ É¶¿ É¿¿ É…¿ ÉÓ¿ Ñ¿ ÑM¿ Ñy¿ Ñ≥¿ Ñ›¿ ÑÏ¿ Ö¿ Ö'¿ Ö-¿ Öo¿ Öã¿ Ö∞¿ Öœ¿ ÖÙ¿ Ü<¿ ÜC¿ ÜT¿ Üs¿ Ü§¿ Ü‘¿ Üˆ¿ á!¿ áL¿ áú¿ á¿¿ áÎ¿ à¿ à¿ à"¿ àI¿ àé¿ à∞¿ àÔ¿ â%¿ â@¿ âw¿ âè¿ âú¿ âº¿ â∆¿ â˚¿ ä
¿ ä2¿ ä¿ äù¿ ä•¿ ä´¿ ä·¿ ã¿ ãU¿ ã{¿ ã¡¿ ã˝¿ å1¿ åL¿ åu¿ å†¿ å»¿ å’¿ å€¿ å˝¿ ç¿ ç]¿ çë¿ ç…¿ çÛ¿ ç˙¿ ç˛¿ çˇ¿ éM¿ éò¿ é´¿ é±¿ éÀ¿ é˝¿ è'¿ èI¿ èP¿ èo¿ èΩ¿ è√¿ èƒ¿ è‡¿ ê ¿ ê&¿ ê'¿ êM¿ êr¿ êô¿ êƒ¿ ë	¿ ë+¿ ër¿ ëä¿ ëó¿ ë·¿ ëÎ¿ ë˙¿ í.¿ í6¿ íU¿ íw¿ íô¿ í™¿ íÚ¿ í¸¿ ì¿ ì
¿ ì5¿ ìg¿ ìk¿ ìl¿ ìª¿ ì˛¿ î¿ î>¿ îD¿ î}¿ îß¿ îˆ¿ ï¿ ï¿ ï$¿ ï*¿ ïl¿ ï}¿ ïí¿ ïΩ¿ ï˜¿ ñ ¿ ñ¿ ñ¿ ñ/¿ ñD¿ ño¿ ñ©¿ ñ≤¿ ñΩ¿ ñƒ¿ ñ¿ ó2¿ ó6¿ ó7¿ óÜ¿ óª¿ ó¡¿ ó€¿ ò'¿ òL¿ òn¿ òê¿ òó¿ òõ¿ òú¿ òÍ¿ ô-¿ ô3¿ ôÑ¿ ôä¿ ôƒ¿ ô ¿ ö¿ ö<¿ öã¿ öù¿ ö´¿ öπ¿ öø¿ õ¿ õ<¿ õr¿ õò¿ õ—¿ ú¿ ú¿ úF¿ úS¿ ús¿ úú¿ ú¢¿ ú≥¿ ú÷¿ ù¿ ù¿ ù&¿ ùV¿ ùÑ¿ ùè¿ ùñ¿ ù≥¿ û¿ û¿ û^¿ ûÖ¿ û´¿ û˙¿ üC¿ üI¿ üo¿ üõ¿ ü…¿ üﬁ¿ üÏ¿ †¿ †K¿ †V¿ †]¿ †â¿ †œ¿ †ˆ¿ °!¿ °b¿ °ä¿ °Ÿ¿ ¢'¿ ¢W¿ ¢§¿ ¢Ô¿ £(¿ £X¿ £©¿ £˙¿ §	¿ §D¿ §d¿ §å¿ §∫¿ §≈¿ §Õ¿ §”¿ • ¿ •n¿ •Ç¿ •£¿ • ¿ •˚¿ ¶0¿ ¶Z¿ ¶a¿ ¶e¿ ¶f¿ ¶¥¿ ¶Ô¿ ¶ı¿ ß¿ ßZ¿ ß°¿ ßÌ¿ ®<¿ ®`¿ ®É¿ ®á¿ ®à¿ ®’¿ ©!¿ ©<¿ ©B¿ ©í¿ ©©¿ ©Ø¿ ©È¿ ©Ô¿ ™=¿ ™j¿ ™π¿ ™Õ¿ ´¿ ´#¿ ´E¿ ´L¿ ´é¿ ´™¿ ´»¿ ´Ï¿ ¨¿ ¨4¿ ¨_¿ ¨ì¿ ¨†¿ ¨·¿ ≠¿ ≠-¿ ≠Z¿ ≠ê¿ ≠ ¿ ≠Ù¿ Æ ¿ ÆL¿ ÆÜ¿ ÆÆ¿ Æÿ¿ Ø¿ Ø¿ ØD¿ Øw¿ Ø£¿ Ø´¿ Ø±¿ ØÁ¿ Øˇ¿ ∞¿ ∞"¿ ∞Q¿ ∞ù¿ ∞Ì¿ ±¿ ±:¿ ±@¿ ±\¿ ±Å¿ ±†¿ ±‰¿ ±Î¿ ±¸¿ ±˝¿ ≤%¿ ≤U¿ ≤w¿ ≤¢¿ ≤„¿ ≤˘¿ ≥¿ ≥ ¿ ≥(¿ ≥.¿ ≥/¿ ≥_¿ ≥Å¿ ≥“¿ ≥Ì¿ ¥7¿ ¥_¿ ¥∞¿ ¥Á¿ µ¿ µ¿ µC¿ µà¿ µ™¿ µ·¿ µ¸¿ ∂3¿ ∂K¿ ∂X¿ ∂x¿ ∂Ç¿ ∂∂¿ ∂æ¿ ∂ƒ¿ ∑¿ ∑?¿ ∑x¿ ∑û¿ ∑‰¿ ∏ ¿ ∏T¿ ∏o¿ ∏ò¿ ∏√¿ ∏Î¿ ∏¯¿ ∏˛¿ π¿ π;¿ π¿ πÖ¿ π¶¿ π»¿ π¸¿ ∫4¿ ∫f¿ ∫í¿ ∫º¿ ∫√¿ ∫«¿ ∫»¿ ª¿ ª_¿ ªr¿ ªx¿ ªí¿ ª√¿ º¿ º¿ º;¿ ºB¿ ºc¿ ºâ¿ º•¿ ºœ¿ º˝¿ Ω¿ Ω¿ Ω¿ Ω¿ Ω=¿ Ωb¿ Ω≥¿ ΩŒ¿ æ¿ æ*¿ æ5¿ æV¿ æ|¿ æç¿ æÿ¿ æ‚¿ æÍ¿ æ¿ ø¿ øB¿ ø~¿ øÖ¿ øâ¿ øä¿ ø’¿ ¿¿ ¿\¿ ¿b¿ ¿™¿ ¿¡¿ ¿«¿ ¡¿ ¡¿ ¡:¿ ¡É¿ ¡“¿ ¡‰¿ ¬ ¿ ¬¿ ¬#¿ ¬e¿ ¬v¿ ¬¨¿ ¬ﬁ¿ √¿ √j¿ √Ñ¿ √Æ¿ √µ¿ √Ë¿ ƒ!¿ ƒR¿ ƒm¿ ƒñ¿ ƒ£¿ ƒ√¿ ƒÏ¿ ≈¿ ≈T¿ ≈Å¿ ≈ú¿ ≈«¿ ≈‘¿ ≈⁄¿ ∆(¿ ∆@¿ ∆i¿ ∆j¿ ∆ô¿ ∆ ¿ ∆ˇ¿ «,¿ «]¿ «á¿ «é¿ «í¿ «ì¿ «€¿ »,¿ »Y¿ »_¿ »y¿ »∑¿ »”¿ »Ô¿ »ˆ¿ …
¿ …:¿ …g¿ …p¿ …}¿ …∆¿  ¿  e¿  ã¿  ∞¿  ∂¿  ∫¿  ª¿ À	¿ À+¿ À1¿ À~¿ Àõ¿ À°¿ À€¿ À·¿ Ã#¿ ÃV¿ Ã•¿ Ãπ¿ Ãˆ¿ Ã˝¿ Õ?¿ Õx¿ Õ≥¿ Õ¥¿ Õ˛¿ Œ#¿ Œ8¿ Œ?¿ Œ[¿ ŒÄ¿ Œü¿ Œ¶¿ Œß¿ ŒÒ¿ œ¿ œQ¿ œ~¿ œ´¿ œ‹¿ –¿ –¿ –¿ –T¿ –ç¿ –≥¿ –˘¿ —5¿ —i¿ —Ñ¿ —≠¿ —ÿ¿ “ ¿ “¿ “¿ “¿ “%¿ “c¿ “Ø¿ “‘¿ “ˇ¿ ” ¿ ”H¿ ”b¿ ”o¿ ”ø¿ ‘¿ ‘U¿ ‘É¿ ‘Ø¿ ‘÷¿ ‘¿ ’¿ ’0¿ ’?¿ ’a¿ ’ú¿ ’∑¿ ’ø¿ ÷¿ ÷4¿ ÷:¿ ÷n¿ ÷o¿ ÷ì¿ ÷µ¿ ◊¿ ◊5¿ ◊m¿ ◊ó¿ ◊û¿ ◊¢¿ ◊£¿ ◊Ì¿ ÿ8¿ ÿ>¿ ÿX¿ ÿ°¿ ÿÀ¿ ÿœ¿ ÿ–¿ Ÿ¿ Ÿ!¿ Ÿn¿ Ÿ§¿ Ÿ™¿ Ÿ‹¿ ⁄¿ ⁄-¿ ⁄B¿ ⁄V¿ ⁄\¿ ⁄m¿ ⁄∂¿ ⁄˙¿ €¿ €H¿ €Å¿ €π¿ €Œ¿ ‹¿ ‹3¿ ‹U¿ ‹á¿ ‹∑¿ ‹˚¿ ›¿ ›¿ ›¿ ›C¿ ›ì¿ ›π¿ ›ﬂ¿ ›Â¿ ﬁ¿ ﬁ+¿ ﬁ[¿ ﬁ¿ ﬁî¿ ﬁõ¿ ﬁü¿ ﬁ†¿ ﬁÿ¿ ﬁﬁ¿ ﬁÔ¿ ﬂ-¿ ﬂ3¿ ﬂB¿ ﬂ{¿ ﬂÅ¿ ﬂ≥¿ ﬂπ¿ ‡	¿ ‡¿ ‡]¿ ‡ú¿ ‡Œ¿ ‡Ê¿ ·¿ · ¿ ·D¿ ·o¿ ·v¿ ·á¿ ·‘¿ ‚¿ ‚F¿ ‚Ç¿ ‚π¿ ‚À¿ ‚Á¿ ‚Ó¿ „	¿ „
¿ „?¿ „j¿ „ü¿ „◊¿ „ˆ¿ ‰'¿ ‰U¿ ‰ç¿ ‰π¿ ‰»¿ Â¿ Â4¿ ÂN¿ Ât¿ Â¢¿ Â±¿ Â›¿ ÂÂ¿ ÂÎ¿ Ê¿ Ê ¿ ÊY¿ Êë¿ Ê¶¿ ÊÛ¿ Á¿ Á-¿ Á]¿ Á°¿ Á™¿ Áπ¿ Á¿¿ Á‰¿ ÁÂ¿ Ë¿ Ë¿ Ë3¿ ËP¿ ËQ¿ Ët¿ Ëî¿ Ë∫¿ ËÍ¿ È¿ È%¿ È)¿ È*¿ Èg¿ È´¿ È±¿ Èˇ¿ ÍN¿ Íy¿ Í¿ ÍÕ¿ Î¿ Î¿ ÎI¿ Îó¿ Î¶¿ Îª¿ ÎŸ¿ ÎÙ¿ Î˚¿ Ï¿ ÏU¿ Ïç¿ Ï†¿ Ïµ¿ Ïº¿ Ï◊¿ Ì¿ Ì ¿ Ì7¿ Ì>¿ Ìw¿ ÌØ¿ Ìƒ¿ Ó¿ Ó+¿ ÓM¿ Ó}¿ Ó¡¿ Ó ¿ ÓŸ¿ Ó‡¿ Ô¿ Ô¿ Ô'¿ ÔK¿ Ôà¿ Ôè¿ Ô∫¿ Ôﬁ¿ ¿ ?¿ c¿ j¿ n¿ o¿ º¿ ﬁ¿ ‰¿ Ò1¿ ÒN¿ ÒT¿ Òé¿ Òî¿ Ò÷¿ Ú	¿ ÚX¿ Úl¿ Ú©¿ Ú∞¿ ÚÚ¿ Û-¿ Ûm¿ Ûn¿ Ûß¿ Û‚¿ Û„¿ Ù¿ ÙZ¿ ÙÇ¿ Ù”¿ ı¿ ı8¿ ıR¿ ıç¿ ıÀ¿ ˆ
¿ ˆH¿ ˆP¿ ˆl¿ ˆr¿ ˆs¿ ˆ©¿ ˆŸ¿ ˜ ¿ ˜¿ ˜¿ ˜¿ ˜/¿ ˜X¿ ˜ò¿ ˜∆¿ ¯¿ ¯"¿ ¯<¿ ¯c¿ ¯°¿ ¯‡¿ ˘+¿ ˘3¿ ˘9¿ ˘r¿ ˘ï¿ ˘∫¿ ˘·¿ ˘Í¿ ˙¿ ˙¿ ˙2¿ ˙W¿ ˙v¿ ˙}¿ ˙~¿ ˙è¿ ˙√¿ ˚¿ ˚¿ ˚-¿ ˚6¿ ˚V¿ ˚ä¿ ˚º¿ ˚Á¿ ˚Ò¿ ¸ ¿ ¸7¿ ¸?¿ ¸w¿ ¸•¿ ¸›¿ ˝	¿ ˝¿ ˝K¿ ˝Q¿ ˝Ö¿ ˝Ü¿ ˝¡¿ ˝˙¿ ˛ ¿ ˛f¿ ˛¢¿ ˛÷¿ ˛Ò¿ ˇ¿ ˇE¿ ˇm¿ ˇz¿ ˇÄ¿ ˇÅ¿ ˇæ¿ ˇÌ¿ ¿ ¿ 5¿ Z¿ }¿ °¿ ®¿ Ã¿ Ó¿:¿n¿¶¿–¿◊¿€¿‹¿¿¿1¿e¿¢¿©¿Ÿ¿¿L¿ô¿∫¿‘¿˙¿	¿,¿4¿:¿à¿å¿ç¿’¿$¿4¿:¿Ö¿´¿±¿˛¿'¿-¿g¿m¿ñ¿—¿ ¿2¿J¿P¿í¿£¿Ÿ¿¿:¿s¿§¿ø¿Ë¿ı¿˚¿	J¿	V¿	n¿	u¿	≤¿	‚¿
¿
?¿
Q¿
X¿
á¿
≈¿
À¿
Ã¿
Ù¿¿X¿Ä¿æ¿À¿˘¿ˇ¿K¿a¿ã¿ú¿±¿˜¿#¿,¿9¿h¿n¿â¿¥¿Î¿¿*¿n¿û¿÷¿Û¿¿P¿_¿g¿ç¿™¿«¿“¿¿S¿p¿ü¿Æ¿∂¿º¿‰¿¿5¿j¿ú¿“¿¿B¿I¿M¿N¿á¿ç¿ß¿·¿2¿}¿ƒ¿Ë¿¿¿¿Z¿`¿¨¿‰¿Í¿6¿M¿Ü¿õ¿µ¿«¿Ë¿Ó¿ˇ¿ ¿P¿ù¿≠¿¥¿˚¿2¿C¿a¿h¿É¿Æ¿˜¿¯¿D¿p¿ö¿π¿“¿˚¿¿U¿Ä¿–¿Ë¿¿4¿Ñ¿’¿¿H¿Ö¿ï¿æ¿«¿Ò¿¿O¿õ¿œ¿¿2¿z¿´¿∆¿Â¿$¿b¿}¿õ¿Ø¿…¿‡¿˛¿¿$¿B¿l¿¢¿Ï¿˚¿ ¿ ¿ F¿ m¿ ç¿ ∑¿ ˙¿!¿!E¿!n¿!ó¿!±¿!Î¿" ¿"<¿"K¿"ò¿"»¿"¯¿#@¿#N¿#ö¿#≠¿#—¿$¿$)¿$d¿$u¿$Ø¿$π¿$Ò¿%7¿%t¿%¬¿&
¿&4¿&>¿&h¿&±¿& ¿&‹¿&Ì¿'¿'¿'C¿'|¿'Ñ¿'–¿(
¿(#¿(0¿(e¿(ê¿(®¿(µ¿)¿)&¿)>¿)K¿)y¿)Å¿)ô¿)°¿)ß¿)›¿*¿*(¿*@¿*t¿*í¿*ô¿*ù¿*û¿*Ê¿*Ï¿+7¿+}¿+¿¿+‘¿+Ó¿,¿,¿,¿,S¿,d¿,Ç¿,â¿,§¿,Œ¿-¿-3¿-W¿-è¿-≈¿-˘¿.:¿.z¿.™¿.Í¿/¿/W¿/ô¿/ﬂ¿/˚¿0B¿0É¿0°¿0«¿0¯¿1¿1/¿1O¿1n¿1y¿1î¿1≥¿1Ú¿20¿2K¿2i¿2}¿2ó¿2Æ¿2Ã¿2„¿2Ú¿3¿3:¿3p¿3∫¿3…¿3ﬁ¿3Î¿4¿40¿4P¿4z¿4Ω¿4 ¿5¿5B¿5`¿5¿5π¿5Œ¿6
¿6¿6f¿6≤¿6‚¿70¿7X¿7f¿7¨¿7Ó¿8¿8-¿89¿8Ñ¿8ï¿8≤¿8¸¿9¿9H¿9q¿9µ¿9Ω¿9˝¿:#¿:b¿:é¿:†¿:Õ¿:⁄¿;¿;N¿;u¿;ä¿;º¿;¯¿<;¿<F¿<N¿<í¿<›¿=¿=H¿=n¿=v¿=¡¿=¯¿>6¿>\¿>é¿>Ø¿>ˆ¿?B¿?J¿?k¿?y¿?ó¿?¬¿?À¿@¿@¿@U¿@l¿@ó¿@≠¿@»¿@¯¿A.¿Aq¿A£¿A∞¿AÙ¿B$¿B*¿BV¿Bà¿B¶¿B»¿Bˆ¿C@¿Cd¿C∞¿C‰¿D¿D	¿D¿D¿DT¿Dk¿Dq¿D¿¿E¿EB¿EH¿Eb¿Eh¿Eô¿E”¿E‚¿E˘¿F¿F8¿F?¿Fâ¿F∂¿FÙ¿G¿G¿G¿GM¿GS¿G£¿G©¿G„¿GÈ¿H¿H;¿Hä¿Hó¿H≤¿H›¿H‰¿I&¿Ia¿Iö¿Iÿ¿J ¿J^¿Jî¿J±¿J‹¿K	¿K3¿KB¿KJ¿KP¿KQ¿Kl¿Kå¿KΩ¿K‰¿L¿L¿L¿L:¿L@¿LA¿Lx¿L°¿L‡¿M	¿M ¿MG¿MP¿MV¿M|¿M∞¿MË¿N¿N¿N¿N¿Nl¿Nô¿Nü¿Nπ¿NÔ¿O¿O!¿OA¿Ob¿Oì¿Oó¿Oò¿Oﬁ¿P*¿Pe¿Pk¿Pπ¿Pø¿PÔ¿Q0¿Q1¿Qw¿Qπ¿QË¿QÓ¿R)¿RJ¿RP¿Ry¿R¨¿R¡¿R‚¿RÁ¿RË¿S9¿S?¿Så¿S€¿T#¿T)¿TO¿Tp¿Tø¿T—¿T÷¿T◊¿U&¿U7¿U=¿UW¿Uì¿Uî¿U⁄¿V!¿VO¿VU¿Vî¿V¥¿V∫¿V‚¿W¿W¿Wa¿Wõ¿Wƒ¿W‚¿WË¿WÈ¿X¿X¿Xp¿X´¿X±¿X˛¿Y;¿Y<¿Y`¿Yy¿YÆ¿YÌ¿Z¿Z*¿Z0¿Z1¿Zt¿Zø¿Z¿¿Z˚¿[E¿[F¿[è¿[√¿[ƒ¿\¿\T¿\Z¿\®¿\Ù¿]=¿]C¿]h¿]°¿]ﬁ¿]ﬂ¿^/¿^p¿^v¿^ƒ¿_¿_\¿_b¿_Ü¿_…¿`¿`	¿`I¿`í¿`ì¿`“¿a¿a¿aI¿aÖ¿aÜ¿a…¿b¿b¿bF¿bÄ¿bÅ¿b»¿c¿c¿cX¿cü¿c†¿cÔ¿d(¿d)¿dq¿dw¿d«¿dÔ¿dı¿e<¿e^¿er¿eÖ¿eß¿e¨¿e≠¿e˝¿f¿f¿fa¿f≤¿f ¿f–¿g¿g-¿g>¿gZ¿gu¿g{¿g|¿g¨¿g≤¿g˙¿h2¿hb¿hh¿hè¿h•¿h∂¿h“¿hÌ¿hÛ¿hÙ¿i2¿i8¿i^¿i®¿i©¿iË¿iÓ¿j¿j<¿jS¿jj¿jÜ¿jã¿jå¿j…¿jœ¿jˇ¿kH¿kI¿k~¿kÑ¿k–¿k¯¿k˛¿lM¿lú¿lÏ¿m<¿mB¿mç¿m§¿m∆¿m‹¿m¯¿n¿n¿n ¿nl¿nπ¿o¿o	¿o9¿of¿og¿o∂¿p¿pK¿pQ¿p°¿p›¿p„¿q¿q<¿q=¿qâ¿q’¿r¿r¿rG¿rq¿rr¿r¥¿r∫¿s¿sD¿st¿sö¿s´¿s«¿s‚¿sË¿sÈ¿t8¿tÜ¿tñ¿tú¿tŸ¿tﬂ¿u,¿uI¿uO¿ui¿uú¿uù¿uŒ¿uˆ¿u˜¿vF¿vì¿vô¿v·¿w¿wf¿wg¿w∞¿wÿ¿wŸ¿x¿x8¿x9¿xà¿xÃ¿xÓ¿y¿y¿y¿yd¿y~¿y»¿z¿z7¿z=¿zA¿zB¿zè¿zﬁ¿{¿{]¿{Å¿{´¿{·¿{Á¿{Ë¿|8¿|j¿|p¿|æ¿}	¿}¿}]¿}o¿}î¿}ô¿}ö¿}È¿~9¿~U¿~ï¿~ñ¿~Á¿"¿i¿j¿®¿»¿Œ¿Ä¿Ä`¿Äq¿Äê¿Äæ¿Äﬂ¿Ä˙¿Å¿Å<¿ÅI¿Åm¿Åè¿Å±¿Å‚¿ÅË¿Ç¿Ç ¿Ç!¿Ç]¿Ç{¿ÇÅ¿Ç∑¿ÇŸ¿Ç˘¿É¿É¿É,¿ÉA¿ÉG¿ÉX¿Éà¿É¥¿É›¿É¯¿Ñ¿ÑB¿ÑO¿Ñs¿Ñ¶¿Ñ»¿Ñ˜¿Ñ˝¿ÖA¿ÖE¿ÖF¿Öç¿Öﬁ¿Ü,¿Ü{¿Üé¿Üœ¿á
¿á¿á!¿á%¿á&¿áL¿áq¿á•¿á⁄¿à¿à¿à&¿àq¿à•¿àÌ¿àı¿â¿â¿âb¿ââ¿âØ¿â„¿ä-¿äH¿äp¿äë¿äº¿äÎ¿ã¿ãB¿ãL¿ãó¿ãﬁ¿ãı¿å!¿åS¿ån¿å¿å™¿å‘¿ç¿ç'¿çF¿çY¿ç~¿ç•¿ç±¿çﬁ¿é¿é?¿éf¿ér¿éñ¿éﬂ¿è¿è7¿èY¿è}¿èå¿èò¿è¢¿è™¿è»¿èÔ¿ê¿ê,¿êL¿êg¿êØ¿êÈ¿ë7¿ëj¿ë¶¿ë≥¿ë¯¿í¿í
¿í¿í¿í¿í^¿í•¿í≈¿íÙ¿ì(¿ìN¿ìT¿ìã¿ì◊¿ì¸¿î¿î¿î)¿îA¿îs¿î°¿îﬂ¿ï ¿ï!¿ï;¿ïg¿ïà¿ïü¿ï©¿ïø¿ïŒ¿ï¸¿ñ¿ñ¿ñM¿ñU¿ñr¿ñx¿ñ°¿ñ¥¿ñ∫¿ñÎ¿ñ˛¿ó¿ó¿ó1¿óD¿óH¿óI¿óÅ¿óπ¿óŒ¿ò¿ò¿ò+¿òp¿òû¿òŸ¿ò˙¿ô¿ô]¿ô}¿ô∆¿ôÚ¿ö
¿ö*¿öH¿öU¿öf¿öã¿öï¿öù¿ö£¿öº¿ö¿¿ö¡¿öÍ¿õ¿õ¿õ$¿õ\¿õî¿õÂ¿õÈ¿õÎ¿õÏ¿ú=¿ú}¿ú†¿ú∑¿ú—¿úÏ¿ù¿ù¿ù6¿ù>¿ù@¿ùh¿ù∂¿ù¿û¿û8¿û`¿ûÅ¿ûß¿û≠¿ûÆ¿ûÈ¿ûÔ¿ü.¿ü[¿ü{¿üö¿ü∫¿ü¿¿ü¡¿ü˝¿†#¿†O¿†i¿†¢¿†‹¿†‚¿†„¿°-¿°L¿°s¿°è¿°¨¿°≤¿°≥¿°È¿°Ô¿¢¿¢H¿¢I¿¢ñ¿¢·¿£¿£.¿£N¿£o¿£u¿£v¿£≈¿§¿§?¿§]¿§|¿§Ç¿§É¿§Ã¿§ˇ¿•'¿•E¿•d¿•Ñ¿•ä¿•ã¿•◊¿¶¿¶¿¶^¿¶ü¿¶•¿¶‰¿ß¿ß*¿ßN¿ßp¿ßv¿ßw¿ß≈¿ßˇ¿®¿®V¿®ù¿®È¿®ı¿©'¿©E¿©`¿©¿©ü¿©•¿©¶¿©˜¿©˝¿™L¿™è¿™ï¿™’¿´¿´¿´:¿´@¿´A¿´ê¿´ﬂ¿¨¿¨1¿¨P¿¨q¿¨w¿¨x¿¨√¿¨ﬂ¿≠ ¿≠>¿≠\¿≠b¿≠c¿≠û¿≠§¿≠Â¿Æ/¿Æ0¿ÆÄ¿Æ…¿Æÿ¿Æﬁ¿Ø.¿Øe¿Øã¿Ø®¿Øƒ¿Ø ¿ØÀ¿∞¿∞c¿∞≠¿∞—¿∞Ô¿±¿± ¿±"¿±#¿±q¿±¨¿±‘¿≤ ¿≤p¿≤¡¿≥¿≥&¿≥,¿≥u¿≥ï¿≥ó¿≥ò¿≥Œ¿≥“¿¥¿¥,¿¥J¿¥K¿¥q¿¥r¿¥ø¿µ¿µ`¿µ®¿µ–¿∂¿∂¿∂)¿∂*¿∂P¿∂Q¿∂x¿∂y¿∂ë¿∂¥¿∂ﬂ¿∑¿∑A¿∑l¿∑ò¿∑û¿∑†    Äÿ   Å   Å*   ÅG   Åk     	ÅîÉÿÅîÇåÄÒ/// Information supplied by the client to [TypeAnalyzer.analyzeSwitchExpression]
/// or [TypeAnalyzer.analyzeSwitchStatement] about a single case head or
/// `default` clause.
///
/// The client is free to `implement` or `extend` this class.Ç•Ç•Ç•ÇºÇºÇºÇ◊Ç◊Ç◊ÖeÖ ÖÖ  Ö!Ö0Ö/  Ö<ÖKÖJ  ÖY
Ö_Ö^   ÇıaÉOÉOK/// For a `case` clause, the case pattern.  For a `default` clause, `null`. É[ÅÑnÑnÄÓ/// The pattern variables declared in [pattern]. Some of them are joins of
/// individual pattern variable declarations. We don't know their types
/// until we do type analysis. So, some of these variables might become
/// not consistent. Ñ|ÄÑÑ˚Ñ˚h/// For a `case` clause that has a guard clause, the expression following
/// `when`.  Otherwise `null`.     ãCÄπãCãI ãYãYãYãtãtãtã¿:ã¿ ã¿ãœ  ã—ã‡ãﬂ  ã‰ãÛãÚ   ãêã°ã°  ã®ã∂ã∂      ã˛Çœã˛ç'Å"/// Information supplied by the client to [TypeAnalyzer.analyzeObjectPattern],
/// [TypeAnalyzer.analyzeRecordPattern], or
/// [TypeAnalyzer.analyzeRecordPatternSchema] about a single field in a record
/// or object pattern.
///
/// The client is free to `implement` or `extend` this class.ç:ç:ç:çOçOçOéfeéf éféx  ééééç  éóé¶é•  éØéæéΩ   çk}ç‰ç‰i/// The client specific node from which this object was created.  It can be
/// used for error reporting. çÌ[éDéDF/// If not `null` then the field is named, otherwise it is positional. éLéZéZ      èŸÅ@èŸê,/// Information about a relational operator. êú{êú êúê∏  êøêŒêÕ  ê◊êÊêÂ  ê¯ëë   ê-!êJêJ  êR"êgêg  êxêçêç      ëÇZëëËÄ∆/// Information supplied by the client to [TypeAnalyzer.analyzeSwitchExpression]
/// about an individual `case` or `default` clause.
///
/// The client is free to `implement` or `extend` this class.ííííííí8í8í8ì(Kì( ì(ìB  ìDìSìR  ìXìgìf   íV{íÕíÕ</// The [CaseHeadOrDefaultInfo] associated with this clause. í÷Mìì//// The body of the `case` or `default` clause.     ìwÜ5ìwîCÄ≈/// Information supplied by the client to [TypeAnalyzer.analyzeSwitchStatement]
/// about an individual `case` or `default` clause.
///
/// The client is free to `implement` or `extend` this class.î`î`î`îwîwîwîëîëîëî¨î¨î¨ôÄåô ôô7  ô>ôMôL  ôWôfôe  ôoô~ô}  ôåôõôö   î Åï ï Äπ/// The list of case heads for this case.
///
/// The reason this is a list rather than a single head is because the front
/// end merges together cases that share a body at parse time. ï‘^ñ)ñ)G/// Is `true` if the group of `case` and `default` clauses has a label. ñ7ÅóMóMÄ˜/// The statements following this `case` or `default` clause.  If this list is
/// empty, and this is not the last `case` or `default` clause, this clause
/// will be considered to share a body with the `case` or `default` clause
/// that follows. óVÅ√ôôÅë/// The merged set of pattern variables from [heads]. If there is more than
/// one element in [heads], these variables are joins of individual pattern
/// variable declarations. Some of these variables might be already not
/// consistent, because they are present not in every head. We don't know
/// their types until we do type analysis. So, some of these variables
/// might become not consistent.     ¿õÏï5¿õÏ¿úåÄê/// Interface used by the shared [TypeAnalyzer] logic to report error conditions
/// up to the client during the "visit" phase of type analysis.¿ú¢¿ú¢¿ú¢¿úπ¿úπ¿úπ¿ú”¿ú”¿ú”¿úÓ¿úÓ¿úÓ¿ù	¿ù	¿ù	¿ù ¿ù ¿ù ¿ù8¿ù8¿ù8    ¿ùjÅB¿ù¯¿ù¯ÄÉ/// Called if pattern support is disabled and a case constant's static type
/// doesn't properly match the scrutinee's static type. ¿û¿û.¿û-  ¿û<"¿ûQ¿ûP  ¿ûd¿ûs¿ûr  ¿ûÖ ¿ûî¿ûì   ¿û∞Å¿ü6¿ü6y/// Called for variable that is assigned more than once.
///
/// Returns an error object that is passed on to the caller. ¿ü_¿ür¿üq  ¿ü¿üë¿üê  ¿üû¿ü∞¿üØ   ¿ü√Å¿†¿†9/// Called for a pair of named fields have the same name. ¿†'&¿†9¿†8  ¿†S¿†d¿†c  ¿†m3¿†ô¿†ò  ¿†¶4¿†“¿†—   ¿†ÂÄÃ¿°5¿°5G/// Called for a duplicate rest pattern found in a list or map pattern. ¿°P!¿°b¿°a  ¿°w¿°Ü¿°Ö  ¿°ì¿°¢¿°°   ¿°µÄí¿¢¿¢Y/// Called if a map pattern does not have elements.
///
/// [pattern] is the map pattern. ¿¢,¿¢>¿¢=   ¿¢KÅ)¿£
¿£
Ä≥/// Called when both branches have variables with the same name, but these
/// variables either don't have the same finality, or their `NORM` types
/// are not structurally equal. ¿£2¿£E¿£D  ¿£R¿£e¿£d   ¿£xÅ	¿§¿§Äò/// Called when a null-assert or null-check pattern is used with the matched
/// type that is strictly non-nullable, so the null check is not necessary. ¿§C¿§U¿§T  ¿§a¿§p¿§o   ¿§ÖÅ¿•¿•w/// Called when the matched type of a cast pattern is a subtype of the
/// required type, so the cast is not necessary. ¿•+¿•=¿•<  ¿•I¿•X¿•W  ¿•h¿•w¿•v   ¿•çÄÇ¿•ﬂ¿•ﬂI/// Called if the static type of a condition is not assignable to `bool`. ¿•Ù¿¶	¿¶   ¿¶Åb¿¶Ï¿¶ÏÄ /// Called if in a pattern `for-in` statement or element, the [expression]
/// that should be an `Iterable` (or dynamic) is actually not.
///
/// [expressionType] is the actual type of the [expression]. ¿ß¿ß%¿ß$  ¿ß.¿ßC¿ßB  ¿ßR¿ßa¿ß`   ¿ßyÇ+¿®˝¿®˝Åo/// Called if, for a pattern in an irrefutable context, the matched type of
/// the pattern is not assignable to the required type.
///
/// [pattern] is the AST node of the pattern with the type error, [context] is
/// the containing AST node that established an irrefutable context,
/// [matchedType] is the matched type, and [requiredType] is the required
/// type. ¿©+¿©=¿©<  ¿©I¿©X¿©W  ¿©d¿©s¿©r  ¿©É¿©í¿©ë   ¿©®Åó¿™›¿™›Å"/// Called if a refutable pattern is illegally used in an irrefutable context.
///
/// [pattern] is the AST node of the refutable pattern, and [context] is the
/// containing AST node that established an irrefutable context.
///
/// TODO(paulberry): move this error reporting to the parser. ¿´¿´¿´  ¿´#¿´2¿´1   ¿´CÅ3¿´Á¿´ÁÄô/// Called if the operand of the [pattern] has the type [operandType], which
/// is not assignable to [parameterType] of the invoked relational operator. ¿¨¿¨)¿¨(  ¿¨5¿¨D¿¨C  ¿¨T¿¨c¿¨b   ¿¨zÄÁ¿¨Á¿¨Áb/// Called if the [returnType] of the invoked relational operator is not
/// assignable to `bool`. ¿≠$¿≠6¿≠5  ¿≠B¿≠Q¿≠P   ¿≠eÄ…¿≠Ì¿≠Ì{/// Called if a rest pattern found inside a map pattern.
///
/// [node] is the map pattern.  [element] is the rest pattern. ¿≠ˇ¿Æ¿Æ  ¿Æ¿Æ%¿Æ$   ¿Æ2Åó¿Øm¿ØmÅ(/// Called if one of the case bodies of a switch statement completes normally
/// (other than the last case body), and the "patterns" feature is not
/// enabled.
///
/// [node] is the AST node of the switch statement.  [caseIndex] is the index
/// of the merged case with the erroneous case body. ¿Øè¿Ø£¿Ø¢  ¿Ø¨¿Ø∫¿Øπ   ¿ØÕÅR¿∞¥¿∞¥Ä€/// Called when a wildcard pattern appears in the context where it is not
/// necessary, e.g. `0 && var _` vs. `[var _]`, and does not add anything
/// to type promotion, e.g. `final x = 0; if (x case int _ && > 0) {}`. ¿∞’¿∞Á¿∞Ê  ¿∞Û%¿±¿±    ¿±#Çs¿±#¿±ªÄà/// Base class for error reporting callbacks that might be reported either in
/// the "pre-visit" or the "visit" phase of type analysis.     ¿±÷Åæ¿≥|¿≥|Åí/// Called when the [TypeAnalyzer] encounters a condition which should be
/// impossible if the user's code is free from static errors, but which might
/// arise as a result of error recovery.  To verify this invariant, the client
/// should double check (preferably using an assertion) that at least one
/// error is reported.
///
/// Note that the error might be reported after this method is called.    ¿≥òÑ¿≥ò¿¥w/// Options affecting the behavior of [TypeAnalyzer].
///
/// The client is free to `implement` or `extend` this class. ¿∂{Å"¿∂{ ¿∂{¿∂é  ¿∂ï¿∂§¿∂£  ¿∂∏%¿∂«¿∂∆  ¿∂„3¿∂Ú¿∂Ò  ¿∑#¿∑+¿∑*  ¿∑E%¿∑T¿∑S  ¿∑p&¿∑¿∑~   ¿¥.¿¥9¿¥9  ¿¥M"¿¥X¿¥X  ¿¥tÅé¿µ›¿µ›ÅS/// Indicates whether initializers of implicitly typed variables should be
/// accounted for by SSA analysis.  (In an ideal world, they always would be,
/// but due to https://github.com/dart-lang/language/issues/1785, they weren't
/// always, and we need to be able to replicate the old behavior when
/// analyzing old language versions). ¿∂ ¿∂¿∂  ¿∂,"¿∂7¿∂7  ¿∂S#¿∂^¿∂^       ÖnÑÀÖnÖ¨8/// The kind of inconsistency identified for a variable. áÆ9á¥ á¥á÷  á◊á›á‹   Ö”ÖÎÖÎ/// No inconsistency.ÖÔÖÒÖÖ˜LÜ7Ü7=/// Only one branch of a logical-or pattern has the variable.Ü@ÜBÜAÜHQÜÜÜÜ;/// Not every case of a shared case scope has the variable.ÜñÜòÜóÜûPÜŸÜŸ8/// The shared case scope has a label or `default` case.ÜÎÜÌÜÏÜÛÄûáwáw/// The finality or type of the variable components is not the same.
/// This is reported for both logical-or and shared cases.áéáêáèáñá†á†    áÎÄﬁàRàRA/// Returns the most serious inconsistency for `this` or [other]. à_(àÉàÇ   àÕÅjâ5â5B/// Returns the most serious inconsistency for `this` or [others]. âE3âsâr    ä;Åä;ä>/// The location where the join of a pattern variable happens.  ä°Aä’ä’1/// A single pattern, from `logical-or` patterns. äÁWã/ã/E/// A shared `case` scope, when multiple `case`s share the same body.     éœÅéœè-X/// Kinds of relational pattern operators that shared analysis needs to
/// distinguish.  èHè`è`/// The operator `==` èk!èÉèÉ/// The operator `!=` èëCèœèœ;/// Any relational pattern operator other than `==` or `!=`            ôÆ¿Ç<ôÆ©0è{/// Type analysis logic to be shared between the analyzer and front end.  The
/// intention is that the client's main type inference visitor class can include
/// this mix-in and call shared analysis logic as needed.
///
/// Concrete methods in this mixin, typically named `analyzeX` for some `X`,
/// are intended to be called by the client in order to analyze an AST node (or
/// equivalent) of type `X`; a client's `visit` method shouldn't have to do much
/// than call the corresponding `analyze` method, passing in AST node's children
/// and other properties, possibly take some client-specific actions with the
/// returned value (such as storing intermediate inference results), and then
/// return the returned value up the call stack.
///
/// Abstract methods in this mixin are intended to be implemented by the client;
/// these are called by the `analyzeX` methods to report analysis results, to
/// query the client-specific information (e.g. to obtain the client's
/// representation of core types), and to trigger recursive analysis of child
/// AST nodes.
///
/// Note that calling an `analyzeX` method is guaranteed to call `dispatch` on
/// all its subexpressions.  However, we don't specify the precise order in
/// which this will happen, nor do we always specify which callbacks will be
/// invoked during analysis, because these details are considered part of the
/// implementation of type analysis, not its API.  Instead, we specify the
/// effect that each method has on a conceptual "stack" of entities.
///
/// In documentation, the entities in the stack are listed in low-to-high order.
/// So, for example, if the documentation says the stack contains "(K, L)", then
/// an entity of kind L is on the top of the stack, with an entity of kind K
/// under it.  This low-to-high order is used when describing pushes and pops
/// too, so, for example a method documented with "pushes (K, L)" pushes K
/// first, then L, whereas a method documented with "pops (K, L)" pops L first,
/// then K.
///
/// In the paragraph above, "K" and "L" are just variables for illustrating the
/// conventions.  The actual kinds used by the analyzer are concepts from the
/// language itself such as "Statement", "Expression", "Pattern", etc.  See the
/// `Kind` enum in `test/mini_ir.dart` for a discussion of all possible kinds of
/// stack entries.
///
/// If multiple stack entries share a kind, we will sometimes add a name to
/// clarify which stack entry is which, e.g. analyzeIfStatement pushes
/// "(Expression condition, Statement ifTrue, Statement ifFalse)".
///
/// We'll also use the convention that "n * K" represents n consecutive entities
/// in the stack, each with kind K.
///
/// The kind associated with all pushes and pops is statically known (and
/// documented, and unit tested), and entities never change from one kind to
/// another.  This fact gives the client considerable freedom in how to actually
/// represent the stack in practice; for example, they might choose to ignore
/// some kinds entirely, or represent certain kinds with a block of multiple
/// stack entries instead of just one.  Or they might choose to multiple stacks,
/// one for each kind.  It's also possible that some clients won't need to keep
/// a stack at all.
///
/// Reasons a client might want to actually have a stack include:
/// - Constructing a lowered intermediate representation of the code as a side
///   effect of analysis,
/// - Building up a symbolic representation of the program's runtime behavior,
/// - Or keeping track of AST nodes that need to be replaced (e.g. replacing an
///   `integer literal` node with a `double literal` node when int->double
///   conversion happens).
///
/// The unit tests in the `_fe_analyzer_shared` package associate a simple
/// intermediate representation with each stack entry, and also record the kind
/// of each entry in order to verify that when an entity is popped, it has the
/// expected kind.©@©@©@©W©W©W©q©q©q©å©å©å©ß©ß©ß©ø©ø©ø©»"©»©»©Ó©Ó©Ó ™öÅJ´≥´≥Å/// Cached context types and their respective dot shorthand nodes.
///
/// The [SharedTypeSchemaView] is used to resolve dot shorthand heads. We
/// save the corresponding dot shorthand [Node] to make sure we aren't caching
/// two context types for the same node.´‚´„´ƒ´·´≈´‡´∆´Ã´ÈÄá¨i¨i    ¨tY¨»¨»   ¨t¨u¨—Ä≠≠I≠Ij/// Queries whether the [_dotShorthands] stack is empty, meaning that we have
/// no cached context types.   ≠Çj≠·≠·   ≠Ç≠É≠dÆ@Æ@5/// Options affecting the behavior of [TypeAnalyzer].    YÆXä0∞l∞lÅ‘/// Analyzes a non-wildcard variable pattern appearing in an assignment
/// context.  [node] is the pattern itself, and [variable] is the variable
/// being referenced.
///
/// Returns an [AssignedVariablePatternResult] with information about reported
/// errors.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// For wildcard patterns in an assignment context,
/// [analyzeDeclaredVariablePattern] should be used instead.
///
/// Stack effect: none. ∞êI∞”∞“  ∞ﬂ∞Ë∞Á  ∞Ò∞˚∞˙   ∏åÅJπ/π/Äâ/// Computes the type schema for a variable pattern appearing in an assignment
/// context.  [variable] is the variable being referenced. πYπcπb   π⁄Ü8∫’∫’Ä‡/// Analyzes a cast pattern.  [innerPattern] is the sub-pattern] and
/// [requiredType] is the type to cast to.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Stack effect: pushes (Pattern innerPattern). ∫ÓVª>ª=  ªJª\ª[  ªhªzªy  ªã$ª§ª£   ¿ @Äù¿ @~¿ @~L/// Computes the type schema for a cast pattern.
///
/// Stack effect: none.   ¿ @∑àÚ¿ B¢¿ B¢Åπ/// Analyzes a constant pattern.  [node] is the pattern itself, and
/// [expression] is the constant expression.  Depending on the client's
/// representation, [node] and [expression] might or might not be identical.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Returns a [ConstantPatternResult] with the static type of [expression]
/// and information about reported errors.
///
/// Stack effect: pushes (Expression). ¿ BæI¿ C¿ C   ¿ C	¿ C¿ C  ¿ C¿ C(¿ C'   ¿ I≠Å∏¿ J¿ JP/// Computes the type schema for a constant pattern.
///
/// Stack effect: none.   ¿ Kiãx¿ N$¿ N$Ç{/// Analyzes a variable pattern in a non-assignment context.  [node] is the
/// pattern itself, [variable] is the variable, [declaredType] is the
/// explicitly declared type (if present).  [variableName] is the name of the
/// variable; this is used to match up corresponding variables in the
/// different branches of logical-or patterns, as well as different switch
/// cases that share a body.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Returns a [DeclaredVariablePatternResult] with the static type of the
/// variable (possibly inferred) and information about reported errors.
///
/// Stack effect: none. ¿ NHI¿ Nã¿ Nä  ¿ Nó¿ N†¿ Nü  ¿ N©¿ N≥¿ N≤  ¿ N¿¿ N»¿ N«  ¿ NŸ¿ NÍ¿ NÈ   ¿ VÂÅ≠¿ Wœ¿ WœÄ /// Computes the type schema for a variable pattern in a non-assignment
/// context (or a wildcard pattern).  [declaredType] is the explicitly
/// declared type (if present).
///
/// Stack effect: none. ¿ W˘¿ X
¿ X	   ¿ XñÅú¿ Y¿ Ya/// Analyzes a dot shorthand.
/// Saves the [context] for when we resolve the dot shorthand head. ¿ Y$¿ Y0¿ Y/  ¿ Y9¿ YO¿ YN   ¿ Z6Öi¿ \∞¿ \∞ÇR/// Analyzes an expression.  [node] is the expression to analyze, and
/// [schema] is the type schema which should be used for type inference.
///
/// If [continueNullShorting] is `false` (the default), then any null shorting
/// that starts inside [node] will be terminated, and the returned type will
/// be nullable, to reflect the fact that null-aware expressions might
/// evaluate to `null`.
///
/// If [continueNullShorting] is `true`, then null shorting that starts inside
/// [node] will be allowed to continue into the containing expression.
///
/// Stack effect: pushes (Expression). ¿ \«¿ \”¿ \“  ¿ \‹¿ \Ú¿ \Ò  ¿ \ˇ!¿ ]¿ ]  ¿ ]¿ _£ãò¿ d¿ dÑ-/// Analyzes a collection element of the form
/// `if (expression case pattern) ifTrue` or
/// `if (expression case pattern) ifTrue else ifFalse`.
///
/// [node] should be the AST node for the entire element, [expression] for
/// the expression, [pattern] for the pattern to match, [ifTrue] for the
/// "then" branch, and [ifFalse] for the "else" branch (if present).
///
/// [variables] should be a map from variable name to the variable the client
/// wishes to use to represent that variable.  This is used to join together
/// variables that appear in different branches of logical-or patterns.
///
/// Returns a [IfCaseStatementResult] with the static type of [expression] and
/// information about reported errors.
///
/// Stack effect: pushes (Expression scrutinee, Pattern, Expression guard,
/// CollectionElement ifTrue, CollectionElement ifFalse).  If there is no
/// `else` clause, the representation for `ifFalse` will be pushed by
/// [handleNoCollectionElement].  If there is no guard, the representation
/// for `guard` will be pushed by [handleNoGuard]. ¿ d1¿ d@¿ d?  ¿ dI¿ d^¿ d]  ¿ dm¿ d¿ d~  ¿ dã(¿ d´¿ d™  ¿ dπ¿ dœ¿ dŒ  ¿ dŸ¿ dË¿ dÁ  ¿ dÛ¿ e¿ e  ¿ e¿ e!¿ e    ¿ k?ä]¿ nû¿ nûÉ#/// Analyzes a statement of the form `if (expression case pattern) ifTrue` or
/// `if (expression case pattern) ifTrue else ifFalse`.
///
/// [node] should be the AST node for the entire statement, [expression] for
/// the expression, [pattern] for the pattern to match, [ifTrue] for the
/// "then" branch, and [ifFalse] for the "else" branch (if present).
///
/// Returns a [IfCaseStatementResult] with the static type of [expression] and
/// information about reported errors.
///
/// Stack effect: pushes (Expression scrutinee, Pattern, Expression guard,
/// Statement ifTrue, Statement ifFalse).  If there is no `else` clause, the
/// representation for `ifFalse` will be pushed by [handleNoStatement].  If
/// there is no guard, the representation for `guard` will be pushed by
/// [handleNoGuard]. ¿ n∫¿ n≈¿ nƒ  ¿ nŒ¿ n⁄¿ nŸ  ¿ nÈ¿ nÚ¿ nÒ  ¿ n˛¿ o¿ o
  ¿ o¿ o ¿ o  ¿ o+¿ o7¿ o6  ¿ oC¿ oZ¿ oY   ¿ u†Ñ/¿ wﬂ¿ wﬂÇ#/// Analyzes a collection element of the form `if (condition) ifTrue` or
/// `if (condition) ifTrue else ifFalse`.
///
/// [node] should be the AST node for the entire element, [condition] for
/// the condition expression, [ifTrue] for the "then" branch, and [ifFalse]
/// for the "else" branch (if present).
///
/// Stack effect: pushes (Expression condition, CollectionElement ifTrue,
/// CollectionElement ifFalse).  Note that if there is no `else` clause, the
/// representation for `ifFalse` will be pushed by
/// [handleNoCollectionElement]. ¿ wˆ¿ x¿ x  ¿ x¿ x#¿ x"  ¿ x1¿ x@¿ x?  ¿ xK¿ x[¿ xZ  ¿ xg¿ xy¿ xx   ¿ y”É…¿ {Ì¿ {ÌÇ /// Analyzes a statement of the form `if (condition) ifTrue` or
/// `if (condition) ifTrue else ifFalse`.
///
/// [node] should be the AST node for the entire statement, [condition] for
/// the condition expression, [ifTrue] for the "then" branch, and [ifFalse]
/// for the "else" branch (if present).
///
/// Stack effect: pushes (Expression condition, Statement ifTrue, Statement
/// ifFalse).  Note that if there is no `else` clause, the representation for
/// `ifFalse` will be pushed by [handleNoStatement]. ¿ |¿ |¿ |  ¿ |¿ |%¿ |$  ¿ |3¿ |>¿ |=  ¿ |I¿ |U¿ |T   ¿ }†Çç¿ ~¿ ~\/// Analyzes an integer literal, given the type schema [schema].
///
/// Stack effect: none. ¿ ~+¿ ~A¿ ~@   ¿ Ä1çÃ¿ Å¯¿ Å¯Åô/// Analyzes a list pattern.  [node] is the pattern itself, [elementType] is
/// the list element type (if explicitly supplied), and [elements] is the
/// list of subpatterns.
///
/// Returns a [ListPatternResult] with the required type and information about
/// reported errors.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Stack effect: pushes (n * Pattern) where n = elements.length. ¿ ÇI¿ ÇS¿ ÇR  ¿ Ç_¿ Çh¿ Çg  ¿ Çs¿ ÇÑ¿ ÇÉ  ¿ Çî¿ Ç©¿ Ç®   ¿ éÖi¿ é‚¿ é‚Ä¡/// Computes the type schema for a list pattern.  [elementType] is the list
/// element type (if explicitly supplied), and [elements] is the list of
/// subpatterns.
///
/// Stack effect: none. ¿ è$¿ è¿ è  ¿ è+¿ è@¿ è?   ¿ ìnÉ«¿ îç¿ îçÅ/// Analyzes a logical-and pattern.  [node] is the pattern itself, and [lhs]
/// and [rhs] are the left and right sides of the `&&` operator.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Stack effect: pushes (Pattern left, Pattern right) ¿ î´I¿ îÓ¿ îÌ  ¿ î˙¿ ï¿ ï  ¿ ï¿ ï¿ ï  ¿ ï¿ ï ¿ ï   ¿ ó9Åa¿ óÚ¿ óÚÄõ/// Computes the type schema for a logical-and pattern.  [lhs] and [rhs] are
/// the left and right sides of the `&&` operator.
///
/// Stack effect: none. ¿ ò¿ ò¿ ò  ¿ ò¿ ò!¿ ò    ¿ òûç∆¿ ö#¿ ö#ÅV/// Analyzes a logical-or pattern.  [node] is the pattern itself, and [lhs]
/// and [rhs] are the left and right sides of the `||` operator.
///
/// Returns a [LogicalOrPatternResult] with information about reported errors.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Stack effect: pushes (Pattern left, Pattern right) ¿ ö@I¿ öÉ¿ öÇ  ¿ öè¿ öò¿ öó  ¿ ö°¿ öß¿ ö¶  ¿ öØ¿ öµ¿ ö¥   ¿ ¶hÇ¿ ß&¿ ß&Ä†/// Computes the type schema for a logical-or pattern.  [lhs] and [rhs] are
/// the left and right sides of the `|` or `&` operator.
///
/// Stack effect: none. ¿ ßD¿ ßJ¿ ßI  ¿ ßN¿ ßT¿ ßS   ¿ ®äí<¿ ™W¿ ™WÅ†/// Analyzes a map pattern.  [node] is the pattern itself, [typeArguments]
/// contain explicit type arguments (if specified), and [elements] is the
/// list of subpatterns.
///
/// Returns a [MapPatternResult] with the required type and information about
/// reported errors.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Stack effect: pushes (n * MapPatternElement) where n = elements.length. ¿ ™nI¿ ™±¿ ™∞  ¿ ™Ω¿ ™∆¿ ™≈  ¿ ™—P¿ ´¿ ´  ¿ ´'¿ ´<¿ ´;   ¿ ∫ Ñæ¿ ª©¿ ª©Äø/// Computes the type schema for a map pattern.  [typeArguments] contain
/// explicit type arguments (if specified), and [elements] is the list of
/// subpatterns.
///
/// Stack effect: none. ¿ ª«P¿ º¿ º
  ¿ º¿ º2¿ º1   ¿ øåà¿ ¡b¿ ¡bÅõ/// Analyzes a null-check or null-assert pattern.  [node] is the pattern
/// itself, [innerPattern] is the sub-pattern, and [isAssert] indicates
/// whether this is a null-check or a null-assert pattern.
///
/// Returns a [NullCheckOrAssertPatternResult] with information about
/// reported errors.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Stack effect: pushes (Pattern innerPattern). ¿ ¡áI¿ ¡ ¿ ¡…  ¿ ¡÷¿ ¡ﬂ¿ ¡ﬁ  ¿ ¡Ë¿ ¡Ò¿ ¡  ¿ ¬¿ ¬¿ ¬   ¿ «ïÉ$¿ »ê¿ »êÄ€/// Computes the type schema for a null-check or null-assert pattern.
/// [innerPattern] is the sub-pattern and [isAssert] indicates whether this is
/// a null-check or a null-assert pattern.
///
/// Stack effect: none. ¿ »ª¿ »ƒ¿ »√  ¿ »◊¿ »Ê¿ »Â   ¿  Ωå‰¿ Ã@¿ Ã@ÅU/// Analyzes an object pattern.  [node] is the pattern itself, and [fields]
/// is the list of subpatterns.
///
/// Returns a [ObjectPatternResult] with the required type and information
/// about reported errors.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Stack effect: pushes (n * Pattern) where n = fields.length. ¿ ÃZI¿ Ãù¿ Ãú  ¿ Ã©¿ Ã≤¿ Ã±  ¿ ÃΩ7¿ ÃÔ¿ ÃÓ   ¿ ◊•Å)¿ ÿo¿ ÿoÄ¨/// Computes the type schema for an object pattern.  [type] is the type
/// specified with the object name, and with the type arguments applied.
///
/// Stack effect: none. ¿ ÿä¿ ÿö¿ ÿô   ¿ ÿ“ÖÃ¿ Ÿ˛¿ Ÿ˛Äˇ/// Analyzes a patternAssignment expression of the form `pattern = rhs`.
///
/// [node] should be the AST node for the entire expression, [pattern] for
/// the pattern, and [rhs] for the right hand side.
///
/// Stack effect: pushes (Expression, Pattern). ¿ ⁄¿ ⁄(¿ ⁄'  ¿ ⁄1¿ ⁄:¿ ⁄9  ¿ ⁄F¿ ⁄R¿ ⁄Q   ¿ ﬁ¢äÜ¿ ‡∏¿ ‡∏Åﬂ/// Analyzes a `pattern-for-in` statement or element.
///
/// Statement:
/// `for (<keyword> <pattern> in <expression>) <statement>`
///
/// Element:
/// `for (<keyword> <pattern> in <expression>) <body>`
///
/// Stack effect: pushes (Expression, Pattern).
///
/// Returns a [PatternForInResult] containing information on reported errors.
///
/// Note, however, that the caller is responsible for reporting an error if
/// the static type of [expression] is potentially nullable. ¿ ‡“¿ ‡·¿ ‡‡  ¿ ‡Í¿ ‡˘¿ ‡¯  ¿ ·¿ ·¿ ·  ¿ ·$¿ ·9¿ ·8  ¿ ·H%¿ ·b¿ ·a   ¿ È,áA¿ Ît¿ ÎtÇ/// Analyzes a patternVariableDeclaration node of the form
/// `var pattern = initializer` or `final pattern = initializer`.
///
/// [node] should be the AST node for the entire declaration, [pattern] for
/// the pattern, and [initializer] for the initializer.  [isFinal] indicates
/// whether this is a final declaration.
///
/// Returns a [PatternVariableDeclarationAnalysisResult] holding the static
/// type of the initializer and the type schema of the [pattern].
///
/// Stack effect: pushes (Expression, Pattern). ¿ Îõ	¿ Î°¿ Î†  ¿ Î™¿ Î≥¿ Î≤  ¿ Îø¿ ÎÀ¿ Î   ¿ Î›¿ ÎÏ¿ ÎÎ   ¿ qëi¿ ÒÛ¿ ÒÛÅT/// Analyzes a record pattern.  [node] is the pattern itself, and [fields]
/// is the list of subpatterns.
///
/// Returns a [RecordPatternResult] with the required type and information
/// about reported errors.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Stack effect: pushes (n * Pattern) where n = fields.length. ¿ ÚI¿ ÚP¿ ÚO  ¿ Ú\¿ Úe¿ Úd  ¿ Úp7¿ Ú¢¿ Ú°   ¿ﬁÇ≠¿H¿HN/// Computes the type schema for a record pattern.
///
/// Stack effect: none. ¿i7¿õ¿ö   ¿èçΩ¿∑¿∑ÅÓ/// Analyzes a relational pattern.  [node] is the pattern itself, and
/// [operand] is a constant expression that will be passed to the relational
/// operator.
///
/// This method will invoke [resolveRelationalPatternOperator] to obtain
/// information about the operator.
///
/// Returns a [RelationalPatternResult] with the type of the [operand] and
/// information about reported errors.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Stack effect: pushes (Expression). ¿’I¿¿  ¿$¿-¿,  ¿6¿B¿A   ¿PÅæ¿æ¿æR/// Computes the type schema for a relational pattern.
///
/// Stack effect: none.   ¿ñä¿m¿mÅ./// Analyzes an expression of the form `switch (expression) { cases }`.
///
/// Returns a [SwitchExpressionResult] with the static type of the switch
/// expression and information about reported errors.
///
/// Stack effect: pushes (Expression, n * ExpressionCase), where n is the
/// number of cases. ¿ä¿ñ¿ï  ¿ü¿´¿™  ¿π¿æ¿Ω  ¿À¿·¿‡   ¿*†ôl¿+®¿+®Ä÷/// Analyzes a statement of the form `switch (expression) { cases }`.
///
/// Stack effect: pushes (Expression, n * StatementCase), where n is the
/// number of cases after merging together cases that share a body. ¿+ƒ¿+œ¿+Œ  ¿+ÿ¿+‰¿+„  ¿+Ú¿+˝¿+¸   ¿DÉ ¿E™¿E™Åv/// Analyzes a variable declaration of the form `type variable;` or
/// `var variable;`.
///
/// [node] should be the AST node for the entire declaration, [variable] for
/// the variable, and [declaredType] for the type (if present).  [isFinal]
/// indicates whether this is a final declaration.
///
/// Stack effect: none.
///
/// Returns the inferred type of the variable. ¿E◊	¿E›¿E‹  ¿EÊ¿E¿EÔ  ¿E˝¿F¿F  ¿F!¿F0¿F/   ¿Gá¿H"¿H"Ä‚/// Analyzes a wildcard pattern.  [node] is the pattern.
///
/// Returns a [WildcardPatternResult] with information about reported errors.
///
/// See [dispatchPattern] for the meaning of [context].
///
/// Stack effect: none. ¿H?V¿Hè¿Hé  ¿Hõ¿H≠¿H¨  ¿H∂%¿H–¿Hœ   ¿N Åv¿N–¿N–Äí/// Computes the type schema for a wildcard pattern.  [declaredType] is the
/// explicitly declared type (if present).
///
/// Stack effect: none. ¿NÛ%¿O¿O   ¿OöÅï¿Pˆ¿PˆÅH/// Calls the appropriate `analyze` method according to the form of
/// collection [element], and then adjusts the stack as needed to combine
/// any sub-structures into a single collection element.
///
/// For example, if [element] is an `if` element, calls [analyzeIfElement].
///
/// Stack effect: pushes (CollectionElement). ¿Q¿Q¿Q  ¿Q¿Q'¿Q&   ¿Q3Å≥¿Rò¿RòÅ7/// Calls the appropriate `analyze` method according to the form of
/// [node], and then adjusts the stack as needed to combine any
/// sub-structures into a single expression.
///
/// For example, if [node] is a switch expression, calls
/// [analyzeSwitchExpression].
///
/// Stack effect: pushes (Expression). ¿R∞¿Rº¿Rª  ¿R≈¿R€¿R⁄   ¿RÍÅÎ¿T_¿T_ÅX/// Calls the appropriate `analyze` method according to the form of [pattern].
///
/// [context] keeps track of other contextual information pertinent to the
/// matching of the [pattern], such as the context of the top-level pattern,
/// and the information accumulated while matching previous patterns.
///
/// Stack effect: pushes (Pattern). ¿TtI¿T∑¿T∂  ¿T√¿T…¿T»   ¿TŸÄπ¿Un¿Unw/// Calls the appropriate `analyze...Schema` method according to the form of
/// [pattern].
///
/// Stack effect: none. ¿UÑ¿Uä¿Uâ   ¿UñÅz¿VÈ¿VÈÅ=/// Calls the appropriate `analyze` method according to the form of
/// [statement], and then adjusts the stack as needed to combine any
/// sub-structures into a single statement.
///
/// For example, if [statement] is a switch statement, calls
/// [analyzeSwitchStatement].
///
/// Stack effect: pushes (Statement). ¿V˚¿W¿W   ¿WÄ”¿Wr¿WrL/// Infers the type for the [pattern], should be a subtype of [matchedType]. ¿Wü#¿W∏¿W∑  ¿W»¿W⁄¿WŸ   ¿WÎÅO¿Y¿YÅ/// Called after visiting an expression case.
///
/// [node] is the enclosing switch expression, and [caseIndex] is the index of
/// this code path within the switch expression's cases.
///
/// Stack effect: pops (CaseHead, Expression) and pushes (ExpressionCase). ¿Y¿Y&¿Y%  ¿Y+¿Y0¿Y/   ¿Y>ÄÒ¿YC¿YC  ¿Yd¿Yn¿Ym  ¿Y}/¿Y•¿Y§  ¿Y≤9¿Yﬂ¿Yﬁ  ¿YÒ¿Z ¿Yˇ  ¿Z¿Z%¿Z$   ¿Z3Äã¿Zã¿Zã@/// Returns the most recently cached dot shorthand context type.   ¿Z¬ÄÇ¿[#¿[#8/// If the [element] is a map pattern entry, returns it. ¿[6¿[<¿[;   ¿[Hz¿[ö¿[öF/// If [node] is [isRestPatternElement], returns its optional pattern. ¿[∑	¿[Ω¿[º   ¿[∆Ç¿]£¿]£Åì/// Returns an [SwitchExpressionMemberInfo] object describing the [index]th
/// `case` or `default` clause in the switch expression [node].
///
/// Note: it is allowed for the client's AST nodes for `case` and `default`
/// clauses to implement [SwitchExpressionMemberInfo], in which case this
/// method can simply return the [index]th `case` or `default` clause.
///
/// See [analyzeSwitchExpression]. ¿]¡¿]Õ¿]Ã  ¿]“	¿]◊¿]÷   ¿]·Ç&¿_À¿_ÀÅñ/// Returns a [SwitchStatementMemberInfo] object describing the [caseIndex]th
/// `case` or `default` clause in the switch statement [node].
///
/// Note: it is allowed for the client's AST nodes for `case` and `default`
/// clauses to implement [SwitchStatementMemberInfo], in which case this
/// method can simply return the [caseIndex]th `case` or `default` clause.
///
/// See [analyzeSwitchStatement]. ¿_Ë¿_Û¿_Ú  ¿_¯¿_˝¿_¸   ¿`ÄÜ¿`P¿`P=/// Called after visiting the pattern in `if-case` statement. ¿`u¿`â¿`à   ¿`ïo¿`Ÿ¿`Ÿ</// Called after visiting the expression of an `if` element. ¿`˜	¿`˝¿`¸   ¿a|¿aP¿aP@/// Called after visiting the `else` element of an `if` element. ¿ai	¿ao¿an  ¿at¿az¿ay   ¿aà{¿a–¿a–@/// Called after visiting the `then` element of an `if` element. ¿aÈ	¿aÔ¿aÓ  ¿aÙ¿a˙¿a˘   ¿bx¿bM¿bM>/// Called after visiting the expression of an `if` statement. ¿bm¿bx¿bw   ¿bÉÄå¿bœ¿bœD/// Called after visiting the `else` statement of an `if` statement. ¿bÍ¿bı¿bÙ  ¿b˙¿c¿c   ¿cÄã¿c_¿c_D/// Called after visiting the `then` statement of an `if` statement. ¿cz¿cÖ¿cÑ  ¿cä¿cï¿cî   ¿c¢ÄÖ¿cˆ¿cˆL/// Called after visiting the left hand side of a logical-or (`||`) pattern. ¿d¿d ¿d   ¿d+ÅÄ¿eC¿eCÅ/// Called after visiting a merged set of `case` / `default` clauses.
///
/// [node] is the enclosing switch statement, [caseIndex] is the index of the
/// merged `case` or `default` group.
///
/// Stack effect: pops (numHeads * CaseHead) and pushes (CaseHeads). ¿eb¿em¿el  ¿ev¿e{¿ez  ¿eâ¿eù¿eú   ¿eØÅÀ¿g¿gÅX/// Called after visiting a single `case` clause, consisting of a pattern and
/// an optional guard.
///
/// [node] is the enclosing switch statement or switch expression,
/// [caseIndex] is the index of the `case` clause, and [subIndex] is the index
/// of the case head.
///
/// Stack effect: pops (Pattern, Expression) and pushes (CaseHead). ¿g1	¿g7¿g6  ¿gB¿gP¿gO  ¿g^¿gl¿gk   ¿g~Åt¿hñ¿hñÅ/// Called after visiting a `default` clause.
///
/// [node] is the enclosing switch statement or switch expression and
/// [caseIndex] is the index of the `default` clause.
/// [subIndex] is the index of the case head.
///
/// Stack effect: pushes (CaseHead). ¿h©	¿hØ¿hÆ  ¿h∫¿h»¿h«  ¿h÷¿h‰¿h„   ¿hˆÄ±¿ie¿iec/// Called after visiting a rest element in a list pattern.
///
/// Stack effect: pushes (Pattern). ¿iÇ¿iã¿iä  ¿iï¿iõ¿iö   ¿i´Äﬂ¿j%¿j%n/// Called after visiting an entry element in a map pattern.
///
/// Stack effect: pushes (MapPatternElement). ¿j@¿jI¿jH  ¿jW¿j]¿j\  ¿jn¿j~¿j}   ¿jéÄπ¿k¿kl/// Called after visiting a rest element in a map pattern.
///
/// Stack effect: pushes (MapPatternElement). ¿k"¿k+¿k*  ¿k5¿k;¿k:   ¿kKÇ”¿m´¿m´ÇB/// Called after visiting a merged statement case.
///
/// [node] is enclosing switch statement, [caseIndex] is the index of the
/// merged `case` or `default` group.
///
/// If [isTerminating] is `true`, then flow analysis has determined that the
/// case ends in a construct that doesn't complete normally (e.g. a `break`,
/// `return`, `continue`, `throw`, or infinite loop); the client can use this
/// to determine whether a jump is needed to the end of the switch statement.
///
/// Stack effect: pops (CaseHeads, numStatements * Statement) and pushes
/// (StatementCase). ¿m ¿m’¿m‘  ¿m‡¿mÓ¿mÌ  ¿m¸¿n¿n
   ¿n"ÅC¿o@¿o@Å/// Called when visiting a syntactic construct where there is an implicit
/// no-op collection element.  For example, this is called in place of the
/// missing `else` part of an `if` element that lacks an `else` clause.
///
/// Stack effect: pushes (CollectionElement). ¿oZ	¿o`¿o_   ¿oiÅ“¿q¿qÅî/// Called when visiting a `case` that lacks a guard clause.  Since the lack
/// of a guard clause is semantically equivalent to `when true`, this method
/// should behave similarly to visiting the boolean literal `true`.
///
/// [node] is the enclosing switch statement, switch expression, or `if`, and
/// [caseIndex] is the index of the `case` within [node].
///
/// Stack effect: pushes (Expression). ¿q!	¿q'¿q&  ¿q,¿q1¿q0   ¿q?Å1¿rN¿rNÄˇ/// Called when visiting a syntactic construct where there is an implicit
/// no-op statement.  For example, this is called in place of the missing
/// `else` part of an `if` statement that lacks an `else` clause.
///
/// Stack effect: pushes (Statement). ¿r`¿rk¿rj   ¿rtÅs¿s{¿s{Ä˜/// Called before visiting a single `case` or `default` clause.
///
/// [node] is the enclosing switch statement or switch expression and
/// [caseIndex] is the index of the `case` or `default` clause.
/// [subIndex] is the index of the case head. ¿sû	¿s§¿s£  ¿sØ¿sΩ¿sº  ¿sÀ¿sŸ¿sÿ   ¿sÎÅ∞¿up¿upÅk/// Called after visiting the scrutinee part of a switch statement or switch
/// expression.  This is a hook to allow the client to start exhaustiveness
/// analysis.
///
/// [type] is the static type of the scrutinee expression.
///
/// TODO(paulberry): move exhaustiveness analysis into the shared code and
/// eliminate this method.
///
/// Stack effect: none. ¿uÜ¿uñ¿uï   ¿uüV¿u’¿u’./// Queries whether [node] is a dot shorthand. ¿u‰¿u¿uÔ   ¿u˘Ål¿w"¿w"Å/// Queries whether the switch statement or expression represented by [node]
/// was exhaustive.  [expressionType] is the static type of the scrutinee.
///
/// Will only be called if the switch statement or expression lacks a
/// `default` clause, and patterns support is disabled. ¿w;	¿wA¿w@  ¿wF¿wV¿wU   ¿win¿w∑¿w∑F/// Returns whether [node] is a rest element in a list or map pattern. ¿wÃ	¿w“¿w—   ¿w€\¿x¿x4/// Queries whether [pattern] is a variable pattern. ¿x)¿x/¿x.   ¿x;Ä◊¿x”¿x”Äé/// Pops the top of the [_dotShorthands] stack when we're finished resolving
/// the dot shorthand head that requires the recent-most context.   ¿yÅ*¿yÖ¿yÖe/// Pushes the [node] and [context] onto the stack to use when we resolve the
/// dot shorthand head. ¿yù	¿y£¿y¢  ¿y®¿yæ¿yΩ   ¿zDÅ¢¿{;¿{;Ä÷/// Returns the type of the property in [receiverType] that corresponds to
/// the name of the [field].  If the property cannot be resolved, the client
/// should report an error, and return `dynamic` for recovery. ¿{a¿{s¿{r  ¿{Ö$¿{û¿{ù  ¿{Ø0¿{€¿{⁄   ¿{ÍÅÆ¿};¿};Å&/// Resolves the relational operator for [node] assuming that the value being
/// matched has static type [matchedValueType].
///
/// If no operator is found, `null` should be returned.  (This could happen
/// either because the code is invalid, or because [matchedValueType] is
/// `dynamic`). ¿}a¿}j¿}i  ¿}s¿}É¿}Ç   ¿}úÄ¯¿~\¿~\Ä¥/// Records that type inference has assigned a [type] to a [variable].  This
/// is called once per variable, regardless of whether the variable's type is
/// explicit or inferred. ¿~l¿~v¿~u  ¿~¿~è¿~é   ¿~òÄ–¿3¿3Äá/// Computes the type that should be inferred for an implicitly typed variable
/// whose initializer expression has static type [type]. ¿S¿c¿b   ¿lÇ≥¿Ä¿ÄÄù/// Common functionality shared by [analyzeIfStatement] and
/// [analyzeIfCaseStatement].
///
/// Stack effect: pushes (Statement ifTrue, Statement ifFalse). ¿Ä(¿Ä3¿Ä2  ¿Ä8¿ÄC¿ÄB  ¿ÄJ¿ÄV¿ÄU   ¿Ç#É!¿Ç‡¿Ç‡Ä≠/// Common functionality shared by [analyzeIfElement] and
/// [analyzeIfCaseElement].
///
/// Stack effect: pushes (CollectionElement ifTrue,
/// CollectionElement ifFalse). ¿Ç˝	¿É¿É  ¿É¿É¿É  ¿É¿É$¿É#  ¿É0¿É9¿É8   ¿ÖHÅ‹¿ÖO¿ÖO  ¿Ö_¿Ök¿Öj  ¿Öv¿ÖÜ¿ÖÖ   ¿á(äÎ¿á-¿á-  ¿áP¿ág¿áf  ¿áu.¿áí¿áë  ¿á©-¿áª¿á∫  ¿áﬁ/¿à¿à   ¿íÖ0¿í›¿í›Ä©/// If the shape described by [fields] is the same as the shape of the
/// [matchedType], returns matched types for each field in [fields].
/// Otherwise returns `null`. ¿í¯.¿ì!¿ì   ¿ì, ¿ìB¿ìA   ¿óKÉt¿óî¿óî5/// Reports errors for duplicate named record fields. ¿óΩ¿ó∆¿ó≈  ¿ó“.¿ó˚¿ó˙   ¿ö√Å%¿ö»¿ö»  ¿öÓ¿ö˛¿ö˝  ¿õ¿õ¿õ       ã¬ MÄõÄ◊ÄÿÅÅ*ÅGÅkÅìÅîÅÂÇ.ÇDÇHÇÜÇ£Ç∫Ç’ÇÔÇÛÉAÉXÉYÉ¶ÉÑ:ÑPÑyÑzÑ∆ÑÁÖÖÖÖ8ÖUÖeÖkÖmÖnÖßÖ—ÖÈÖÙÖıÜ5ÜEÜFÜÑÜõÜúÜ◊ÜÜÒá8áuáìáîá´á¨áËáÈà-à[àâàèà∆à àÀââAâzâÄâ∂âıää!ä4ä8ä:ä;äzäüä”ä‰äÂã-ã@ãBãCãéã¶ãΩãæã˚ã˝ã˛åMåyå»åﬂå„ç!çiç∑ç◊çÍçÎé4éJécédé{éìé´é∆éÃéŒéœèè(èFè^èhèièÅèéèèèÕè÷èÿèŸêê+êPêvêôêöêªê”êÙëëëëëlë†ë§ë‚ííí6íPíTíìí”í‘ìì%ì&ìtìvìwì«ì˚ìˇî=î^îuîèî™îƒî»îÙî˙ïIïäï—ï“ññ4ñ5ñÜñ‘ó!ó5óSóTó¢óò:òÜòœòÚôôô:ôSôkôàô•ô´ô≠ôÆô¸öMöáöãöÿõ(õyõ úúfúóúõúÏù:ùÅùœùﬁù‚û1û}û üücü®ü¨ü˝†N†õ†È°4°Ñ°ê°î°‰¢2¢Ç¢”¢Ê¢Í£6£}£¿£ƒ§§9§=§á§‘•%•s•¿¶¶a¶u¶y¶ªß
ß$ßsß√®®)®-®x®»©©*©>©U©o©ä©•©Ω©∆©Ï™™™™I™_™s™å™ò™›™„´/´Ä´´´Ê´Á´˝¨¨¨&¨4¨H¨U¨_¨c¨q¨r¨~¨Œ¨œ≠≠>≠≠Ä≠å≠€≠Ì≠ÓÆ&ÆUÆVÆ†ÆÌØØØ\ØjØpØ™Ø∞ØÊ∞%∞+∞E∞å∞€∞Ì±±
±L±Ä±À±≤'≤E≤q≤Ä≤π≤Í≥≥.≥M≥\≥d≥j≥k≥∏≥Û≥ˇ¥!¥n¥u¥Æ¥‘µµ8µÉµøµÛ∂∂7∂b∂í∂ü∂•∂¡∂Ê∑∑∑X∑Ü∑µ∑Ë∏∏T∏~∏Ö∏â∏ä∏€ππUπlπåπ“π◊πÿ∫∫L∫R∫å∫í∫≈∫Íª9ªFªdªáª±ª∏ª˙ºº;ºZº~ºÖº«ºıΩ"Ω<ΩcΩáΩêΩñΩ‚æ/æ}æÕøø&øMøõø≥øÕ¿ @¿ @¿ @¿ @G¿ @M¿ @g¿ @¥¿ @µ¿ @˚¿ AE¿ Aî¿ Aö¿ A‘¿ A⁄¿ B'¿ BT¿ BZ¿ BÉ¿ B∫¿ C	¿ C¿ C3¿ C9¿ C{¿ Cå¿ C«¿ C˝¿ D#¿ D\¿ Dç¿ D®¿ D—¿ Dﬁ¿ D‰¿ E¿ E-¿ E^¿ Ee¿ EÉ¿ Eï¿ E´¿ EÁ¿ F¿ F¿ F3¿ F_¿ Fè¿ FÃ¿ FÒ¿ GB¿ GZ¿ G©¿ G—¿ G˘¿ H)¿ HV¿ Hc¿ Hm¿ Hu¿ H{¿ H°¿ H«¿ H¯¿ I-¿ Iu¿ Iü¿ I¶¿ I™¿ I´¿ I‚¿ IË¿ J¿ J:¿ Jâ¿ J‘¿ K¿ K?¿ Kb¿ Kf¿ Kg¿ Kµ¿ K˝¿ LM¿ Lï¿ L‚¿ M¿ M¿ MA¿ MG¿ Mì¿ M›¿ M„¿ M˝¿ ND¿ Nì¿ N•¿ Nº¿ N’¿ N˜¿ N˝¿ O?¿ O_¿ O™¿ OÂ¿ P¿ PD¿ Pv¿ P®¿ PÈ¿ Q%¿ QY¿ Qt¿ Qù¿ Q»¿ QÓ¿ Q˚¿ R¿ R¿ RB¿ R_¿ Rf¿ R≤¿ R˛¿ S5¿ Sx¿ S´¿ SÁ¿ T8¿ TZ¿ TÑ¿ T¶¿ TÚ¿ U¿ U;¿ UF¿ Uq¿ U∂¿ Uı¿ V#¿ VA¿ Vu¿ V≠¿ V◊¿ Vﬁ¿ V‚¿ V„¿ W-¿ Wv¿ Wò¿ Wû¿ W∏¿ Wı¿ X¿ X¿ X=¿ X^¿ Xè¿ Xì¿ Xî¿ X¥¿ X˙¿ Y ¿ Y5¿ YW¿ Y]¿ Yâ¿ Yœ¿ Y€¿ YÍ¿ YÒ¿ Z¿ Z/¿ Z3¿ Z4¿ Z|¿ Z«¿ ZÕ¿ [¿ [m¿ [∂¿ [–¿ [÷¿ \'¿ \p¿ \v¿ \ü¿ \√¿ \ÿ¿ \˚¿ ]"¿ ])¿ ]K¿ ]ó¿ ]®¿ ]Ÿ¿ ^ ¿ ^¿ ^R¿ ^m¿ ^ù¿ ^∂¿ ^º¿ ^„¿ _¿ _E¿ _Ö¿ _ã¿ _ú¿ _†¿ _°¿ _—¿ ` ¿ `:¿ `@¿ `ç¿ `ÿ¿ a¿ a%¿ au¿ aƒ¿ b¿ b¿ be¿ bé¿ bî¿ b·¿ c-¿ cu¿ c¬¿ c˜¿ d-¿ dE¿ di¿ dá¿ dµ¿ d’¿ dÔ¿ e¿ e)¿ e0¿ eA¿ ec¿ eõ¿ e≠¿ eÀ¿ e“¿ f¿ f4¿ fm¿ f•¿ fÿ¿ fÌ¿ g:¿ gR¿ gÇ¿ g∆¿ gœ¿ gﬁ¿ gÂ¿ h	¿ h,¿ h=¿ hW¿ h{¿ h∏¿ hø¿ h‡¿ hˇ¿ i¿ i=¿ iL¿ iÇ¿ iã¿ iÀ¿ iÿ¿ iˆ¿ i¸¿ j'¿ jR¿ jè¿ jµ¿ j„¿ k¿ k1¿ k8¿ k<¿ k=¿ kç¿ k«¿ kÕ¿ l¿ lg¿ lÆ¿ l¥¿ m¿ m.¿ m4¿ mÅ¿ m–¿ n¿ nh¿ n¿ n∂¿ n ¿ nÂ¿ n˙¿ o¿ o'¿ o?¿ od¿ oj¿ o{¿ où¿ o’¿ oÁ¿ p¿ p¿ pS¿ pn¿ pß¿ pﬂ¿ q¿ q'¿ qt¿ qå¿ qº¿ r ¿ r	¿ r¿ r¿ r ¿ rC¿ rT¿ rn¿ rí¿ rœ¿ r÷¿ r◊¿ s¿ s0¿ sQ¿ sp¿ sâ¿ sÆ¿ sΩ¿ sÛ¿ s¸¿ t<¿ tI¿ tg¿ tm¿ tò¿ t√¿ t¿ u¿ uD¿ uv¿ uí¿ uô¿ uù¿ uû¿ uÈ¿ v¿ v¿ vg¿ vµ¿ vﬂ¿ vÂ¿ w1¿ wÄ¿ wµ¿ wÿ¿ wÚ¿ x
¿ x-¿ xG¿ xc¿ xÅ¿ xà¿ xô¿ x¿¿ y¿ y9¿ y^¿ yè¿ yÃ¿ y–¿ y—¿ z¿ z?¿ zE¿ zì¿ z·¿ {¿ {¿ {_¿ {Ø¿ {Ê¿ |¿ |¿ |/¿ |E¿ |]¿ |c¿ |t¿ |õ¿ |Î¿ }¿ };¿ }l¿ }ô¿ }ù¿ }û¿ }·¿ }Á¿ ~¿ ~J¿ ~e¿ ~ê¿ ~¥¿ ~“¿ ~ﬂ¿ 	¿ 0¿ N¿ Y¿ É¿ £¿ ¡¿ Á¿ ˘¿ Ä#¿ Ä*¿ Ä.¿ Ä/¿ Ä~¿ Ä ¿ ÄÂ¿ ÄÎ¿ Å<¿ ÅS¿ ÅY¿ Åì¿ Åô¿ Å›¿ Ç¿ Ç[¿ Ço¿ Çê¿ Ç≤¿ Çπ¿ Ç˚¿ É¿ É8¿ ÉW¿ Éd¿ É¶¿ É¿¿ É…¿ ÉÓ¿ Ñ¿ ÑM¿ Ñy¿ Ñ≥¿ Ñ›¿ ÑÏ¿ Ö¿ Ö'¿ Ö-¿ Öo¿ Öã¿ Ö∞¿ Öœ¿ ÖÙ¿ Ü<¿ ÜC¿ ÜT¿ Üs¿ Ü§¿ Ü‘¿ Üˆ¿ á!¿ áL¿ áú¿ á¿¿ áÎ¿ à¿ à¿ à"¿ àI¿ àé¿ à∞¿ àÔ¿ â%¿ â@¿ âw¿ âè¿ âú¿ âº¿ â∆¿ â˚¿ ä
¿ ä2¿ ä¿ äù¿ ä•¿ ä´¿ ä·¿ ã¿ ãU¿ ã{¿ ã¡¿ ã˝¿ å1¿ åL¿ åu¿ å†¿ å»¿ å’¿ å€¿ å˝¿ ç¿ ç]¿ çë¿ ç…¿ çÛ¿ ç˙¿ ç˛¿ çˇ¿ éM¿ éò¿ é´¿ é±¿ éÀ¿ é˝¿ è'¿ èI¿ èP¿ èo¿ èΩ¿ è√¿ èƒ¿ è‡¿ ê ¿ ê&¿ ê'¿ êM¿ êr¿ êô¿ êƒ¿ ë	¿ ë+¿ ër¿ ëä¿ ëó¿ ë·¿ ëÎ¿ ë˙¿ í.¿ í6¿ íU¿ íw¿ íô¿ í™¿ íÚ¿ í¸¿ ì¿ ì
¿ ì5¿ ìg¿ ìk¿ ìl¿ ìª¿ ì˛¿ î¿ î>¿ îD¿ î}¿ îß¿ îˆ¿ ï¿ ï¿ ï$¿ ï*¿ ïl¿ ï}¿ ïí¿ ïΩ¿ ï˜¿ ñ ¿ ñ¿ ñ¿ ñ/¿ ñD¿ ño¿ ñ©¿ ñ≤¿ ñΩ¿ ñƒ¿ ñ¿ ó2¿ ó6¿ ó7¿ óÜ¿ óª¿ ó¡¿ ó€¿ ò'¿ òL¿ òn¿ òê¿ òó¿ òõ¿ òú¿ òÍ¿ ô-¿ ô3¿ ôÑ¿ ôä¿ ôƒ¿ ô ¿ ö¿ ö<¿ öã¿ öù¿ ö´¿ öπ¿ öø¿ õ¿ õ<¿ õr¿ õò¿ õ—¿ ú¿ ú¿ úF¿ úS¿ ús¿ úú¿ ú¢¿ ú≥¿ ú÷¿ ù¿ ù¿ ù&¿ ùV¿ ùÑ¿ ùè¿ ùñ¿ ù≥¿ û¿ û¿ û^¿ ûÖ¿ û´¿ û˙¿ üC¿ üI¿ üo¿ üõ¿ ü…¿ üﬁ¿ üÏ¿ †¿ †K¿ †V¿ †]¿ †â¿ †œ¿ †ˆ¿ °!¿ °b¿ °ä¿ °Ÿ¿ ¢'¿ ¢W¿ ¢§¿ ¢Ô¿ £(¿ £X¿ £©¿ £˙¿ §	¿ §D¿ §d¿ §å¿ §∫¿ §≈¿ §Õ¿ §”¿ • ¿ •n¿ •Ç¿ •£¿ • ¿ •˚¿ ¶0¿ ¶Z¿ ¶a¿ ¶e¿ ¶f¿ ¶¥¿ ¶Ô¿ ¶ı¿ ß¿ ßZ¿ ß°¿ ßÌ¿ ®<¿ ®`¿ ®É¿ ®á¿ ®à¿ ®’¿ ©!¿ ©<¿ ©B¿ ©í¿ ©©¿ ©Ø¿ ©È¿ ©Ô¿ ™=¿ ™j¿ ™π¿ ™Õ¿ ´¿ ´#¿ ´E¿ ´L¿ ´é¿ ´™¿ ´»¿ ´Ï¿ ¨¿ ¨4¿ ¨_¿ ¨ì¿ ¨†¿ ¨·¿ ≠¿ ≠-¿ ≠Z¿ ≠ê¿ ≠ ¿ ≠Ù¿ Æ ¿ ÆL¿ ÆÜ¿ ÆÆ¿ Æÿ¿ Ø¿ Ø¿ ØD¿ Øw¿ Ø£¿ Ø´¿ Ø±¿ ØÁ¿ Øˇ¿ ∞¿ ∞"¿ ∞Q¿ ∞ù¿ ∞Ì¿ ±¿ ±:¿ ±@¿ ±\¿ ±Å¿ ±†¿ ±‰¿ ±Î¿ ±¸¿ ±˝¿ ≤%¿ ≤U¿ ≤w¿ ≤¢¿ ≤„¿ ≤˘¿ ≥¿ ≥ ¿ ≥(¿ ≥.¿ ≥/¿ ≥_¿ ≥Å¿ ≥“¿ ≥Ì¿ ¥7¿ ¥_¿ ¥∞¿ ¥Á¿ µ¿ µ¿ µC¿ µà¿ µ™¿ µ·¿ µ¸¿ ∂3¿ ∂K¿ ∂X¿ ∂x¿ ∂Ç¿ ∂∂¿ ∂æ¿ ∂ƒ¿ ∑¿ ∑?¿ ∑x¿ ∑û¿ ∑‰¿ ∏ ¿ ∏T¿ ∏o¿ ∏ò¿ ∏√¿ ∏Î¿ ∏¯¿ ∏˛¿ π¿ π;¿ π¿ πÖ¿ π¶¿ π»¿ π¸¿ ∫4¿ ∫f¿ ∫í¿ ∫º¿ ∫√¿ ∫«¿ ∫»¿ ª¿ ª_¿ ªr¿ ªx¿ ªí¿ ª√¿ º¿ º¿ º;¿ ºB¿ ºc¿ ºâ¿ º•¿ ºœ¿ º˝¿ Ω¿ Ω¿ Ω¿ Ω¿ Ω=¿ Ωb¿ Ω≥¿ ΩŒ¿ æ¿ æ*¿ æ5¿ æV¿ æ|¿ æç¿ æÿ¿ æ‚¿ æÍ¿ æ¿ ø¿ øB¿ ø~¿ øÖ¿ øâ¿ øä¿ ø’¿ ¿¿ ¿\¿ ¿b¿ ¿™¿ ¿¡¿ ¿«¿ ¡¿ ¡¿ ¡:¿ ¡É¿ ¡“¿ ¡‰¿ ¬ ¿ ¬¿ ¬#¿ ¬e¿ ¬v¿ ¬¨¿ ¬ﬁ¿ √¿ √j¿ √Ñ¿ √Æ¿ √µ¿ √Ë¿ ƒ!¿ ƒR¿ ƒm¿ ƒñ¿ ƒ£¿ ƒ√¿ ƒÏ¿ ≈¿ ≈T¿ ≈Å¿ ≈ú¿ ≈«¿ ≈‘¿ ≈⁄¿ ∆(¿ ∆@¿ ∆i¿ ∆j¿ ∆ô¿ ∆ ¿ ∆ˇ¿ «,¿ «]¿ «á¿ «é¿ «í¿ «ì¿ «€¿ »,¿ »Y¿ »_¿ »y¿ »∑¿ »”¿ »Ô¿ »ˆ¿ …
¿ …:¿ …g¿ …p¿ …}¿ …∆¿  ¿  e¿  ã¿  ∞¿  ∂¿  ∫¿  ª¿ À	¿ À+¿ À1¿ À~¿ Àõ¿ À°¿ À€¿ À·¿ Ã#¿ ÃV¿ Ã•¿ Ãπ¿ Ãˆ¿ Ã˝¿ Õ?¿ Õx¿ Õ≥¿ Õ¥¿ Õ˛¿ Œ#¿ Œ8¿ Œ?¿ Œ[¿ ŒÄ¿ Œü¿ Œ¶¿ Œß¿ ŒÒ¿ œ¿ œQ¿ œ~¿ œ´¿ œ‹¿ –¿ –¿ –¿ –T¿ –ç¿ –≥¿ –˘¿ —5¿ —i¿ —Ñ¿ —≠¿ —ÿ¿ “ ¿ “¿ “¿ “¿ “%¿ “c¿ “Ø¿ “‘¿ “ˇ¿ ” ¿ ”H¿ ”b¿ ”o¿ ”ø¿ ‘¿ ‘U¿ ‘É¿ ‘Ø¿ ‘÷¿ ‘¿ ’¿ ’0¿ ’?¿ ’a¿ ’ú¿ ’∑¿ ’ø¿ ÷¿ ÷4¿ ÷:¿ ÷n¿ ÷o¿ ÷ì¿ ÷µ¿ ◊¿ ◊5¿ ◊m¿ ◊ó¿ ◊û¿ ◊¢¿ ◊£¿ ◊Ì¿ ÿ8¿ ÿ>¿ ÿX¿ ÿ°¿ ÿÀ¿ ÿœ¿ ÿ–¿ Ÿ¿ Ÿ!¿ Ÿn¿ Ÿ§¿ Ÿ™¿ Ÿ‹¿ ⁄¿ ⁄-¿ ⁄B¿ ⁄V¿ ⁄\¿ ⁄m¿ ⁄∂¿ ⁄˙¿ €¿ €H¿ €Å¿ €π¿ €Œ¿ ‹¿ ‹3¿ ‹U¿ ‹á¿ ‹∑¿ ‹˚¿ ›¿ ›¿ ›¿ ›C¿ ›ì¿ ›π¿ ›ﬂ¿ ›Â¿ ﬁ¿ ﬁ+¿ ﬁ[¿ ﬁ¿ ﬁî¿ ﬁõ¿ ﬁü¿ ﬁ†¿ ﬁÿ¿ ﬁﬁ¿ ﬁÔ¿ ﬂ-¿ ﬂ3¿ ﬂB¿ ﬂ{¿ ﬂÅ¿ ﬂ≥¿ ﬂπ¿ ‡	¿ ‡¿ ‡]¿ ‡ú¿ ‡Œ¿ ‡Ê¿ ·¿ · ¿ ·D¿ ·o¿ ·v¿ ·á¿ ·‘¿ ‚¿ ‚F¿ ‚Ç¿ ‚π¿ ‚À¿ ‚Á¿ ‚Ó¿ „	¿ „
¿ „?¿ „j¿ „ü¿ „◊¿ „ˆ¿ ‰'¿ ‰U¿ ‰ç¿ ‰π¿ ‰»¿ Â¿ Â4¿ ÂN¿ Ât¿ Â¢¿ Â±¿ Â›¿ ÂÂ¿ ÂÎ¿ Ê¿ Ê ¿ ÊY¿ Êë¿ Ê¶¿ ÊÛ¿ Á¿ Á-¿ Á]¿ Á°¿ Á™¿ Áπ¿ Á¿¿ Á‰¿ ÁÂ¿ Ë¿ Ë¿ Ë3¿ ËP¿ ËQ¿ Ët¿ Ëî¿ Ë∫¿ ËÍ¿ È¿ È%¿ È)¿ È*¿ Èg¿ È´¿ È±¿ Èˇ¿ ÍN¿ Íy¿ Í¿ ÍÕ¿ Î¿ Î¿ ÎI¿ Îó¿ Î¶¿ Îª¿ ÎŸ¿ ÎÙ¿ Î˚¿ Ï¿ ÏU¿ Ïç¿ Ï†¿ Ïµ¿ Ïº¿ Ï◊¿ Ì¿ Ì ¿ Ì7¿ Ì>¿ Ìw¿ ÌØ¿ Ìƒ¿ Ó¿ Ó+¿ ÓM¿ Ó}¿ Ó¡¿ Ó ¿ ÓŸ¿ Ó‡¿ Ô¿ Ô¿ Ô'¿ ÔK¿ Ôà¿ Ôè¿ Ô∫¿ Ôﬁ¿ ¿ ?¿ c¿ j¿ n¿ o¿ º¿ ﬁ¿ ‰¿ Ò1¿ ÒN¿ ÒT¿ Òé¿ Òî¿ Ò÷¿ Ú	¿ ÚX¿ Úl¿ Ú©¿ Ú∞¿ ÚÚ¿ Û-¿ Ûm¿ Ûn¿ Ûß¿ Û‚¿ Û„¿ Ù¿ ÙZ¿ ÙÇ¿ Ù”¿ ı¿ ı8¿ ıR¿ ıç¿ ıÀ¿ ˆ
¿ ˆH¿ ˆP¿ ˆl¿ ˆr¿ ˆs¿ ˆ©¿ ˆŸ¿ ˜ ¿ ˜¿ ˜¿ ˜¿ ˜/¿ ˜X¿ ˜ò¿ ˜∆¿ ¯¿ ¯"¿ ¯<¿ ¯c¿ ¯°¿ ¯‡¿ ˘+¿ ˘3¿ ˘9¿ ˘r¿ ˘ï¿ ˘∫¿ ˘·¿ ˘Í¿ ˙¿ ˙¿ ˙2¿ ˙W¿ ˙v¿ ˙}¿ ˙~¿ ˙è¿ ˙√¿ ˚¿ ˚¿ ˚-¿ ˚6¿ ˚V¿ ˚ä¿ ˚º¿ ˚Á¿ ˚Ò¿ ¸ ¿ ¸7¿ ¸?¿ ¸w¿ ¸•¿ ¸›¿ ˝	¿ ˝¿ ˝K¿ ˝Q¿ ˝Ö¿ ˝Ü¿ ˝¡¿ ˝˙¿ ˛ ¿ ˛f¿ ˛¢¿ ˛÷¿ ˛Ò¿ ˇ¿ ˇE¿ ˇm¿ ˇz¿ ˇÄ¿ ˇÅ¿ ˇæ¿ ˇÌ¿ ¿ ¿ 5¿ Z¿ }¿ °¿ ®¿ Ã¿ Ó¿:¿n¿¶¿–¿◊¿€¿‹¿¿¿1¿e¿¢¿©¿Ÿ¿¿L¿ô¿∫¿‘¿˙¿	¿,¿4¿:¿à¿å¿ç¿’¿$¿4¿:¿Ö¿´¿±¿˛¿'¿-¿g¿m¿ñ¿—¿ ¿2¿J¿P¿í¿£¿Ÿ¿¿:¿s¿§¿ø¿Ë¿ı¿˚¿	J¿	V¿	n¿	u¿	≤¿	‚¿
¿
?¿
Q¿
X¿
á¿
≈¿
À¿
Ã¿
Ù¿¿X¿Ä¿æ¿À¿˘¿ˇ¿K¿a¿ã¿ú¿±¿˜¿#¿,¿9¿h¿n¿â¿¥¿Î¿¿*¿n¿û¿÷¿Û¿¿P¿_¿g¿ç¿™¿«¿“¿¿S¿p¿ü¿Æ¿∂¿º¿‰¿¿5¿j¿ú¿“¿¿B¿I¿M¿N¿á¿ç¿ß¿·¿2¿}¿ƒ¿Ë¿¿¿¿Z¿`¿¨¿‰¿Í¿6¿M¿Ü¿õ¿µ¿«¿Ë¿Ó¿ˇ¿ ¿P¿ù¿≠¿¥¿˚¿2¿C¿a¿h¿É¿Æ¿˜¿¯¿D¿p¿ö¿π¿“¿˚¿¿U¿Ä¿–¿Ë¿¿4¿Ñ¿’¿¿H¿Ö¿ï¿æ¿«¿Ò¿¿O¿õ¿œ¿¿2¿z¿´¿∆¿Â¿$¿b¿}¿õ¿Ø¿…¿‡¿˛¿¿$¿B¿l¿¢¿Ï¿˚¿ ¿ ¿ F¿ m¿ ç¿ ∑¿ ˙¿!¿!E¿!n¿!ó¿!±¿!Î¿" ¿"<¿"K¿"ò¿"»¿"¯¿#@¿#N¿#ö¿#≠¿#—¿$¿$)¿$d¿$u¿$Ø¿$π¿$Ò¿%7¿%t¿%¬¿&
¿&4¿&>¿&h¿&±¿& ¿&‹¿&Ì¿'¿'¿'C¿'|¿'Ñ¿'–¿(
¿(#¿(0¿(e¿(ê¿(®¿(µ¿)¿)&¿)>¿)K¿)y¿)Å¿)ô¿)°¿)ß¿)›¿*¿*(¿*@¿*t¿*í¿*ô¿*ù¿*û¿*Ê¿*Ï¿+7¿+}¿+¿¿+‘¿+Ó¿,¿,¿,¿,S¿,d¿,Ç¿,â¿,§¿,Œ¿-¿-3¿-W¿-è¿-≈¿-˘¿.:¿.z¿.™¿.Í¿/¿/W¿/ô¿/ﬂ¿/˚¿0B¿0É¿0°¿0«¿0¯¿1¿1/¿1O¿1n¿1y¿1î¿1≥¿1Ú¿20¿2K¿2i¿2}¿2ó¿2Æ¿2Ã¿2„¿2Ú¿3¿3:¿3p¿3∫¿3…¿3ﬁ¿3Î¿4¿40¿4P¿4z¿4Ω¿4 ¿5¿5B¿5`¿5¿5π¿5Œ¿6
¿6¿6f¿6≤¿6‚¿70¿7X¿7f¿7¨¿7Ó¿8¿8-¿89¿8Ñ¿8ï¿8≤¿8¸¿9¿9H¿9q¿9µ¿9Ω¿9˝¿:#¿:b¿:é¿:†¿:Õ¿:⁄¿;¿;N¿;u¿;ä¿;º¿;¯¿<;¿<F¿<N¿<í¿<›¿=¿=H¿=n¿=v¿=¡¿=¯¿>6¿>\¿>é¿>Ø¿>ˆ¿?B¿?J¿?k¿?y¿?ó¿?¬¿?À¿@¿@¿@U¿@l¿@ó¿@≠¿@»¿@¯¿A.¿Aq¿A£¿A∞¿AÙ¿B$¿B*¿BV¿Bà¿B¶¿B»¿Bˆ¿C@¿Cd¿C∞¿C‰¿D¿D	¿D¿D¿DT¿Dk¿Dq¿D¿¿E¿EB¿EH¿Eb¿Eh¿Eô¿E”¿E‚¿E˘¿F¿F8¿F?¿Fâ¿F∂¿FÙ¿G¿G¿G¿GM¿GS¿G£¿G©¿G„¿GÈ¿H¿H;¿Hä¿Hó¿H≤¿H›¿H‰¿I&¿Ia¿Iö¿Iÿ¿J ¿J^¿Jî¿J±¿J‹¿K	¿K3¿KB¿KJ¿KP¿KQ¿Kl¿Kå¿KΩ¿K‰¿L¿L¿L¿L:¿L@¿LA¿Lx¿L°¿L‡¿M	¿M ¿MG¿MP¿MV¿M|¿M∞¿MË¿N¿N¿N¿N¿Nl¿Nô¿Nü¿Nπ¿NÔ¿O¿O!¿OA¿Ob¿Oì¿Oó¿Oò¿Oﬁ¿P*¿Pe¿Pk¿Pπ¿Pø¿PÔ¿Q0¿Q1¿Qw¿Qπ¿QË¿QÓ¿R)¿RJ¿RP¿Ry¿R¨¿R¡¿R‚¿RÁ¿RË¿S9¿S?¿Så¿S€¿T#¿T)¿TO¿Tp¿Tø¿T—¿T÷¿T◊¿U&¿U7¿U=¿UW¿Uì¿Uî¿U⁄¿V!¿VO¿VU¿Vî¿V¥¿V∫¿V‚¿W¿W¿Wa¿Wõ¿Wƒ¿W‚¿WË¿WÈ¿X¿X¿Xp¿X´¿X±¿X˛¿Y;¿Y<¿Y`¿Yy¿YÆ¿YÌ¿Z¿Z*¿Z0¿Z1¿Zt¿Zø¿Z¿¿Z˚¿[E¿[F¿[è¿[√¿[ƒ¿\¿\T¿\Z¿\®¿\Ù¿]=¿]C¿]h¿]°¿]ﬁ¿]ﬂ¿^/¿^p¿^v¿^ƒ¿_¿_\¿_b¿_Ü¿_…¿`¿`	¿`I¿`í¿`ì¿`“¿a¿a¿aI¿aÖ¿aÜ¿a…¿b¿b¿bF¿bÄ¿bÅ¿b»¿c¿c¿cX¿cü¿c†¿cÔ¿d(¿d)¿dq¿dw¿d«¿dÔ¿dı¿e<¿e^¿er¿eÖ¿eß¿e¨¿e≠¿e˝¿f¿f¿fa¿f≤¿f ¿f–¿g¿g-¿g>¿gZ¿gu¿g{¿g|¿g¨¿g≤¿g˙¿h2¿hb¿hh¿hè¿h•¿h∂¿h“¿hÌ¿hÛ¿hÙ¿i2¿i8¿i^¿i®¿i©¿iË¿iÓ¿j¿j<¿jS¿jj¿jÜ¿jã¿jå¿j…¿jœ¿jˇ¿kH¿kI¿k~¿kÑ¿k–¿k¯¿k˛¿lM¿lú¿lÏ¿m<¿mB¿mç¿m§¿m∆¿m‹¿m¯¿n¿n¿n ¿nl¿nπ¿o¿o	¿o9¿of¿og¿o∂¿p¿pK¿pQ¿p°¿p›¿p„¿q¿q<¿q=¿qâ¿q’¿r¿r¿rG¿rq¿rr¿r¥¿r∫¿s¿sD¿st¿sö¿s´¿s«¿s‚¿sË¿sÈ¿t8¿tÜ¿tñ¿tú¿tŸ¿tﬂ¿u,¿uI¿uO¿ui¿uú¿uù¿uŒ¿uˆ¿u˜¿vF¿vì¿vô¿v·¿w¿wf¿wg¿w∞¿wÿ¿wŸ¿x¿x8¿x9¿xà¿xÃ¿xÓ¿y¿y¿y¿yd¿y~¿y»¿z¿z7¿z=¿zA¿zB¿zè¿zﬁ¿{¿{]¿{Å¿{´¿{·¿{Á¿{Ë¿|8¿|j¿|p¿|æ¿}	¿}¿}]¿}o¿}î¿}ô¿}ö¿}È¿~9¿~U¿~ï¿~ñ¿~Á¿"¿i¿j¿®¿»¿Œ¿Ä¿Ä`¿Äq¿Äê¿Äæ¿Äﬂ¿Ä˙¿Å¿Å<¿ÅI¿Åm¿Åè¿Å±¿Å‚¿ÅË¿Ç¿Ç ¿Ç!¿Ç]¿Ç{¿ÇÅ¿Ç∑¿ÇŸ¿Ç˘¿É¿É¿É,¿ÉA¿ÉG¿ÉX¿Éà¿É¥¿É›¿É¯¿Ñ¿ÑB¿ÑO¿Ñs¿Ñ¶¿Ñ»¿Ñ˜¿Ñ˝¿ÖA¿ÖE¿ÖF¿Öç¿Öﬁ¿Ü,¿Ü{¿Üé¿Üœ¿á
¿á¿á!¿á%¿á&¿áL¿áq¿á•¿á⁄¿à¿à¿à&¿àq¿à•¿àÌ¿àı¿â¿â¿âb¿ââ¿âØ¿â„¿ä-¿äH¿äp¿äë¿äº¿äÎ¿ã¿ãB¿ãL¿ãó¿ãﬁ¿ãı¿å!¿åS¿ån¿å¿å™¿å‘¿ç¿ç'¿çF¿çY¿ç~¿ç•¿ç±¿çﬁ¿é¿é?¿éf¿ér¿éñ¿éﬂ¿è¿è7¿èY¿è}¿èå¿èò¿è¢¿è™¿è»¿èÔ¿ê¿ê,¿êL¿êg¿êØ¿êÈ¿ë7¿ëj¿ë¶¿ë≥¿ë¯¿í¿í
¿í¿í¿í¿í^¿í•¿í≈¿íÙ¿ì(¿ìN¿ìT¿ìã¿ì◊¿ì¸¿î¿î¿î)¿îA¿îs¿î°¿îﬂ¿ï ¿ï!¿ï;¿ïg¿ïà¿ïü¿ï©¿ïø¿ïŒ¿ï¸¿ñ¿ñ¿ñM¿ñU¿ñr¿ñx¿ñ°¿ñ¥¿ñ∫¿ñÎ¿ñ˛¿ó¿ó¿ó1¿óD¿óH¿óI¿óÅ¿óπ¿óŒ¿ò¿ò¿ò+¿òp¿òû¿òŸ¿ò˙¿ô¿ô]¿ô}¿ô∆¿ôÚ¿ö
¿ö*¿öH¿öU¿öf¿öã¿öï¿öù¿ö£¿öº¿ö¿¿ö¡¿öÍ¿õ¿õ¿õ$¿õ\¿õî¿õÂ¿õÈ¿õÎ¿õÏ¿ú=¿ú}¿ú†¿ú∑¿ú—¿úÏ¿ù¿ù¿ù6¿ù>¿ù@¿ùh¿ù∂¿ù¿û¿û8¿û`¿ûÅ¿ûß¿û≠¿ûÆ¿ûÈ¿ûÔ¿ü.¿ü[¿ü{¿üö¿ü∫¿ü¿¿ü¡¿ü˝¿†#¿†O¿†i¿†¢¿†‹¿†‚¿†„¿°-¿°L¿°s¿°è¿°¨¿°≤¿°≥¿°È¿°Ô¿¢¿¢H¿¢I¿¢ñ¿¢·¿£¿£.¿£N¿£o¿£u¿£v¿£≈¿§¿§?¿§]¿§|¿§Ç¿§É¿§Ã¿§ˇ¿•'¿•E¿•d¿•Ñ¿•ä¿•ã¿•◊¿¶¿¶¿¶^¿¶ü¿¶•¿¶‰¿ß¿ß*¿ßN¿ßp¿ßv¿ßw¿ß≈¿ßˇ¿®¿®V¿®ù¿®È¿®ı¿©'¿©E¿©`¿©¿©ü¿©•¿©¶¿©˜¿©˝¿™L¿™è¿™ï¿™’¿´¿´¿´:¿´@¿´A¿´ê¿´ﬂ¿¨¿¨1¿¨P¿¨q¿¨w¿¨x¿¨√¿¨ﬂ¿≠ ¿≠>¿≠\¿≠b¿≠c¿≠û¿≠§¿≠Â¿Æ/¿Æ0¿ÆÄ¿Æ…¿Æÿ¿Æﬁ¿Ø.¿Øe¿Øã¿Ø®¿Øƒ¿Ø ¿ØÀ¿∞¿∞c¿∞≠¿∞—¿∞Ô¿±¿± ¿±"¿±#¿±q¿±¨¿±‘¿≤ ¿≤p¿≤¡¿≥¿≥&¿≥,¿≥u¿≥ï¿≥ó¿≥ò¿≥Œ¿≥“¿¥¿¥,¿¥J¿¥K¿¥q¿¥r¿¥ø¿µ¿µ`¿µ®¿µ–¿∂¿∂¿∂)¿∂*¿∂P¿∂Q¿∂x¿∂y¿∂ë¿∂¥¿∂ﬂ¿∑¿∑A¿∑l¿∑ò¿∑û¿∑†   CaseHeadOrDefaultInfo"JoinedPatternVariableInconsistencyJoinedPatternVariableLocationMapPatternEntryRecordPatternFieldRelationalOperatorKindRelationalOperatorResolutionSwitchExpressionMemberInfoSwitchStatementMemberInfoTypeAnalyzerTypeAnalyzerErrorsTypeAnalyzerErrorsBaseTypeAnalyzerOptions  ¨û